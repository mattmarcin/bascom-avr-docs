# Compiler Directives

> Compiler directives ($) for build configuration

## #IF ELSE ELSEIF ENDIF

Action

Conditional compilation directives intended for conditional compilation.

Syntax

```vb
#IF condition

#ELSEIF condition

#ELSE

#ENDIF

```
Remarks

Conditional compilation is supported by the compiler.

What is conditional compilation?

Conditional compilation will only compile parts of your code that meet the criteria of the condition.

By default all your code is compiled.

Conditional compilation needs a [constant](const.md) to test.

So before a condition can be tested you need to define a constant.

CONST test = 1

```vb
#IF TEST

Print "This will be compiled"

#ELSE

Print "And this not"

#ENDIF

```
![notice](notice.jpg) Note that there is no THEN and that you need to use #ENDIF which has no space between END and IF , so #END IF is wrong!

You can nest the conditions and the use of #ELSE and #ELSEIF is optional.

There are a few internal constants that you can use. These are generated by the compiler:

_CHIP = 0

_RAMSIZE = 128

_ERAMSIZE = 128

_SIM = 0

_XTAL = 4000000

_BUILD = 11162

_CHIP is an integer that specifies the chip, in this case the 2313

_RAMSIZE is the size of the SRAM

_ERAMSIZE is the size of the EEPROM

_SIM is set to 1 when the $SIM directive is used

_XTAL contains the value of the specified crystal

_BUILD is the build number of the compiler.

The build number can be used to write support for statements that are not available in a certain version :

#IF _BUILD >= 11162

s = Log(1.1)

```vb
#ELSE

Print "Sorry, implemented in 1.11.6.2"

#ENDIF

```
Conditional compilation allows you to create different versions of your program but that you keep one source file.

For example you could make a multi lingual program like this :

CONST LANGUAGE=1

```vb
'program goes here

#IF LANGUAGE=1

```
DATA "Hello"

```vb
#ENDIF

#IF LANGUAGE=2

```
DATA "Guten tag"

#ENDIF

By changing just one constant you can have for example English or German data lines.

Conditional compilation does work with the $REGFILE directive but you need to set the option 'Use New Method' in Environment IDE options.

VAREXIST

A special check was added to 1.11.8.1 to test for existence of dimmed/defined constants or variables.

```vb
#IF varexist("S")

' the variable S was dimensioned so we can use it here

#ELSE

' when it was not dimmed and we do need it, we can do it here

DIM S as BYTE

#ENDIF

```
The Editor can show non included code with a different font color. This makes it more clear which code is included.

See Also

[CONST](const.md) , [Edit Show Excluded Code](edit_show_excluded_code.md)

---

## $AESKEY

Action

This directive accepts a 16 byte AES key and informs the compiler to encrypt the binary image.

Syntax

$AESKEY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16

Remarks

$AESKEY accepts 16 parameters. These are the 16 bytes which form a 128 bit key.

When your code is compiled, the resulting binary code will be encrypted with the provided key.

A boot loader could then use AES and decrypt the binary file before writing to flash memory.

![notice](notice.jpg)Only the binary image is encrypted, the HEX file is not encrypted!

You can not simulate an encrypted program. Add this option when your project is ready.

See also

[$XTEAKEY](xteakey.md) , [AESENCRYPT](aesencrypt.md) , [AESDECRYPT](aesdecrypt.md)

Example

See the Samples\boot\xmega_dos_boot_AES.zip , an Xmega boot loader with AES decryption.

---

## $BAUD1

Action

Instruct the compiler to set the baud rate for the second hardware UART.

Syntax

$BAUD1 = var

Remarks

Var | The baud rate that you want to use. This must be a numeric constant.  
---|---  
  
In the generated report, you can view which baud rate is actually generated.

When you simulate a program you will not notice any problems when the baud rate is not set to the value you expected. In real hardware a wrong baud rate can give weird results on the terminal emulator screen. For best results use a crystal that is a multiple of the baud rate.

Some AVR chips have 2 UARTS. For example the Mega161, Mega162, Mega103 and Mega128. There are several other's and some new chips even have 4 UARTS.

In the simulator you need to select the UART1-TAB to view the output of the UART1, or to send data to this UART.

See also

[$CRYSTAL](crystal_1.md) , [BAUD](baud_2.md) , [$BAUD](baud_1.md)

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega162

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates BAUD1 directive and BAUD1 statement

'-------------------------------------------------------------------------------

$regfile = "M162def.dat"

$baud1 = 2400

$crystal= 14000000 ' 14 MHz crystal

$hwstack = 32

$swstack = 8

$framesize = 24

```
Open "COM2:" For BINARY As #1

```vb
Print #1 , "Hello"

'Now change the baud rate in a program

```
Baud1 = 9600 '

Print #1 , "Did you change the terminal emulator baud rate too?"

Close #1

End

---

## $BGF

Action

Includes a BASCOM Graphic File.

Syntax

$BGF "file"

Remarks

file | The file name of the BGF file to include.  
---|---  
  
Use SHOWPIC to display the BGF file. $BGF only task is to store the picture into the compressed BASCOM Graphics Format(BGF).

See also

[SHOWPIC](showpic.md) , [PSET](pset.md) , [CONFIG GRAPHLCD](config_graphlcd.md)

Example

```vb
'-----------------------------------------------------------------  
' (c) 1994-2025 MCS Electronics  
' T6963C graphic display support demo  
'-----------------------------------------------------------------  
  
'The connections of the LCD used in this demo  
'LCD pin connected to  
' 1 GND GND  
'2 GND GND  
'3 +5V +5V  
'4 -9V -9V potmeter  
'5 /WR PORTC.0  
'6 /RD PORTC.1  
'7 /CE PORTC.2  
'8 C/D PORTC.3  
'9 NC not conneted  
'10 RESET PORTC.4  
'11-18 D0-D7 PA  
'19 FS PORTC.5  
'20 NC not connected  
  
$crystal = 8000000  
$regfile = "m32def.dat"  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
  
'First we define that we use a graphic LCD  
  
Config Graphlcd = 240x128 , Dataport = Porta , Controlport = Portc , Ce = 2 , Cd = 3 , Wr = 0 , Rd = 1 , Reset = 4 , Fs = 5 , Mode = 8  
'The dataport is the portname that is connected to the data lines of the LCD  
'The controlport is the portname which pins are used to control the lcd  
'CE, CD etc. are the pin number of the CONTROLPORT.  
' For example CE =2 because it is connected to PORTC.2  
'mode 8 gives 240 / 8 = 30 columns , mode=6 gives 240 / 6 = 40 columns  
  
'Dim variables (y not used)  
Dim X As Byte , Y As Byte  
  
  
'Clear the screen will both clear text and graph display  
```
Cls  
```vb
'Other options are :  
' CLS TEXT to clear only the text display  
' CLS GRAPH to clear only the graphical part  
  
```
Cursor Off  
  
```vb
Wait 1  
'locate works like the normal LCD locate statement  
' LOCATE LINE,COLUMN LINE can be 1-8 and column 0-30  
  
  
```
Locate 1 , 1  
  
'Show some text  
Lcd "MCS Electronics"  
'And some othe text on line 2  
Locate 2 , 1 : Lcd "T6963c support"  
Locate 3 , 1 : Lcd "1234567890123456789012345678901234567890"  
  
Wait 2  
  
Cls Text  
```vb
' draw a line using PSET X,Y, ON/OFF  
' PSET on.off param is 0 to clear a pixel and any other value to turn it on  
For X = 0 To 140  
```
Pset X , 20 , 255 ' set the pixel  
```vb
Next  
  
Wait 2  
  
  
'Now it is time to show a picture  
'SHOWPIC X,Y,label  
'The label points to a label that holds the image data  
```
Showpic 0 , 0 , Plaatje  
  
Wait 2  
Cls Text ' clear the text  
```vb
End  
  
  
  
'This label holds the mage data  
```
Plaatje:  
```vb
'$BGF will put the bitmap into the program at this location  
$bgf "mcs.bgf"  
  
'You could insert other picture data here

```

---

## $BOOT

Action

Instruct the compiler to include boot loader support.

Syntax

$BOOT = address

Remarks

address | The boot loader address. This is a WORD address.   
---|---  
  
Some new AVR chips have a special boot section in the upper memory of the flash.

By setting some fuse bits you can select the code size of the boot section.

The code size also determines the address of the boot loader.

With the boot loader you can reprogram the chip when a certain condition occurs.

The sample checks a pin to see if a new program must be loaded.

When the pin is low there is a jump to the boot address.

The boot code must always be located at the end of your program.

It must be written in ASM since the boot loader may not access the application flash rom. This because otherwise you could overwrite your running code!

The example is written for the M163. You can use the Upload file option of the terminal emulator to upload a new hex file. The terminal emulator must have the same baud rate as the chip. Under Options, Monitor, set the right upload speed and set a monitor delay of 20. Writing the flash take time so after every line a delay must be added while uploading a new file.

![notice](notice.jpg) The $BOOT directive is replaced by $LOADER. $LOADER works much simpler. $BOOT is however still supported.

See also

[$LOADER](loader.md) , [$LOADERSIZE](loadersize.md)

Example

See BOOT.BAS from the samples dir. But better look at the $LOADER directive.

---

## $DBG

Action

Enables debugging output to the hardware UART.

Syntax

$DBG

Remarks

Calculating the hardware, software and frame space can be a difficult task.

With $DBG the compiler will insert characters for the various spaces.

To the Frame space 'F' will be written. When you have a frame size of 4, FFFF will be written.

To the Hardware space 'H' will be written. If you have a hardware stack space of 8, HHHHHHHH will be written to this space.

To the software space 'S' will be written. If you have a software stack space of 6, SSSSSS will be written.

The idea is that when a character is overwritten, it is being used. So by watching these spaces you can determine if the space is used or not.

With the DBG statement a record is written to the HW UART. The record must be logged to a file so it can be analyzed by the stack analyzer.

Make the following steps to determine the proper values:

•| Make the frame space 40, the soft stack 20 and the HW stack 50  
---|---  
  
•| Add $DBG to the top of your program  
---|---  
  
•| Add a DBG statement to every Subroutine or Function  
---|---  
  
•| Open the terminal emulator and open a new log file. By default it will have the name of your current program with the .log extension  
---|---  
  
•| Run your program and notice that it will dump information to the terminal emulator  
---|---  
  
•| When your program has executed all sub modules or options you have build in, turn off the file logging and turn off the program  
---|---  
  
•| Choose the Tools Stack analyzer option  
---|---  
  
•| A window will be shown with the data from the log file  
---|---  
  
•| Press the Advise button that will determine the needed space. Make sure that there is at least one H, S and F in the data. Otherwise it means that all the data is overwritten and that you need to increase the size.  
---|---  
  
•| Press the Use button to use the advised settings.  
---|---  
  
As an alternative you can watch the space in the simulator and determine if the characters are overwritten or not.

The DBG statement will assign an internal variable named ___SUBROUTINE

Because the name of a SUB or Function may be 32 long, this variable uses 33 bytes!

___SUBROUTINE will be assigned with the name of the current SUB or FUNCTION.

When you first run a SUB named Test1234 it will be assigned with Test1234

When the next DBG statement is in a SUB named Test, it will be assigned with Test.

The 234 will still be there so it will be shown in the log file.

![tool_stack](tool_stack.gif)

Every DBG record will be shown as a row.

The columns are:

Column | Description  
---|---  
Sub | Name of the sub or function from where the DBG was used  
FS | Used frame space  
SS | Used software stack space  
HS | Used hardware stack space  
Frame space | Frame space  
Soft stack | Soft stack space  
HW stack | Hardware stack space  
  
The Frame space is used to store temp and local variables.

It also stores the variables that are passed to subs/functions by value.

Because PRINT , INPUT and the FP num<>String conversion routines require a buffer, the compiler always is using 24 bytes of frame space.

When the advise is to use 2 bytes of frame space, the setting will be 24+2=26.

For example when you use : print var, var need to be converted into a string before it can be printed or shown with LCD.

An alternative for the buffer would be to setup a temp buffer and free it once finished. This gives more code overhead.

In older version of BASCOM the start of the frame was used for the buffer but that gave conflicts when variables were printed from an ISR.

See also

[DBG](dbg.md)

---

## $EEPLEAVE

Action

Instructs the compiler not to recreate or erase the EEP file.

Syntax

$EEPLEAVE

Remarks

When you want to store data in the EEPROM, and you use an external tool to create the EEP file, you can use the $EEPLEAVE directive.

Normally the EEP file will be created or erased, but this directive will not touch any existing EEP file.

Otherwise you would erase an existing EEP file, created with another tool.

See also

[$EEPROMHEX](_eepromhex.md)

Example

NONE

---

## $EEPROMHEX

Action

Instruct the compiler to store the data in the EEP file in Intel HEX format instead of binary format.

Syntax

$EEPROMHEX

Remarks

The AVR has build in EEPROM. With the WRITEEEPROM and READEEPROM statements, you can write and read to the EEPROM.

To store information in the EEPROM, you can add DATA lines to your program that hold the data that must be stored in the EEPROM. $EEPROM must be used to create a EEP file that holds the data.

The EEP file is by default a binary file. When you use the STK500 you need an Intel HEX file. Use $EEPROMHEX to create an Intel Hex EEP file.

![notice](notice.jpg) $EEPROMHEX must be used together with $EEPROM. 

See also

[$EEPROMLEAVE](_eepleave.md)

Example

$eeprom'the following DATA lines data will go to the EEP file

Data 200 , 100,50

$data

This would create an EEP file of 3 bytes. With the values 200,100 and 50.

Add $eepromhex in order to create an Intel Hex file.

This is how the EEP file content looks when using $eepromhex

:0A00000001020304050A141E283251

:00000001FF

---

## $FRAMESIZE

Action

Sets the available space for the frame.

Syntax

$FRAMESIZE = var

Remarks

Var | A numeric decimal value.  
---|---  
  
While you can configure the Frame Size in Options, Compiler, Chip, it is good practice to put the value into your code. This way you do no need the cfg(configuration) file.

The $FRAMESIZE directive overrides the value from the IDE Options.

It is important that the $FRAMESIZE directive occurs in your main project file. It may not be included in an $include file as only the main file is parsed for $FRAMESIZE. $FRAMESIZE only accepts numeric values. 

![notice](notice.jpg)Functions like [PRINT](print.md), [LCD](lcd_1.md), [INPUT](input.md) and the FP num <> [FORMAT](format.md) String conversion routines require a buffer in SRAM. Because of that the compiler always is using 24 bytes of frame space. This 24 Byte start at the beginning of the Frame which act as the conversion buffer within the frame (See also picture).

Because the FRAME is growing bottom up and this 24 Byte start at the beginning of the FRAME this 24 Byte conversion buffer start at the lowest FRAME Address (See picture). Here you also see that a too small $framesize causes an overwriting of Software Stack and/or Hardware Stack which lead to malfunction. If you use Print numVar, then the numeric variable "numvar" is converted into a string representation of the binary number. The framespace buffer is also used for that.

When there is not enough room inside the frame, the ERR variable will be set to 1. 

See also

[$SWSTACK](_swstack.md), [$HWSTACK](_hwstack.md), [Memory usage](memory_usage.md)

![framesize](framesize.png)

Picture: Memory of ATXMEGA128A1

A LOCAL variable is a temporary variable that is stored in frame. 

There can be only LOCAL variables of the type BYTE, INTEGER, WORD, LONG, SINGLE, DOUBLE or STRING.

A LOCAL Integer will use 2 Bytes of Frame ,

A LOCAL Long will use 4 Bytes. 

A LOCAL string * 20 will use 20 + 1 = 21 Byte (this additional 1 Byte is because every String is terminated with a 0-Byte)

When the SUB or FUNCTION is terminated, the memory will be released back to the frame but the FRAME will not be cleared ! Therefore a LOCAL variable is not initialized. So you can not assume the variable is 0. If you like it to be 0, you need to assign it !

BIT variables are not possible as LOCAL because they are always GLOBAL to the system.

Arrays can NOT be used as LOCAL (but arrays can be passed by REFERENCE as parameter to SUB and FUNCTIONS which just need 2 Bytes Software Stack of the Address of Array start)

See following example for frame calculation:

Example

```vb
$regfile = "xm128a1def.dat"  
$crystal = 32000000 '32MHz  
$hwstack = 64  
$swstack = 128  
$framesize = 288  
  
Config Osc = Enabled , 32mhzosc = Enabled '32MHz  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1 '32MHz  
  
'Config Interrupts  
Config Priority = Static , Vector = Application , Lo = Enabled 'Enable Lo Level Interrupts  
Config Com1 = 57600 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
  
  
Declare Sub My_sub()  
  
```
Call My_sub()  
  
```vb
End 'end program  
  
Sub My_sub()  
```
Local A1 As Byte , A2 As Byte , A3 As Byte , A4 As Byte , A5 As Byte  
Local S As String * 254  
  
For A1 = 1 To 254  
S = S + "1"  
Next A1  
  
A1 = 1  
A2 = 2  
A3 = 3  
A4 = 4  
A5 = 5  
```vb
Print A1  
End Sub

```
Now we calculate the FRAME:

The Print A1 will be placed in the first frame-Byte of the 24 Byte conversion buffer.

5 LOCAL Byte (A1 â¦ A5) = 5 Byte of FRAME

LOCAL String: 254 Byte + 1 Byte = 255 Byte

Frame needed = 24Byte Frame conversion Buffer + 5 Byte + 255 Byte = 284 Byte 

This can be easy double checked with BASCOM-AVR Simulator (see following picture).

In following picture you see the start of FRAME which start with the 24Byte conversion buffer. The 31 in the first Frame Byte is from Print A1. After the 24 Byte conversion buffer follow the 5 Local Byte variables (A1 â¦. A5) and then the 255 Byte for the LOCAL String.

As with Software Stack you need to calculate the Framesize needed by the SUB or FUNCTION with the most LOCAL Variables and parameter passed by REFERENCE etc..

Take care when calling a SUB within a SUB. In this case you need to add the FRAME needed by both SUB !

When both SUB need 284 Byte you need to use:

24 Byte conversion Buffer + 2* 5 Byte (A1â¦A5) + 2*255 Byte (String) = 544 Byte

(the conversion buffer is needed only once !)

![frame_calc](frame_calc.png)

Picture: Memory window of BASCOM-AVR Simulator (Frame calculation example)

```vb
For further investigation of Stacks and Frame we use a SUB with 5 LOCAL Byte Variables and a PRINT function within the SUB. We start with hwstack, swstack and framesize defined and in second step we set swstack to 0. In addition we will lower the framesize to a not recommended value to force overwriting of other stack bytes.

$regfile = "xm128a1def.dat"  
$crystal = 32000000 '32MHz  
$hwstack = 64  
$swstack = 128  
$framesize = 256  
  
Config Osc = Enabled , 32mhzosc = Enabled '32MHz  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1 '32MHz  
  
'Config Interrupts  
Config Priority = Static , Vector = Application , Lo = Enabled 'Enable Lo Level Interrupts  
Config Com1 = 57600 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
  
  
  
Declare Sub My_sub()  
  
```
Call My_sub()  
  
```vb
End 'end program  
  
Sub My_sub()  
```
Local A1 As Byte , A2 As Byte , A3 As Byte , A4 As Byte , A5 As Byte

  
A1 = 1  
A2 = 2  
A3 = 3  
A4 = 4  
A5 = 5  
```vb
Print A1  
  
End Sub

```
Here we see the 64 Byte Hardware Stack followed by 128 Byte Software Stack and then 256 Byte Frame. As always the Frame is the 24 Byte conversion buffer + rest of frame.

![framesize6](framesize6.png)

Picture : SRAM for Example with $hwstack = 64, $swstack = 128, $framesize = 256

The Simulator Memory Window show give us the details:

![framesize2](framesize2.png)

Picture: Simulator Memory Window for Example with $hwstack = 64, $swstack = 128, $framesize = 256

The second example use $hwstack = 64, $swstack = 0, $framesize = 256

Without defining a software Stack or with $swstack = 0 the Frame follows direct after the Hardware Stack. The Frame is as always 24 Byte conversion buffer + Rest of Frame.

Rest of Frame is in this case: 256 Byte â 24 Byte = 232 Byte

![framesize4](framesize4.png)

Picture: SRAM for example with $hwstack = 64, $swstack = 0, $framesize = 256

In the BASCOM Simulator Window you now see the addresses of the LOCAL variables are now stored in FRAME (which are usually in the Software Stack). This is not a problem as long as the Frame is big enough not to overwrite these addresses of the LOCAL variables.

(Remember: Address of LOCAL variables are stored in Software Stack (when Software Stack is defined) . The LOCAL Variables itself are stored in FRAME)

And here you see also with the 24 Byte conversion buffer the absolute minimum you need to define for software Stack and Framesize together is 24 Byte !

But this is not the recommendation. The recommendation is always define values for all Stack and Frame !

![framesize5](framesize5.png)

Picture: Simulator Memory Window for Example with $hwstack = 64, $swstack = 0, $framesize = 256

---

## $HWSTACK

Action

Sets the available space for the Hardware stack.

Syntax

$HWSTACK = var

Remarks

Var | A numeric decimal value.  
---|---  
  
While you can configure the HW Stack in Options, Compiler, Chip, it is good practice to put the value into your code. This way you do no need the cfg(configuration) file.

The $HWSTACK directive overrides the value from the IDE Options.

It is important that the $HWSTACK directive occurs in your main project file. It may not be included in an $include file as only the main file is parsed for $HWSTACK. $HWSTACK only accepts numeric values. 

The Hardware stack is room space in SRAM that is needed by your program. Each time you call a SUB or FUNCTION, or use GOSUB, the processor need to know at which address to return after returning from the call. Also for RETURN Address after Interrupt this is needed by the program. For this purpose, the processor saves this address on the hardware stack.

When you use GOSUB label, the microprocessor pushes the return address on the hardware stack and will use 2 Bytes for that. When you use RETURN, the Hardware stack is popped back and the program can continue at the proper address. When you nest GOSUB, CALL or functions, you will use more stack space. Most statements use HW stack because a machine language routine is called.

The Hardware Stack is growing top down. The Hardware Stack start at the highest available SRAM Address and therefore is located before Software Stack and/or Frame. 

See also

[$SWSTACK](_swstack.md) , [$FRAMESIZE](_framesize.md), [Memory Usage](memory_usage.md)

Example for using an Interrupt and examine Hardware Stack:

With the following example we just define and enable the Receive Interrupt of the UART and examine when clicking on Interrupt button within the Bascom-AVR Simulator Interrupts Tab how many Hardware Stack is needed.

```vb
$regfile = "m328pdef.dat"  
$crystal = 16000000  
$hwstack = 48  
$swstack = 32  
$framesize = 32  
  
$baud = 19200  
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  
  
Dim Rs232 As Byte  
  
'Enable Receive Interrupt for COM1  
On Urxc Rxc_isr  
Enable Urxc  
Enable Interrupts  
  
Do  
```
!nop  
```vb
Loop  
  
End  
  
```
Rxc_isr:  
Rs232 = Inkey()  
```vb
Print Rs232  
Return

```
Bascom-AVR Simulator output of the example above:

![hw_stack](hw_stack.png)

Picture : The Hardware Stack will be filled by clicking the Bascom-AVR Simulator Interrupt

With this example we see (by counting the changed SRAM Bytes in Bascom Simulator Memory Window) that Software Stack is NOT needed but at least 39 Byte of Hardware Stack and the Frame with the 24 Byte conversion buffer because of PRINT. 

Most of the 39 Bytes are the saved Registers when jumping in Interrupt Service Routine. These are SREG , R31 to R16 and R11 to R0 with exception of R6,R8 and R9.

The following should be considered in any case (not only when using NOSAVE):

Take care when using floating point math in the ISR because the Register R12 to R15 are not saved in the regular process of processor register backup. Using floating point math in ISR is not recommended anyway.

When you try the same example with NOSAVE (![hwstack](hwstack.png)) you will see the example will need less Hardware Stack but you are responsible then to save all of the Registers with PUSH and POP in the Interrupt Service Routine that are needed or changed during the Interrupt Service Routine.

The easier, and above all safer way is not using NOSAVE which is also the default way.

By clicking on the Interrupts Button will fire an interrupt in Simulator

![hw_stack_sim](hw_stack_sim.png)

---

## $INC

Action

Includes a binary file in the program at the current position.

Syntax

$INC label , size | nosize , "file"

Remarks

Label | The name of the label you can use to refer to the data.  
---|---  
Nosize | Specify either nosize or size. When you use size, the size of the data will be included. This way you know how many bytes you can retrieve.  
File | Name of the file which must be included.  
  
Use RESTORE to get a pointer to the data. And use READ, to read in the data.

The $INC statement is an alternative for the DATA statement.

While DATA works ok for little data, it is harder to use on large sets of data.

See Also

[RESTORE](restore.md), [DATA](data_2.md) , [READ](read.md)

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$baud = 19200

$hwstack = 16

$swstack = 16

$framesize = 16

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim Size As Word , W As Word , B As Byte

```
Restore L1 ' set pointer to label

Read Size ' get size of the data

```vb
Print Size ; " bytes stored at label L1"

For W = 1 To Size

```
Read B : Print Chr(b);

```vb
Next

End

'include some data here

$inc L1 , Size , "c:\test.bas"

'when you get an error, insert a file you have on your system

```

---

## $INITMICRO

Action

Calls a user routine at startup to perform important initialization functions such as setting ports.

Syntax

$INITMICRO

Remarks

This directive will call a label named _INIT_MICRO just after the most important initialization is performed. You can put the _INIT_MICRO routine into your program, or you can put it in a library. Advantage of a library is that it is the same for all programs, and advantage of storing the code into your program is that you can change it for every program.  
---  
  
It is important that you end the routine with a RETURN as the label is called and expects a return.

The $initmicro can be used to set a port direction or value as it performs before the memory is cleared which can take some mS.

The best solution for a defined logic level at startup remains the usage of pull up/pull down resistors.

See Also

NONE

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$hwstack = 10  
$swstack = 10  
$framesize = 26

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

$initmicro

Print Version() 'show date and time of compilation

Print Portb

Do

```
nop

```vb
Loop

End

'do not write a complete application in this routine.

'only perform needed init functions

```
_init_micro:

Config Portb = Output

Portb = 3

Return

---

## $LCDVFO

Action

Instruct the compiler to generate very short Enable pulse for VFO displays.

Syntax

$LCDVFO

Remarks

VFO based displays need a very short Enable pulse. Normal LCD displays need a longer pulse. To support VFO displays this compiler directive has been added.

The display need to be instruction compatible with normal HD44780 based text displays.

Noritake is the biggest manufacturer of VFO displays.

The $LCDVFO directive is intended to be used in combination with the LCD routines.

ASM

NONE

See also

NONE

Example

NONE

---

## $MAP

Action

Will generate label info in the report.

Syntax

$MAP

Remarks

The $MAP directive will put an entry for each line number with the address into the report file. This info can be used for debugging purposes with other tools.

See also

NONE

ASM

NONE

Example

$MAP

The report file will now contain the following section :

Code map

\--------------------------------------------------------------------------------

Line Address(hex)

\--------------------------------------------------------------------------------

1 0

9 36

26 39

30 3B

31 3E

32 48

33 4B

36 50

37 56

42 5B

43 6C

44 7D

45 80

46 81

---

## $NOINIT

Action

Instruct the compiler to generate code without initialization code.

Syntax

$NOINIT

Remarks

```vb
$NOINIT is only needed in rare situations. It will instruct the compiler not to add initialization code. But that means that you need to write your own code then.

$NOINIT was added in order to support boot loaders. But the new $LOADER directive can better be used as it does not require special ASM knowledge.

```
See also

[$LOADER](loader.md)

Example

NONE

---

## $NORAMCLEAR

Action

Instruct the compiler to not generate initial RAM clear code.

Syntax

$NORAMCLEAR

Remarks

Normally the SRAM is cleared in the initialization code. When you don't want the SRAM to be cleared(set to 0) you can use this directive.

Because all variables are automatically set to 0 or ""(strings) without the $NORAMCLEAR, using $NORAMCLEAR will set the variables to an unknown value. That is, the variables will probably set to FF but you cannot count on it.

When you have a battery back upped circuit, you do not want to clear the RAM at start up. So that would be a situation when you could use $NORAMCLEAR.

See also

[$NOINIT](_noinit.md)

---

## $PROG

Action

Directive to auto program the lock and fuse bits.

Syntax old AVR

$PROG LB, FB , FBH , FBX

Syntax Xmega

$PROG LB, F0 , F1 , F2 , F3 ,F4 , F5

Remarks

While the lock and fuse bits make the AVR customizable, the settings for your project can give some problems.

The $PROG directive will create a file with the project name and the PRG extension.

Every time you program the chip, it will check the lock and fuse bit settings and will change them if needed.

So in a new chip, the lock and fuse bits will be set automatically. A chip that has been programmed with the desired settings will not be changed.

The programmer has an option to create the PRG file from the current chip settings.

The LB, FH, FBH and FBX values are stored in hexadecimal format in the PRJ file.

You may use any notation as long as it is a numeric constant.

Some chips might not have a setting for FBH or FBX, or you might not want to set all values. In that case, do NOT specify the value. For example:

$PROG &H20 ,,,

This will only write the Lockbit settings.

$PROG ,,&H30,

This will only write the FBH settings.

LB | Lockbit settings  
---|---  
FB | Fusebit settings  
FBH | Fusebit High settings  
FBX | Extended Fusebit settings  
  
Sometimes the data sheet refers to the Fusebit as the Fusebit Low settings.

The $PROG setting is only supported by the AVRISP, STK200/300, Sample Electronics and Universal MCS Programmer Interface. The USB-ISP programmer also supports the $PROG directive.

![notice](notice.jpg) When you select the wrong Fuse bit, you could lock your chip. For example when you choose the wrong oscillator option, it could mean that the micro expects an external crystal oscillator. But when you connect a simple crystal, it will not work.

In these cases where you can not communicate with the micro anymore, the advise is to apply a clock signal to X1 input of the micro.

You can then select the proper fuse bits again.

When you set the Lock bits, you can not read the chip content anymore. Only after erasing the chip, it could be reprogrammed again.

![important](important.jpg) Once the lock bits and fuse bits are set, it is best to remark the $PROG directive. This because it takes more time to read and compare the bits every time.

Xmega

The Xmega has one lock byte and 6 fuse bytes. For an Xmega the Write PRG option will write the correct code. 

Xtiny

The Xtiny has way more fuses and has a special CONFIG FUSES statement code. 

See also

[Programmers](supported_programmers.md) , [CONFIG FUSES](config_fuses.md) , [$PROGRAMMER](programmer.md)

---

## $PROJECTTIME

Action

This directive will keep track of time you spend on the source.

Syntax

$PROJECTTIME

Remarks

Keeping track of project time is the only purpose of this directive. It will be ignored by the compiler. 

When the IDE finds the $PROJECTTIME directive, it will count the minutes you spend on the code.

Each time you save the code, the updated value will be shown.

The IDE will automatic insert the value after $PROJECTTIME. 

So how does this work?

When you type, you start a timer. When there are no keystrokes for 2 minutes, this process stops. It is started automatic as soon as you start typing. 

So when you type a character each minute, each minute will be counted a a full minutes of work.

The time is counted and shown in minutes. 

While you can edit the value in the source, it will be changed as soon as you save the source. 

See also

NONE

Example

$PROJECTTIME

---

## $ROMSTART

Action

Instruct the compiler to generate a hex/bin file that starts at the specified address.

Syntax

$ROMSTART = address

Remarks

Address | The address where the code must start. By default the first address is 0.  
---|---  
  
![notice](notice.jpg)The $ROMSTART directive is an inheritance from BASCOM-8051. In the AVR it did not have any meaning.

In the 8051 you can use and relocate external memory. This is not possible in the AVR and hence there is no practical usage.

For a bootloader used with AVR and XMega you can use the $LOADER directive.

Only use $ROMSTART with the Xtiny platform and when you have a boot loader !

In version 2083 where XTINY is supported the $ROMSTART has a new purpose. Since the boot loading mechanism in the XTINY differs from the other AVR processors, the $ROMSTART can be used to relocate the address.

The memory map starts with the BOOT area, followed by the application area. This means that a boot loader starts at &H0000 and a normal application will start after that.

So in order to use a bootloader, your normal code need to be compiled with the $ROMSTART directive. When the boot loader uses 1024 bytes, it means that the normal application starts at the WORD address which is halve of the byte address and in this case would be &H200 (1024 dec=400 hex).

The simulator supports $ROMSTART relocated code.

See also

[$LOADER](loader.md) , [Using a BOOTLOADER](using_a_bootloader.md)

ASM

NONE

Example

$ROMSTART = &H200 'xtiny boot loader

---

## $SERIALINPUT1

Action

Specifies that serial input of the second UART must be redirected.

Syntax

$SERIALINPUT1 = label

Remarks

Label | The name of the assembler routine that must be called when a character is needed from the INPUT routine. The character must be returned in R24.  
---|---  
  
With the redirection of the INPUT command, you can use your own input routines.

This way you can use other devices as input devices.

Note that the INPUT statement is terminated when a RETURN code (13) is received.

By default when you use INPUT or INKEY(), the compiler will expect data from the COM2 port. When you want to use a keyboard or remote control as the input device you can write a custom routine that puts the data into register R24 once it asks for this data.

See also

[$SERIALOUTPUT1](_serialoutput1.md) , [$SERIALINPUT](serialinput.md) , [$SERIALOUTPUT](serialoutput.md)

Example

See the [$SERIALINPUT](serialinput.md) sample

---

## $SERIALOUTPUT1

Action

Specifies that serial output of the second UART must be redirected.

Syntax

$SERIALOUTPUT1 = label

Remarks

Label | The name of the assembler routine that must be called when a character is send to the serial buffer (UDR1). The character is placed into R24.  
---|---  
  
With the redirection of the PRINT and other serial output related commands, you can use your own routines.

This way you can use other devices as output devices.

See also

[$SERIALINPUT1](_serialinput1.md) , [$SERIALINPUT](serialinput.md) , [$SERIALINPUT2LCD](serialinput2lcd.md) , [$SERIALOUTPUT](serialoutput.md)

Example

See the [$SERIALOUTPUT](serialoutput.md) example

---

## $SWSTACK

Action

Sets the available space for the software stack.

Syntax

$SWSTACK = var

Remarks

Var | A numeric decimal value.  
---|---  
  
While you can configure the SW Stack in Options, Compiler, Chip, it is good practice to put the value into your code. This way you do no need the cfg(configuration) file.

The $SWSTACK directive overrides the value from the IDE Options.

![notice](notice.jpg) It is important that the $SWSTACK directive occurs in your main project file. It may not be included in an $include file as only the main file is parsed for $SWSTACK. $SWSTACK only accepts numeric values. 

Software Stack stores the parameter addresses passed to a subroutine and LOCAL variable addresses. 

So the Software stack stores the addresses of variables where each passed variable and local variable use 2 bytes per respective addresses. 

When using SUB or FUNCTION there are 3 ways for parameters:

•| Using BYREF pass a variable by reference with its ADDRESS (so it is pointing to an existing variable which is already in SRAM)  
---|---  
  
•| Using BYVAL the value is stored in FRAME (during the SUB is processed) so it is pointing to the address in FRAME.  
---|---  
  
•| Using BYLABEL pass the address of a label  
---|---  
  
When nothing is specified the parameter will be passed BYREF.

See also

[$HWSTACK](_hwstack.md) , [$FRAMESIZE](_framesize.md), [Memory Usage](memory_usage.md)

For example if you have used 10 locals in a SUB and there are 3 parameters passed to it, you need:

(10 * 2 Byte) + (3 * 2 Byte) = 26 Byte Software Stack.

The following SUB need 10 Byte of Software Stack:

5* 2 Byte = 10 Byte

![swstack](swstack.png)

So the software stack size can be calculated by taking the maximum number of parameter passed to a SUB routine, adding the number of LOCAL variables and multiplying the result by 2. To be safe, add 4 more bytes for internally used LOCAL variables.

If you have several SUB or FUNCTIONS search for the SUB or FUNCTION with the most parameters and LOCAL variables and use that calculated maximum numbers for defining the Software Stack ($swstack).

The Software Stack is growing top down (see picture) and start direct after the Hardware Stack. The Software Stack grows against the FRAME.

![swstack_memmap](swstack_memmap.png)

Picture: Example Memory of ATXMEGA128A1

[[****]](<memory_usage.htm>)

Example

```vb
$regfile = "xm128a1def.dat"  
$crystal = 32000000 '32MHz  
$hwstack = 64  
$swstack = 128  
$framesize = 288  
  
  
Config Osc = Enabled , 32mhzosc = Enabled '32MHz  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1 '32MHz  
'Config Interrupts  
Config Priority = Static , Vector = Application , Lo = Enabled 'Enable Lo Level Interrupts  
Config Com1 = 57600 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
  
Declare Sub My_sub()  
  
```
Call My_sub()  
  
```vb
End 'end program  
  
Sub My_sub()  
```
Local A1 As Byte , A2 As Byte , A3 As Byte , A4 As Byte , A5 As Byte  
Local S As String * 254  
  
For A1 = 1 To 254  
S = S + "1"  
Next A1  
  
A1 = 1  
A2 = 2  
A3 = 3  
A4 = 4  
A5 = 5  
```vb
Print A1  
  
End Sub 'default use 40 for the frame space

```

---

## $TIMEOUT

Action

Enable timeout on the hardware UART and software UART.

Syntax

$TIMEOUT = value

Remarks

Value | A constant that fits into a LONG , indicating how much time must be waited before the waiting is terminated.  
---|---  
  
All RS-232 serial statements and functions(except INKEY) that use the hardware UART or software UART, will halt the program until a character is received. Only with buffered serial input you can process your main program while the buffer receives data on the background.

![notice](notice.jpg) $TIMEOUT is an alternative for normal serial reception. It is not intended to be used with buffered serial reception. As of version 2077, the first (and only the first) UART supports the $TIMEOUT feature. The latest version supports timeout on ALL UARTS.

When you assign a constant to $TIMEOUT, you actual assign a value to the internal created value named ___TIMEOUT.

This value will be decremented in the routine that waits for serial data. When it reaches zero, it will terminate.

So the bigger the value, the longer the wait time before the timeout occurs. The timeout is not in seconds or microseconds, it is a relative number. Only the speed of the oscillator has effect on the duration. And the value of the number of course.

When the time out is reached, a zero/null will be returned to the calling routine. Waitkey() will return 0 when used with a byte. When you use INPUT with a string, the timeout will be set for every character. And when 3 characters are received but no CR and/or LF, these 3 characters will be returned. 

![notice](notice.jpg)When you activate $TIMEOUT, and your micro has two UARTS(Mega128 for example) it will be active for both UART0 and UART1. And for an ATMEGA2560 with 4 UARTS, it will be enabled for all 4 UARTS, but only when no serial input buffer is configured.

$TIMEOUT is also supported by the software UART. In fact, when you enable it for the hardware UART, you enable it for the software UART as well.

Note that for the SW UART the maximum timeout value is lower. The maximum is &HFF_FF_FF. This because 1 byte less is used.

See Also

[INPUT](input.md) , [WAITKEY](waitkey.md) , [INKEY](inkey.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : timeout.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstration of the $timeout option

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'most serial communication functions and routines wait until a character

'or end of line is received.

'This blocks execution of your program. SOmething you can change by using buffered input

'There is also another option : using a timeout

'$timeout Does Not Work With Buffered Serial Input

Dim Sname As String * 10

Dim B As Byte

Do

$timeout = 1000000

Input "Name : " , Sname

Print "Hello " ; Sname

$timeout = 5000000

Input "Name : " , Sname

Print "Hello " ; Sname

Loop

'you can re-configure $timeout

```

---

## $TINY

Action

Instruct the compiler to generate initialize code without setting up the stacks.

Syntax

$TINY

Remarks

The tiny11 for example is a powerful chip. It only does not have SRAM. BASCOM depends on SRAM for the hardware stack and software stack.

When you like to program in ASM you can use BASCOM with the $TINY directive.

Some BASCOM statements will also already work but the biggest part will not work.

A future version will support a subset of the BASCOM statements and function to be used with the chips without SRAM.

Note that the generated code is not yet optimized for the tiny parts. Some used ASM statements for example will not work because the chip does not support it.

See also

NONE

ASM

NONE

Example

```vb
$regfile = "attiny15.dat"  
$tiny  
$crystal = 1000000  
$noramclear  
$hwstack = 0  
$swstack = 0  
$framesize = 0  
  
Dim A As Iram Byte  
Dim B As Iram Byte  
```
A = 100 : B = 5  
A = A + B  
End

---

## $VERSION

Action

This compiler directive stores version information.

Syntax

$VERSION V,S,R

Remarks

Version info is important information. If you need to maintain source code, it will make it easy to identify the code.

$VERSION has 3 parameters. These must be numeric digits. Each time you compile your code, the release number is increased.

You can use Version(2) to print this information. $version 1,2,3 will be printed as 1.2.3

The compiler will create three internal constants named _VERSION_MAJOR, _VERSION_MINOR and _VERSION_BUILD with the specified values.

For example when $version is set to : $VERSION 1,2,3

_VERSION_MAJOR will become 1 , _VERSION_MINOR will become 2 and _VERSION_BUILD will become 3.

See also

[VERSION](version.md)

Example

```vb
$version 1,2,3

Print Version(2)

```

---

## $WAITSTATE

Action

Compiler directive to activate external SRAM and to insert a WAIT STATE for a slower ALE signal.

![notice](notice.jpg)[CONFIG XRAM ](configxram.md)should be used instead.

Syntax

$WAITSTATE

Remarks

The $WAITSTATE can be used to override the Compiler Chip Options setting.

Wait states are needed for slow external components that can not handle the fast ALE signal from the AVR chip.

See also

[$XA](xa.md) , [CONFIG XRAM](configxram.md)

Example

$WAITSTATE

---

## Compiler Directives



---
