# BASCOM-AVR Commands

> Language commands, statements, functions, and chip-specific documentation

## #AUTOCODE

Action

Informs the IDE that code can be maintained by the IDE.

Syntax

```vb
#AUTOCODE

CONFIG STATEMENTS

#ENDAUTOCODE

```
Remarks

Auto code informs the IDE that it may alter the code. A new IDE uses a property editor for the configuration. It will only update, add or delete, CONFIG statements that are enclosed in an #AUTOCODE block. 

#AUTOCODE must be closed with a matching #ENDAUTOCODE

You can still use CONFIG statements in other places of your code. But the property editor will only work on the ones inside the block.

The compiler will ignore #AUTOCODE and #ENDAUTOCODE.

---

## $ASM

Action

Start of inline assembly code block.

Syntax

$ASM

Remarks

Use $ASM together with $END ASM to insert a block of assembler code in your BASIC code. You can also precede each line with the ! sign.

See also the chapter [Mixing BASIC and Assembly](mixing_asm_and_basic.md) and [assembler mnemonics](assembler_mnemonics.md)

Example

Dim C As Byte

Loadadr C , X 'load address of variable C into register X

$asm

Ldi R24,1 ; load register R24 with the constant 1

St X,R24 ; store 1 into variable c

```vb
$end Asm

Print C

End

```

---

## $BAUD

Action

Instruct the compiler to override the baud rate setting from the options menu.

Syntax

$BAUD = var

Remarks

Var | The baud rate that you want to use. This must be a numeric constant.  
---|---  
  
The baud rate is selectable from the [Compiler Settings](options_compiler_communication.md). It is stored in a configuration file. The $BAUD directive overrides the setting from the Compiler Settings.

In the generated report, you can view which baud rate is actually generated. The generated baud rate does depend on the used micro and crystal.

When you simulate a program you will not notice any problems when the baud rate is not set to the value you expected. In real hardware a wrong baud rate can give weird results on the terminal emulator screen. For best results use a crystal that is a multiple of the baud rate.

In the simulator you need to select the UART0-TAB to view the output of the UART0, or to send data to this UART.

See also

[$CRYSTAL](crystal_1.md) , [BAUD](baud_2.md)

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$baud = 19200

$hwstack = 32

$swstack = 8

$framesize = 24

Config Com1 = Dummy, Synchrone = 0, Parity = None, Stopbits = 1, Databits = 8, Clockpol = 0

Print "Hello"

'Now change the baud rate in a program

```
Baud = 9600

```vb
Print "Did you change the terminal emulator baud rate too?"

End

```

---

## $BIGSTRINGS

Action

Instruct the compiler to use big strings.

Syntax

$BIGSTRINGS

Remarks

By default each string has a maximum length of 254 bytes. A null character is used to mark the end of a string.

When a longer string is needed, the compiler can not use bytes for passing the length. A word is needed to hold the length.

The $BIGSTRINGS directive will include the bigstrings.lbx and will handle all string routines different when parameters are passed which influence the length. 

The alternative library contains modified(overloaded) routines for code not compatible with big strings.

The following string routines support $BIGSTRINGS:

[ASC](asc.md)

[CHARPOS](charpos.md)

[CRC8](crc8.md)

[DELCHAR](delchar.md)

[DELCHARS](delchars.md)

[GET](get.md)

[INPUT LCD , INPUT SERIAL](input.md)

[INSERTCHAR](insertchar.md)

[INSTR](instr.md)

[LCASE](lcase.md)

[LEFT](left.md)

[LEN](len.md)

[LTRIM](ltrim.md)

[MID](mid.md) function

[MID](mid.md) statement

[PUT](put.md)

[QUOTE](quote.md)

[RIGHT](right.md)

[RTRIM](rtrim.md)

[SPACE](space.md)

[STRING](string.md)

[TRIM](trim.md)

[UCASE](ucase.md)

See also

[DIM](dim.md)

Example

$BIGSTRINGS

---

## $BOOTVECTOR

Action

This compiler directive will force the compiler to create an interrupt vector table(IVR).

Syntax

$BOOTVECTOR

Remarks

By default an IVR is always created for normal applications. There is no good reason not to create an IVR for a normal application.

When making a boot loader application things are different. A boot loader application resides in upper flash memory inside the boot area. And when the boot loader applications runs, it has special rights so it can update the flash memory which resides in the lower flash memory.

The boot loader area size depends on the processor but is usual small. An interrupt vector table can use up to 250 bytes or more and it would be a waste of space in many cases. So by default the $LOADER directive which is used to create a boot loader application, will not create an IVR. The downside is that when you do not have an IVR you can not use interrupts.

The $BOOTVECTOR directive will force the compiler to create an IVR when the $LOADER directive is used. This way your boot loader application will include an IVR and you can use interrupts in your code.

![notice](notice.jpg)The $BOOTVECTOR directive will only work when the processor has an option to move the IVR to the boot area using the IVSEL bit.

By default the interrupts are located after address 0. Address 0 is the reset vector and usually contains a jump to the real code. Behind the reset address, a table with jumps to the interrupt routines is located. That the code contains an IVR is not enough : in case of a boot loader the interrupt table must be moved to the boot area. For this purpose most processors have a register and bit to switch the IVR between the normal address 0 and the boot loader address.

In BASCOM you can use : Config Intvectorselection = Enabled to set the selection to the boot area.

When the boot loader application finishes, it is best to use a watchdog timeout to reset the processor so the intvector selection is set to the default address 0.

Or you can use Config Intvectorselection = Disabled in your main (normal) application before you enable the interrupts. 

So in short you only need to add the $BOOTVECTOR directive and Config Intvectorselection = Enabled to your code. And do not forget to switch back the intvectorselection in the main application!

See also

[$LOADER](loader.md) , [CONFIG INTVECTORSELECTION](config_intvectorselection.md) , [$REDUCEIVR](reduceivr.md)

Example

```vb
'-----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' BootEDB-IVSEL.bas  
' This Bootloader is for the BASCOM-EDB  
' VERSION 4 of the BOOTLOADER.  
' IMPORTANT :  
' When changing the vector table in the boot loader you MUST  
' reset the vector table in your code using :  
' Config Intvectorselection = Disabled  
' otherwise your code points to the wrong table  
'-----------------------------------------------------------------  
'The loader is supported by the IDE  
  
$prog &HFF , &HE2 , &HDF , &HF8 ' generated. Take care that the chip supports all fuse bytes.'----------------------------------------------------------------  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
$crystal = 8000000  
$baud = 38400 'this loader uses serial com  
'It is VERY IMPORTANT that the baud rate matches the one of the boot loader  
'do not try to use buffered com as we can not use interrupts  
  
'This bootloader uses buffers serial input  
Config Serialin = Buffered , Size = 250  
  
'in order to use interrupts in a bootloader, the processor must support IVSEL  
'since the vector table occupies space some processors will not support it.  
$bootvector ' put int table into bootloader section so we can use interrupts  
Config Intvectorselection = Enabled ' enabled means that the vector table points to the boot section  
  
'since this boot loader uses interrupts we need to activate them but :  
'AFTER the interrupt vector table is enabeld  
Enable Interrupts  
  
'$regfile = "m8def.dat"  
'Const Loaderchip = 8  
  
'$regfile = "m168def.dat"  
'Const Loaderchip = 168  
  
'$regfile = "m16def.dat"  
'Const Loaderchip = 16  
  
'$regfile = "m32def.dat"  
'Const Loaderchip = 32  
  
$regfile = "m88def.dat"  
```
Const Loaderchip = 88  
  
```vb
'$regfile = "m162def.dat"  
'Const Loaderchip = 162  
  
'$regfile = "m128def.dat"  
'Const Loaderchip = 128  
  
'$regfile = "m64def.dat"  
'Const Loaderchip = 64  
  

#if Loaderchip = 88 'Mega88  
$loader = $c00 'this address you can find in the datasheet  
'the loader address is the same as the boot vector address  
```
Const Maxwordbit = 5  
Const Maxpages = 96 - 1 ' total WORD pages available for program  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 168 'Mega168  
$loader = $1c00 'this address you can find in the datasheet  
'the loader address is the same as the boot vector address  
```
Const Maxwordbit = 6  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 32 ' Mega32  
$loader = $3c00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit '  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  

#if Loaderchip = 8 ' Mega8  
$loader = $c00 ' 1024 words  
```
Const Maxwordbit = 5 'Z5 is maximum bit '  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  

#if Loaderchip = 161 ' Mega161  
$loader = $1e00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit '  

```vb
#endif  

#if Loaderchip = 162 ' Mega162  
$loader = $1c00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit '  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 64 ' Mega64  
$loader = $7c00 ' 1024 words  
```
Const Maxwordbit = 7 'Z7 is maximum bit '  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 128 ' Mega128  
$loader = &HFC00 ' 1024 words  
```
Const Maxwordbit = 7 'Z7 is maximum bit '  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 16 ' Mega16  
$loader = $1c00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit '  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  
  
  
```
Const Maxword =(2 ^ Maxwordbit) * 2 '128  
Const Maxwordshift = Maxwordbit + 1  
Const Cdbg = 0 ' leave this to 0  
  

```vb
#if Cdbg  
Print Maxword  
Print Maxwordshift  
' Print Maxpages  

#endif  
  
  
  
'Dim the used variables  
Dim Bstatus As Byte , Bretries As Byte , Bblock As Byte , Bblocklocal As Byte  
Dim Bcsum1 As Byte , Bcsum2 As Byte , Buf(128) As Byte , Csum As Byte  
Dim J As Byte , Spmcrval As Byte ' self program command byte value  
  
Dim Z As Long 'this is the Z pointer word  
Dim Vl As Byte , Vh As Byte ' these bytes are used for the data values  
Dim Wrd As Word , Page As Word 'these vars contain the page and word address  
Dim Bkind As Byte , Bstarted As Byte  
'Mega 88 : 32 words, 128 pages  
  
  
'in this loader we may not disable interrupts !  
'Disable Interrupts 'we do not use ints  
  
  
'Waitms 100 'wait 100 msec sec  
'We start with receiving a file. The PC must send this binary file  
  
'some constants used in serial com  
```
Const Nak = &H15  
Const Cack = &H06  
Const Can = &H18  
  
```vb
'we use some leds as indication in this sample , you might want to remove it  
Config Pind.7 = Output  
```
Portd.7 = 0  
  
```vb
$timeout = 200000 'we use a timeout  
'When you get LOADER errors during the upload, increase the timeout value  
'for example at 16 Mhz, use 200000  
  
```
Bretries = 5 'we try 5 times  
Testfor123:  

```vb
#if Cdbg  
Print "Try " ; Bretries  
Print "Wait"  

#endif  
```
Bstatus = Waitkey() 'wait for the loader to send a byte  

```vb
#if Cdbg  
Print "Got "  

#endif  
  
Print Chr(bstatus);  
  
If Bstatus = 123 Then 'did we received value 123 ?  
```
Bkind = 0 'normal flash loader  
Goto Loader  
Elseif Bstatus = 124 Then ' EEPROM  
Bkind = 1 ' EEPROM loader  
Goto Loader  
Elseif Bstatus <> 0 Then  
Decr Bretries  
```vb
If Bretries <> 0 Then Goto Testfor123 'we test again  
End If  
  
For J = 1 To 10 'this is a simple indication that we start the normal reset vector  
Toggle Portd.7 : Waitms 100  
Next  
  

#if Cdbg  
Print "RESET"  

#endif  
Goto _reset 'goto the normal reset vector at address 0  
  
  
'this is the loader routine. It is a Xmodem-checksum reception routine  
```
Loader:  

```vb
#if Cdbg  
Print "Clear buffer"  

#endif  
Do  
```
Bstatus = Waitkey()  
```vb
Loop Until Bstatus = 0  
  
  
For J = 1 To 3 'this is a simple indication that we start the normal reset vector  
Toggle Portd.7 : Waitms 250  
Next  
  
If Bkind = 0 Then  
```
Spmcrval = 3 : Gosub Do_spm ' erase the first page  
Spmcrval = 17 : Gosub Do_spm ' re-enable page  
End If  
  
  
Bretries = 10 'number of retries  
  
Do  
Bblocklocal = 1  
Bstarted = 0 ' we were not started yet  
Csum = 0 'checksum is 0 when we start  
```vb
Print Chr(nak); ' firt time send a nack  
Do  
  
```
Bstatus = Waitkey() 'wait for statuse byte  
  
```vb
Select Case Bstatus  
Case 1: ' start of heading, PC is ready to send  
```
Csum = 1 'checksum is 1  
Bblock = Waitkey() : Csum = Csum + Bblock 'get block  
Bcsum1 = Waitkey() : Csum = Csum + Bcsum1 'get checksum first byte  
For J = 1 To 128 'get 128 bytes  
Buf(j) = Waitkey() : Csum = Csum + Buf(j)  
Next  
Bcsum2 = Waitkey() 'get second checksum byte  
```vb
If Bblocklocal = Bblock Then 'are the blocks the same?  
If Bcsum2 = Csum Then 'is the checksum the same?  
Gosub Writepage 'yes go write the page  
Print Chr(cack); 'acknowledge  
```
Incr Bblocklocal 'increase local block count  
```vb
Else 'no match so send nak  
Print Chr(nak);  
End If  
Else  
Print Chr(nak); 'blocks do not match  
End If  
Case 4: ' end of transmission , file is transmitted  
If Wrd > 0 Then 'if there was something left in the page  
```
Wrd = 0 'Z pointer needs wrd to be 0  
Spmcrval = 5 : Gosub Do_spm 'write page  
Spmcrval = 17 : Gosub Do_spm ' re-enable page  
```vb
End If  
Print Chr(cack); ' send ack and ready  
  
```
Portd.7 = 0 ' simple indication that we are finished and ok  
```vb
Waitms 20  
Goto _reset ' start new program  
Case &H18: ' PC aborts transmission  
Goto _reset ' ready  
Case 123 : Exit Do 'was probably still in the buffer  
Case 124 : Exit Do  
Case Else  
Exit Do ' no valid data  
End Select  
Loop  
If Bretries > 0 Then 'attempte left?  
Waitms 1000  
```
Decr Bretries 'decrease attempts  
```vb
Else  
Goto _reset 'reset chip  
End If  
Loop  
  
  
  
'write one or more pages  
```
Writepage:  
```vb
If Bkind = 0 Then  
For J = 1 To 128 Step 2 'we write 2 bytes into a page  
```
Vl = Buf(j) : Vh = Buf(j + 1) 'get Low and High bytes  
! lds r0, {vl} 'store them into r0 and r1 registers  
! lds r1, {vh}  
Spmcrval = 1 : Gosub Do_spm 'write value into page at word address  
Wrd = Wrd + 2 ' word address increases with 2 because LS bit of Z is not used  
If Wrd = Maxword Then ' page is full  
Wrd = 0 'Z pointer needs wrd to be 0  
Spmcrval = 5 : Gosub Do_spm 'write page  
Spmcrval = 17 : Gosub Do_spm ' re-enable page  
  
  
If Page < Maxpages Then 'only if we are not erasing the bootspace  
Page = Page + 1 'next page  
Spmcrval = 3 : Gosub Do_spm ' erase next page  
Spmcrval = 17 : Gosub Do_spm ' re-enable page  
Else  
Portd.7 = 0 : Waitms 200  
```vb
End If  
End If  
Next  
  
Else 'eeprom  
For J = 1 To 128  
```
Writeeeprom Buf(j) , Wrd  
Wrd = Wrd + 1  
```vb
Next  
End If  
Toggle Portd.7 : Waitms 10 : Toggle Portd.7 'indication that we write  
Return  
  
  
```
Do_spm:  
Bitwait Spmcsr.0 , Reset ' check for previous SPM complete  
Bitwait Eecr.1 , Reset 'wait for eeprom  
  
Z = Page 'make equal to page  
Shift Z , Left , Maxwordshift 'shift to proper place  
Z = Z + Wrd 'add word  
! lds r30,{Z}  
! lds r31,{Z+1}  
  

#if Loaderchip = 128  
! lds r24,{Z+2}  
! sts rampz,r24 ' we need to set rampz also for the M128  

#endif  
  
Spmcsr = Spmcrval 'assign register  
! spm 'this is an asm instruction  
! nop  
! nop  
```vb
Return  
  
  
'Sub Isr_urx()  
  
'End Sub  
  
  
  
'How you need to use this program:  
'1- compile this program  
'2- program into chip with sample elctronics programmer  
'3- select MCS Bootloader from programmers  
'4- compile a new program for example M88.bas  
'5- press F4 and reset your micro  
' the program will now be uploaded into the chip with Xmodem Checksum  
' you can write your own loader.too  
'A stand alone command line loader is also available  
  
  
'How to call the bootloader from your program without a reset ???  
'Do  
' Print "test"  
' Waitms 1000  
' If Inkey() = 27 Then  
' Print "boot"  
' Goto &H1C00  
' End If  
'Loop  
  
'The GOTO will do the work, you need to specify the correct bootloader address  
'this is the same as the $LOADER statement.

```

---

## $CRYPT

Action

This directive marks encrypted BASIC code.

Syntax

$CRYPT data

Remarks

In some cases you might want to share only portions of your code. The IDE can encrypt your code, and the compiler can process this encrypted code.

AES encryption is used. You do need a commercial add on to use the encryption. The $crypt command can be processed by all bascom editions starting from version 2.0.5.0. So you only need an add on when you want to encrypt the code. 

![notice](notice.jpg)Once encrypted, you can NOT DECRYPT into source code! Thus make a BACKUP of your source code before you encrypt the code. 

See also

[Edit Encrypt Selected Code](edit_encrypt_selected_code.md)

Example

```vb
$CRYPT 6288E522B4A1429A6F16D639BFB7405B

$CRYPT 7ABCF89E7F817EB166E03AFF2EB64C4B

$CRYPT 645C88E996A87BF94D34726AA1B1BCCC

$CRYPT 9405555D91FA3B51DEEC4C2186F09ED1

$CRYPT 6D4790DA2ADFF09DE0DA97C594C1B074

```

---

## $CRYSTAL

Action

Instruct the compiler to override the crystal frequency options setting.

Syntax

$CRYSTAL = var

Remarks

var | A numeric constant with the Frequency of the crystal.  
---|---  
  
The frequency is selectable from the [Compiler Settings](options_compiler_communication.md). It is stored in a configuration file. The $CRYSTAL directive overrides this setting.

It is best to use the $CRYSTAL directive as the used crystal frequency is visible in your program that way.

![notice](notice.jpg) The $CRYSTAL directive only informs the compiler about the used frequency. It does not set any fuse bit. The frequency must be know by the compiler for a number of reasons. First when you use serial communications, and you specify [$BAUD](baud_1.md), the compiler can calculate the proper settings for the UBR register. And second there are a number of routines like [WAITMS](waitms.md), that use the execution time of a loop to generate a delay. When you specify $CRYSTAL = 1000000 (1 MHz) but in reality, connect a 4 MHz XTAL, you will see that everything will work 4 times as quick.

![notice](notice.jpg)Most new AVR chips have an internal oscillator that is enabled by default. Check the data sheet for the default value.

Most new AVR chips have an option to divide the oscillator frequency by a number of values. If these options are used you need to take this into account.

For example, you connect a 16 MHz crystal and select the external oscillator fuse byte, this would result in a 16 MHz clock for most old processors.

Most new processors have an internal divider which can be enabled. This is an 8-divider in most cases. So in such a case, the resulting frequency would be 2 MHz. $crystal should have a value of 2 MHz in that case.

Instead of changing the divider fusebyte you can also use the CONFIG CLOCKDIV statement to select the division factor.

In case you have a crystal with 16 MHz and you code has code like : CONFIG CLOCKDIV=4 , you would use $CRYSTAL=4000000

Thus $crystal is the clock value used to clock the processor.

Here follows some more info :

What might not be clear : $crystal value does not reflect the value of the xtal you put in your circuit. But it reflects the value of the system clock. 

Early older processors just had a provision for using an external oscillator. For example you could connect a 24 MHz xtal. There was no divider or option to divide this frequency. So the oscillator frequency was directly connected to the processor. This meant : xtal=processor clock

For this reason there was the $crystal directive. There were simply no internal oscillators. 

But later series got options with an internal oscillator. And also options to set a fuse to divide the clock by 8 or some times 16. 

Later series also had a divisor/pre scaler between the xtal oscillator and the system clock input.

So you start with an oscillator frequency of 16 Mhz. The divider is by default 1 so it will result in a 16 Mhz clock. For this reason you use $crystal=16000000

Now when you want to run on 8 Mhz, you still have 16 Mhz osc. so you divide by 2. This means your system clock will be 8 Mhz. And for this reason you set $crystal to a value of 8000000

In short, $crystal value must reflect the system clock.

The reason is that many options need to know the system clock. For example for waitms, waitus, etc. But also when setting a baud rate.

When designed when all AVR chips were known the $crystal directive probably was named $systemclock or something like that.

See also

[$BAUD](baud_1.md) , [BAUD](baud_2.md) , [CONFIG CLOCKDIV](config_clockdiv.md)

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Print "Hello world"

End

```

---

## $DATA

Action

Instruct the compiler to store the data in the DATA lines following the $DATA directive, in code memory.

Syntax

$DATA

Remarks

The AVR has built-in EEPROM. With the WRITEEEPROM and READEEPROM statements, you can write to and read from the EEPROM.

To store information in the EEPROM, you can add DATA lines to your program that hold the data that must be stored in the EEPROM.

A separate file is generated with the EEP extension. This file can be used to program the EEPROM.

The compiler must know which DATA must go into the code memory and which into the EEPROM memory and therefore two compiler directives were added.

```vb
$EEPROM and $DATA.

$EEPROM tells the compiler that the DATA lines following the compiler directive must be stored in the EEP file.

```
To switch back to the default behavior of the DATA lines, you must use the $DATA directive.

The READ statement that is used to read the DATA info may only be used with normal DATA lines. It does not work with DATA stored in EEPROM.

![notice](notice.jpg) Do not confuse $DATA directive with the DATA statement.

So while normal DATA lines will store the specified data into the code memory of the micro which is called the flash memory, the $EEPROM and $DATA will cause the data to be stored into the EEPROM. The EEP file is a binary file.

See also

[$EEPROM](eeprom.md) , [READEEPROM](readeeprom.md) , [WRITEEEPROM](writeeeprom.md) , [DATA](data_2.md)

ASM

NONE

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : AT90S2313

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates $DATA directive

'-------------------------------------------------------------------------------

$regfile = "2313def.dat"

$baud = 19200

$crystal = 4000000 ' 4 MHz crystal

$hwstack = 16

$swstack = 16

$framesize = 16

Dim B As Byte

```
Readeeprom B , 0 ' now B will be 1

End

Dta:

$eeprom

Data 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8

```vb
$data

End

```

---

## $DEFAULT

Action

Set the default for data types dimensioning to the specified type.

Syntax

$DEFAULT var

Remarks

Var | SRAM, XRAM, ERAM  
---|---  
  
Each variable that is dimensioned will be stored into SRAM, the internal memory of the chip. You can override it by specifying the data type.

Dim B As XRAM Byte , will store the data into external memory.

When you want all your variables to be stored in XRAM for example, you can use the statement : $DEFAULT XRAM

Each Dim statement will place the variable in XRAM in that case.

To switch back to the default behavior, use $END $DEFAULT

See also

NONE

ASM

NONE

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

$default Xram

Dim A As Byte , B As Byte , C As Byte

'a,b and c will be stored into XRAM

$default Sram

Dim D As Byte

'D will be stored in internal memory, SRAM

```

---

## $EEPROM

Action

Instruct the compiler to store the data in the DATA lines following the $EEPROM directive in an EEP file.

Syntax

$EEPROM

Remarks

The AVR has built-in EEPROM. With the WRITEEEPROM and READEEPROM statements, you can write to and read from the EEPROM.

To store information in the EEPROM, you can add DATA lines to your program that hold the data that must be stored in the EEPROM.

A separate file is generated with the EEP extension. This file can be used to program the EEPROM.

The compiler must know which DATA must go into the code memory and which into the EEPROM memory and therefore two compiler directives were added.

```vb
$EEPROM and $DATA.

$EEPROM tells the compiler that the DATA lines following the compiler directive must be stored in the EEP file.

```
To switch back to the default behavior of the DATA lines, you must use the $DATA directive.

The READ statement that is used to read the DATA info may only be used with normal DATA lines. It does not work with DATA stored in EEPROM.

![notice](notice.jpg) Do not confuse $DATA directive with the DATA statement.

So while normal DATA lines will store the specified data into the code memory of the micro which is called the flash memory, the [$EEPROM](eeprom.md) and $DATA will cause the data to be stored into the EEPROM. The EEP file is a binary file. The [$EEPROMHEX](_eepromhex.md) directive can be used to create Intel HEX records in the EEP file 

See also

[$EEPROM](eeprom.md) , [READEEPROM](readeeprom.md) , [WRITEEEPROM](writeeeprom.md) , [DATA](data_2.md) , [$EEPROMHEX](_eepromhex.md)

ASM

NONE

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : AT90S2313

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates $DATA directive

'-------------------------------------------------------------------------------

$regfile = "2313def.dat"  
$baud = 19200  
$crystal = 4000000 ' 4 MHz crystal  
$hwstack = 16  
$swstack = 16  
$framesize = 16  
  
Dim B As Byte  
```
Readeeprom B , 0 'now B will be 1  
End  
  
Dta:  
$eeprom  
Data 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8  
```vb
$data  
End

```

---

## $EEPROMSIZE

Action

Instruct the compiler to override the EEPROM size of the micro processor.

Syntax

$EEPROMSIZE = size

size | The size in bytes of the EEPROM.   
---|---  
  
Remarks

The AVR has build in EEPROM. With the WRITEEEPROM and READEEPROM statements, you can write and read to the EEPROM. You can also use the ERAM pseudo variables to read/write EEPROM.

When you use an external EEPROM and an alternative EEPROM library such as FM24C16 or FM25C256 you can override the internal EEPROM. All EEPROM routines will use the external EEPROM then. This way you are able to use a bigger EEPROM than internal available. Or you can use a quicker EEPROM such as a RAMTRON FRAM EEPROM. These EEPROM's are as quick as SRAM and also can be written to almost unlimited times. 

![notice](notice.jpg) When using an external EEPROM and $EEPROMSIZE , take care that the supported programmers can not write to this EEPROM. They assume the internal EEPROM.

See also

[FM24C16](fm24c16.md), [FM25C256](fm25c256.md)

Example

$eepromsize = &H8000

---

## $EXTERNAL

Action

Instruct the compiler to include ASM routines from a library.

Syntax

$EXTERNAL Myroutine [, myroutine2]

Remarks

You can place ASM routines in a library file. With the $EXTERNAL directive you tell the compiler which routines must be included in your program.

See also

[$LIB](lib.md)

Example

```vb
$regfile = "m48def.dat"  
$crystal = 4000000  
$baud = 19200  
$hwstack = 16  
$swstack = 16  
$framesize = 16  
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  
'In order to let this work you must put the mylib.lib file in the LIB dir  
'And compile it to a LBX  
'-------------------------------------------------------------------------  
'define the used library  
$lib"mylib.lbx"  
'you can also use the original ASM :  
'$LIB "mylib.LIB"  
  
'also define the used routines  
$external Test  
'this is needed so the parameters will be placed correct on the stack  
Declare Sub Test(byval X As Byte , Y As Byte)  
'reserve some space  
Dim Z As Byte  
'call our own sub routine  
```
Call Test(1 , Z)  
```vb
'z will be 2 in the used example  
End

```

---

## $FILE

Action

Change name of generated files.

Syntax

$FILE = "myname.bin"

Remarks

In some cases it is desired to change the name of the output file. By default, the generated files have the same base name as the opened project file. So if your program name is "mytest.bas" , all generated files will start with the base "mytest".

The $FILE directive let you change this base name. 

![notice](notice.jpg)Simulating and programming will NOT work since the IDE uses the base name of your project. If you change it with $FILE, the files can not be located. 

See also

NONE

Example

$FILE = "mytest.bin"

---

## $FRAMEPROTECT

Action

This directive will enable or disable interrupt frame protection.

Syntax

$FRAMEPROTECT = value

Remarks

Value must be a constant expression that evaluates to false (0) or true (<>0).

By default the frame protection is off. 

When a user function/sub passes parameters with byval, a copy is created and passed to the user sub/function.

When an interrupt is executed, and it calls user sub/functions with parameters passed with byval, the values can get corrupted. 

When activated, the compiler disables interrupts before passing variables, and enables interrupts (when they were enabled) inside the user sub/function. This ensures that the values can not get corrupted from an interrupt which is calling other user sub/functions. 

When you do not call user sub/functions from inside your interrupt you can omit the $frameprotect directive or set it to 0 in order to reduce code.

In version 2075 the compiler had frame protection as a default, and the $NOFRAMEPROTECT served as an override. While you can still use $NOFRAMEPROTECT, it is off by default in 2076 to the preferred switch is $FRAMEPROTECT = 0|1

When you activate frame protection the internal constant named _FPROTECT will be set to 1. 

When you have a user function that calls an ASM library, you must include code to restore the I-flag.

The bcd.lib user lib sample demonstrates this with this code :

#IF _FPROTECT

Out sreg,r3 ; restore I flag

#ENDIF

See also

[$NOFRAMEPROTECT](noframeprotect.md)

Example

```vb
'************************************************  
' TESTING THE FRAME PARAMETER PASSING  
' UNDER HEAVY INTERRUPT LOAD  
'************************************************  
  
' file: frame_pass_test.bas  
  
$regfile = "m88def.dat"  
$crystal = 8000000  
$hwstack = 100  
$swstack = 100  
$framesize = 100  
  
$noframeprotect ' in this sample, disabling the frame protection will result in errors

$frameprotect=0 ' from version 2076, this is the preferred method  
  
Dim Ww As Word , Www As Word , Wwww As Word  
Declare Sub Stack_checking(byval Identifier As Integer )  
  
$baud = 19200  
```
Open "com1:" For Binary As #1  
  
Const T0_idozito = 100  
```vb
Config Timer0 = Timer , Prescale = 1024 '256 --> 4.096 msec egység, 1024 --> 16.384 msec  
On Ovf0 Timer0_interrupt  
Enable Timer0  
```
Start Timer0  
Load Timer0 , T0_idozito  
  
```vb
' These routines are called under the timer interrupt  
Declare Sub Under_it_pass_1(byval Inpar1_uit As Word )  
Declare Sub Under_it_pass_2(byval Inpar2_uit As Word )  
Declare Sub Test()  
' These routines are called in the main loop  
Declare Sub Inmain_test_routine_1(byval Im1_par1 As Word , Byval Im1_par2 As Word , Byval Im1_par3 As Word , Byval Im1_par4 As Word , Byval Im1_par5 As Word , Byval Im1_par6 As Word )  
Declare Sub Inmain_test_routine_2(byval Im2_par1 As Word , Byval Im2_par2 As Word , Byval Im2_par3 As Word , Byval Im2_par4 As Word , Byval Im2_par5 As Word , Byval Im2_par6 As Word )  
Declare Sub Inmain_test_routine_3(byval Im3_par1 As Word , Byval Im3_par2 As Word , Byval Im3_par3 As Word , Byval Im3_par4 As Word , Byval Im3_par5 As Word , Byval Im3_par6 As Word )  
  
' Routine-1 parameters are stored here  
Dim Dim1_p1 As Word  
Dim Dim1_p2 As Word  
Dim Dim1_p3 As Word  
Dim Dim1_p4 As Word  
Dim Dim1_p5 As Word  
Dim Dim1_p6 As Word  
  
' Routine-3 parameters are stored here  
Dim Dim3_p1 As Word  
Dim Dim3_p2 As Word  
Dim Dim3_p3 As Word  
Dim Dim3_p4 As Word  
Dim Dim3_p5 As Word  
Dim Dim3_p6 As Word  
  
```
Program_begins_here:  
```vb
Enable Interrupts  
Print #1 , "PROGRAM BEGIN"  
Do  
```
Call Inmain_test_routine_1(&Haaaa , &HAAAA , &HAAAA , &HAAAA , &HAAAA , &HAAAA )  
  
Call Inmain_test_routine_2(&Haaaa , &HAAAA , &HAAAA , &HAAAA , &HAAAA , &HAAAA )  
  
Call Inmain_test_routine_3(&Haaaa , &HAAAA , &HAAAA , &HAAAA , &HAAAA , &HAAAA )  
```vb
Loop  
  
' All the three routines always gets all parameters as &hAAAA, if they see anything else, they print an error  
' routine_1 stores to DIM area and checks the stored values  
' routine 2 check immediately the incoming parameters  
' routine_3 completely identical to routine_1, except the parameter passing protection  
'  
  
Sub Inmain_test_routine_1(byval Im1_par1 As Word , Byval Im1_par2 As Word , Byval Im1_par3 As Word , Byval Im1_par4 As Word , Byval Im1_par5 As Word , Byval Im1_par6 As Word )  
```
Dim1_p1 = Im1_par1 : Dim1_p2 = Im1_par2 : Dim1_p3 = Im1_par3 : Dim1_p4 = Im1_par4 : Dim1_p5 = Im1_par5 :

Dim1_p6 = Im1_par6  
If Dim1_p1 <> &HAAAA Or Dim1_p2 <> &HAAAA Or Dim1_p3 <> &HAAAA Or Dim1_p4 <> &HAAAA Or Dim1_p5 <> &HAAAA _

Or Dim1_p6 <> &HAAAA Then  
```vb
Print #1 , " PAR ERROR R1 " ; Hex(dim1_p1 ) ; " " ; Hex(dim1_p2 ) ; " " ; Hex(dim1_p3 ) ; " " ;  
Print #1 , Hex(dim1_p4 ) ; " " ; Hex(dim1_p5 ) ; " " ; Hex(dim1_p6 )  
End If  
End Sub  
  
Sub Inmain_test_routine_2(byval Im2_par1 As Word , Byval Im2_par2 As Word , Byval Im2_par3 As Word , Byval Im2_par4 As Word , Byval Im2_par5 As Word , Byval Im2_par6 As Word )  
If Im2_par1 <> &HAAAA Or Im2_par2 <> &HAAAA Or Im2_par3 <> &HAAAA Or Im2_par4 <> &HAAAA Or Im2_par5 <> &HAAAA Or _ Im2_par6 <> &HAAAA Then  
Print #1 , " PAR ERROR R2 " ; Hex(im2_par1 ) ; " " ; Hex(im2_par2 ) ; " " ; Hex(im2_par3 ) ; " " ;  
Print #1 , Hex(im2_par4 ) ; " " ; Hex(im2_par5 ) ; " " ; Hex(im2_par6 )  
End If  
End Sub  
  
Sub Inmain_test_routine_3(byval Im3_par1 As Word , Byval Im3_par2 As Word , Byval Im3_par3 As Word , Byval Im3_par4 As Word , Byval Im3_par5 As Word , Byval Im3_par6 As Word )  
```
Dim3_p1 = Im3_par1 : Dim3_p2 = Im3_par2 : Dim3_p3 = Im3_par3 : Dim3_p4 = Im3_par4 : Dim3_p5 = Im3_par5 :

Dim3_p6 = Im3_par6  
If Dim3_p1 <> &HAAAA Or Dim3_p2 <> &HAAAA Or Dim3_p3 <> &HAAAA Or Dim3_p4 <> &HAAAA Or Dim3_p5 <> &HAAAA Or _

Dim3_p6 <> &HAAAA Then  
```vb
Print #1 , " PAR ERROR R3 " ; Hex(dim3_p1 ) ; " " ; Hex(dim3_p2 ) ; " " ; Hex(dim3_p3 ) ; " " ;  
Print #1 , Hex(dim3_p4 ) ; " " ; Hex(dim3_p5 ) ; " " ; Hex(dim3_p6 )  
End If  
End Sub  
  
Dim Under_it_store_1 As Word  
Dim Under_it_store_2 As Word  
  
' these two routines are called under timer IT  
' They don't do much, except use the frame for parameter passing  
  
Sub Under_it_pass_1(byval Inpar1_uit As Word )  
```
Under_it_store_1 = Inpar1_uit  
```vb
End Sub  
  
Sub Under_it_pass_2(byval Inpar2_uit As Word )  
```
Under_it_store_2 = Inpar2_uit  
```vb
End Sub  
  
' Timer IT calling two routines which use the frame  
  
```
Timer0_interrupt:  
Load Timer0 , T0_idozito  
Call Under_it_pass_1(&H5555 )  
Call Under_it_pass_2(&H3333 )  
```vb
Return  
  
  
End  
  
  


```

---

## $HWCHECK, $SWCHECK, $SOFTCHECK

Action

This directive can be used to determine the required stack space.

Syntax

```vb
$HWCHECK

$FRAMECHECK

$SOFTCHECK

```
Remarks

All variables you DIM in your application require RAM or SRAM space. But an application needs more RAM space.

Each time you call a sub or function, or us gosub, the processor need to know at which address to return after returning from the call. For this purpose, the processor saves this address on the hardware stack. There is noting you can do about this. This hardware stack grows downwards. Some basic statements compile into code that do not need any calls. But some call a machine language function which in turn can call other functions. Which and how many other calls will be made depend on the selected processor and other options. sometimes it also depends on variable parameters.

When parameters are passed to a sub or function, the address is passed of the variables. These are word addresses thus using 2 bytes for each variable. This passing is being done via the so called soft stack. This area is located below the HW stack space. And it also grows down.

All LOCAL variables you use also need 2 bytes of the soft stack.

When you pass a parameter with BYVAL or when you create a LOCAL variable, some temporarily space is need. 

Consider this example : somestring = "abc" + somestring 

When the compiler assigns "abc" to somestring, the somestring variable will become "abc" and it will overwrite the content making it impossible to add it's content after the "abc".

So we first need to store the content of somestring before we can start assigning new data to this string.

This copy also requires space.

This space is created dynamically and is taken from the so called frame space. This space is located below the soft stack.

Now you can use $DBG or some default values for most projects to determine the values.

But when you have a problem and have absolutely no idea how the settings must be made, you can use the $HWCHECK option.

You start with including a special library named "stackcheck.lib" to your code.

Then you run your application and somewhere in your code you print the value of the generated _hw_lowest variable.

This variable is set to &HFFFF and each time a call is made, the stack is compared to this value. If the hardware stack (SPL and SPH registers) are lower then the _hw_lowest value, _hw_lowest is assigned with the new lowest stack value.

This way you determine the lowest possible hardware stack value that occurred during the runtime of your application. 

Of course it is important that your application runs all code.

You can print the value or show it on LCD. To determine the actual needed space you subtract it from the stacktop value.

```vb
For the softstack the same applies. It will store the lowest Y-pointer value to the variable named _sw_lowest.

For the framespace the the variable _fw_highest is used and this variables is increasing.

```
The stackcheck.bas example demonstrates how to retrieve the values when a recursive sub is used.

See also

NONE

Example

```vb
$regfile = "m88def.dat"  
$hwstack = 40  
$swstack = 80  
$framesize = 80  
$lib "stackcheck.lib"  
  
Declare Sub Test(byval Prm As Byte)  
  
Print "stack test"  
  
Dim G As Byte , W As Word  
Dim P As Byte  
  
$hwcheck 'hw stack check on  
$framecheck  
$softcheck  
  
```
Test P  
Print _hw_lowest  
W = _hwstackstart - _hw_lowest  
```vb
Print "HW stack needed : " ; W  
  
Print _fw_highest  
If _fw_highest > 0 Then  
```
W = _frame_high - _fw_highest  
```vb
Print "Frame space needed : " ; W  
End If  
  
  
Print _sw_lowest  
```
W = _hwstack_low - _sw_lowest  
```vb
Print "SW stack needed : " ; W  
  
  
End  
  
  
Sub Test(byval Prm As Byte)  
```
Local L As Byte  
```vb
Print "HWSTACK:" ; _hw_lowest  
Print "Frame:" ; _fw_highest  
Print "SWSTACK:" ; _sw_lowest  
  
```
G = G + 1 ' global var  
```vb
If G >= 5 Then  
Exit Sub  
Else  
```
Test P 'recursive call  
```vb
End If  
End Sub

```

---

## $INCLUDE

Action

Includes an ASCII file in the program at the current position.

Syntax

$INCLUDE "file"

Remarks

File | Name of the ASCII file, which must contain valid BASCOM statements. This option can be used if you make use of the same routines in many programs. You can write modules and include them into your program. If there are changes to make you only have to change the module file, not all your BASCOM programs. You can only include ASCII files! An include file will only be included once, even if you include it multiple times.  
---|---  
  
Use [$INC](_inc.md) when you want to include binary files.

You can specify an absolute file name (with a drive and full path) like : $INCLUDE "c:\folder\myfile.bas"

Or you can specify a relative file name like : $INCLUDE "myfile.bas"

The main program path will be used to determine the absolute file name. 

If your main file is stored under c:\abc\main.bas , and you include a file named "test.inc" , the compiler expects a file named "c:\abc\test.inc"

You can include a path too. The path is relative to the main file.

When used in sub folders use " \ " (back slash). The path uses the DOS/Windows convention. A forward slash will work too since windows does not seem to be bothered with it. 

Example with sub folder Test: $include "Test\my_functions.bas"

When you include sub procedures and functions before the actual code, your code will run into this code. You can use a GOTO to jump over the included code or you can use CONFIG SUBMODE=NEW so that the compiler will only include the used functions. See Example2

See Also

[$INC](_inc.md) , [CONFIG SUBMODE=NEW](config_submode.md)

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$hwstack = 10  
$swstack = 10  
$framesize = 26

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

'--------------------------------------------------------------

Print "INCLUDE.BAS"

'Note that the file 123.bas contains an error

$include "123.bas" 'include file that prints Hello

Print "Back in INCLUDE.BAS"

End

```
Example2

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$hwstack = 10  
$swstack = 10  
$framesize = 26

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

'--------------------------------------------------------------

$include "mysubs.bas" 'include file with sub procedures

'this is the included code : Sub Test()

' print "Test"

' End Sub 

'Without a GOTO to jump over the included code the code will run into the sub without a call

' Or use CONFIG SUBMODE=NEW so you do not need to change a thing

Print "Back in INCLUDE.BAS"

End

```

---

## $LIB

Action

Informs the compiler about the used libraries.

Syntax

$LIB "libname1" [, "libname2"]

Remarks

Libname1 is the name of the library that holds ASM routines that are used by your program. More filenames can be specified by separating the names by a comma.

The specified libraries will be searched when you specify the routines to use with the $EXTERNAL directive.

The search order is the same as the order you specify the library names.

The MCS.LBX will be searched last and is always included so you don't need to specify it with the $LIB directive.

Because the MCS.LBX is searched last you can include duplicate routines in your own library. These routines will be used instead of the ones from the default MCS.LBX library. This is a good way when you want to enhance the MCS.LBX routines. Just copy the MCS.LIB to a new file and make the changes in this new file. When we make changes to the library your changes will be preserved.

Creating your own LIB file

A library file is a simple ASCII file. It can be created with the BASCOM editor, notepad or any other ASCII editor.

When you use BASCOM, make sure that the LIB extension is added to the Options, Environment, Editor, "No reformat extension".

This will prevent the editor to reformat the LIB file when you open it.

The file must include the following header information. It is not used yet but will be later.

copyright = Your name

www = optional location where people can find the latest source

email = your email address

comment = AVR compiler library

libversion = the version of the library in the format : 1.00

date = date of last modification

statement = A statement with copyright and usage information

The routine must start with the name in brackets and must end with the [END].

The following ASM routine example is from the MYLIB.LIB library.

[test]

Test:

ldd r26,y+2 ; load address of X

ldd r27,y+3

ld r24,x ; get value into r24

Inc r24 ; value + 1

St x,r24 ; put back

ldd r26,y+0 ; address of Y

ldd r27,y+1

st x,r24 ; store

ret ; ready

[END]

After you have saved your library in the LIB subdirectory you must compile it with the [LIB Manager](tools_lib_manager.md). Or you can include it with the LIB extension in which case you donât have to compile it.

About the assembler.

When you reference constants that are declared in your basic program you need to put a star(*) before the line.

' Basic Program

CONST myconst = 7

' asm lib

* sbi portb, myconst

By adding the *, the line will be compiled when the basic program is compiled. It will not be changed into object code in the LBX file.

When you use constants you need to use valid BASIC constants:

Ldi r24,12

Ldi r24, 1+1

Ldi r24, &B001 ; binary basic

Ldi r24,0b001 ; binary

Ldi r24,&HFF ; hex basic

Ldi r24,$FF ; hex

Ldi r24,0xFF ; hex

Other syntax is NOT supported.

See also

[$EXTERNAL](external.md)

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

'In order to let this work you must put the mylib.lib file in the LIB dir

'And compile it to a LBX

'-------------------------------------------------------------------------

'define the used library

$lib"mylib.lbx"

'you can also use the original ASM :

'$LIB "mylib.LIB"

'also define the used routines

$external Test

'this is needed so the parameters will be placed correct on the stack

Declare Sub Test(byval X Asbyte , Y Asbyte)

'reserve some space

Dim Z As Byte

'call our own sub routine

```
Call Test(1 , Z)

```vb
'z will be 2 in the used example

End

```

---

## $LOADER

Action

Instruct the compiler to create a boot loader at the specified address.

Can be used for all AVR that support a boot loader like ATMEGA and ATXMEGA chips.

Syntax

$LOADER = address [,BOOTONLY]

Remarks

address | The address where the boot loader is located. You can find this address in the data sheet.  In version 2081 a constant named _LOADER_PAGE is created that holds the 64 KB page number.   
---|---  
BOOTONLY | Normally when the BIN and HEX files are created, they are an image of the processor flash memory. The BOOTONLY option will write only the code for the BOOT area to the BIN file. This option has no effect on the HEX file. Writing just the boot portion to a binary file allows to include the boot loader code using the $INC directive to a normal program.   
  
A lot of AVR microcontrollers are configured such that it is possible to use a boot

loader able to receive firmware updates and to reprogram the Flash memory on

demand. 

These AVR which support boot loader have a so called boot section. 

Normally a chip will start at address 0 when it resets. 

This is also called the reset vector.

Chips that have a boot section, split the flash memory in two parts. The boot section is a small part of the normal flash and by setting a fuse bit you select that the chip runs code at the boot sector when it resets instead of the normal reset vector.

The Program Flash memory space of ATXMEGA chips is also divided into Application and Boot sections. Both sections

have dedicated Lock Bits for setting restrictions on write or read/write operations.

ATXMEGA Program Flash memory parts:

1.| Application Section for application code  
---|---  
  
2.| Application Table Section for application code or data storage  
---|---  
  
3.| Boot Section for application code or bootloader code  
---|---  
  
![notice](notice.jpg)You need to set the fuse bits so the chip jump to the boot loader address at reset (BOOTRST) ! 

Some chips also have fuse bits to select the size of the boot loader (e.g. 1024 words, 2048 words, 4096 words)

The boot loader start address depends also on the boot size.

You can find following information in the data sheet of the device (example for ATMEGA644):

Boot Size | Boot Loader Flash Section | Boot Reset Address (Start Boot Loader Section)  
---|---|---  
512 words | 0x7E00 - 0x7FFF | $loader = $7E00  
1024 words | 0x7C00 - 0x7FFF | $loader = $7C00  
2048 words | 0x7800 - 0x7FFF | $loader = $7800  
4096 words | 0x7000 - 0x7FFF | $loader = $7000  
  
For ATXMEGA chips like ATXMEGA32A4 the boot section is part of the Flash Program Memory.

You can find following information in the data sheet of the ATXMEGA device under Flash Program Memory

(example for ATxmega16A4 .....ATxmega128A4):

Chip | Boot Loader Flash Section | Boot Reset Address (Start Boot Loader Section)  
---|---|---  
ATxmega16A4 | 0x2000 - 0x7FFF | $loader = &H2000  
ATxmega32A4 | 0x4000 - 0x47FF | $loader = &H4000  
ATxmega64A4 | 0x8000 - 0x87FF | $loader = &H8000  
ATxmega128A4 | 0x10000 - 0x10FFF | $loader = &H10000  
  
![notice](notice.jpg)An external programmer is needed to program the boot loader into the chip. After the fuse bits are set and the boot loader is programmed you do not need the external programmer anymore for this chip (except you want to change the fuse bits).

The MCS boot loader sample is a serial boot loader that uses the serial port (USART).

With ATXMEGA or with ATMEGA with more then one USART you can choose which USART (COM port) should be used with the boot loader.

```vb
For example you can use COM7 with an ATXMEGA:

  
Config Com7 = 57600 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8 '   
```
Open "COM7:" For Binary As #7  


![notice](notice.jpg)When using another UART as COM1 do not forget to add the Interface number (in this example #7) to all the Serial IO functions like Waitkey(#7) or Print #7 , Chr(bstatus); in the boot loader example  


The boot loader uses the X-modem checksum protocol to receive the data. (XModem protocol (packet size = 128))

Most terminal emulators can send X-modem checksum.

The Boot loader sample can upload both normal flash programs and EEPROM images.

The Boot loader sends a byte with value of 123 to the AVR Boot loader. This boot loader program then enter the boot loader or will jump to the reset vector (0000) to execute the normal flash program.

When it receives 124 instead of 123, it will upload the EEPROM.

When you select a BIN file the flash will be uploaded. When you select an EEP file, the EEPROM will be uploaded.

The following sample is written so it supports all chips with a boot section. 

How you need to use this ATMEGA boot loader example program:

1.|  Uncomment the Chip type and Const Loaderchip you want to use (for example ATMEGA644)  
---|---  
  
```vb
$regfile = "m644def.dat"  
'$regfile = "m644Pdef.dat"  
```
Const Loaderchip = 644

2.| Double check the baud rate and COM port you want to use  
---|---  
  
3.| Compile the boot loader example  
---|---  
  
4.| Program it into the chip with an external programmer like AVR ISP MKII  
---|---  
  
5.| Select [MCS Bootloader](mcsbootloader.md) from programmer (select the right COM Port and baud rate)  
---|---  
  
6.| compile a new program or example for this chip  
---|---  
  
7.| reset the chip  
---|---  
  
Ways to reset the AVR chip:

Hardware reset:

1.|  Hardware Reset switch/button to GND (manual)  
---|---  
  
2.|  MCS Bootloader can set and reset the DTR or RTS line of serial COM port which can be used to reset the AVR (automatic)  
---|---  
  
Software Reset:

1.|  Reset with Watchdog Timer (e.g. setting the Watchdog to 16ms, start it and let it time out)  
---|---  
  
2.|  With GOTO command (e.g. when ATMEGA644 is used the boot loader start at $7c00 ($loader = $7c00).  
---|---  
  
```vb
Then you can use:

GOTO &H7c00

```
to jump to the boot loader start.

3.|  With ATXMEGA there is a special register to reset the ATXMEGA via software. See also topic ATXMEGA   
---|---  
  
4.|  With MCS Bootloader you can send one or several ASCII character to reset the chip like with string "boot_me". In this case the "boot_me" must be detected in your main application on the AVR and then use for example Watchdog or GOTO to reset the chip.   
---|---  
  
The boot loader is written to work at a baud rate of 57600. This baud rate works for most chips that use the internal oscillator. But it is best to check it first with a simple program. When you use a crystal you might even use a higher baud rate. 

You can change this by changing the baud rate in the boot loader example (take care to use also the same baud rate in the boot loader application (e.g. [MCS Bootloader](mcsbootloader.md)) on the PC side)

Now make a new test program and compile it. Press F4 to start the [MCS bootloader](mcsbootloader.md). You now need to reset the chip so that it will start the boot loader section. The boot loader will send a byte with value of 123 and the Bascom boot loader receives this and thus starts the loader process.

There will be a stand alone boot loader available too. And the sample will be extended to support other AVR chips with boot section too.

![notice](notice.jpg) There is a $BOOT directive too. It is advised to use $LOADER as it allows you to write the boot loader in BASIC.

![important](important.jpg)You can not use interrupts in your boot loader program as the interrupts will point to the reset vector which is located in the lower section of the flash. When you start to writing pages, you overwrite this part.

![notice](notice.jpg)Take care when Watchdog is enabled by fuse bits and using a boot loader. You need to reset or deactivate the Watchdog in the boot loader example otherwise the firmware upload could be terminated by watchdog reset !

![notice](notice.jpg)If you want to analyze the MCU Control and Status Register to know which reset source caused the reset you need to save this register already in the boot loader example because this register will be cleared and it will be always 0 when you check it at start of your application.

![notice](notice.jpg)When you use a boot loader it will use space from the available flash memory. The compiler does not know if you use a boot loader or not. When your program exceeds the available space and runs into the boot sector space, it will overwrite the boot loader.

The [$LOADERSIZE](loadersize.md) directive will take the boot loader size into account so you will get an error when the target file gets too big.

Encryption/Decryption with Bootloader:

You can use for example AES or XTEA ( [XTEADECODE](xteadecode.md), [XTEAENCODE](xteaencode.md) ) in combination with boot loader examples.

There is an AES with boot loader and AVR-DOS example in the ...BASCOM-AVR\SAMPLES\boot folder (xmega_dos_boot_AES.zip).

See also

[$BOOT](_boot.md) , [$LOADERSIZE](loadersize.md), [MCS Bootloader](mcsbootloader.md) , [CONFIG INTVECTORSELECTION](config_intvectorselection.md) , [$BOOTVECTOR](bootvector.md)

There is an example for ATMEGA chips and for ATXMEGA Chips:

ATMEGA Example:

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' Bootloader.bas  
' This sample demonstrates how you can write your own bootloader  
' in BASCOM BASIC  
' VERSION 2 of the BOOTLOADER. The waiting for the NAK is stretched  
' further a bug was resolved for the M64/M128 that have a big page size  
'-----------------------------------------------------------------  
'This sample will be extended to support other chips with bootloader  
'The loader is supported from the IDE  
$crystal = 8000000  
'$crystal = 14745600  
$baud = 57600 'this loader uses serial com  
'It is VERY IMPORTANT that the baud rate matches the one of the boot loader  
'do not try to use buffered com as we can not use interrupts  
  
'possible return codes of the PC bootloader.exe  
' -6005 Cancel requested  
' -6006 Fatal time out  
' -6007 Unrecoverable event during protocol  
' -6008 Too many errors during protocol  
' -6009 Block sequence error in Xmodem  
' -6016 Session aborted  
  
'$regfile = "m8def.dat"  
  
'Const Loaderchip = 8  
'$regfile = "m168def.dat"  
'Const Loaderchip = 168  
  
'$regfile = "m16def.dat"  
'Const Loaderchip = 16  
  
'$regfile = "m32def.dat"  
'Const Loaderchip = 32  
  
'$regfile = "m88def.dat"  
'Const Loaderchip = 88  
  
'$regfile = "m162def.dat"  
'Const Loaderchip = 162  
  
'$regfile = "m8515.dat"  
'Const Loaderchip = 8515  
  
'$regfile = "m128def.dat"  
'Const Loaderchip = 128  
  
'$regfile = "m64def.dat"  
'Const Loaderchip = 64  
  
'$regfile = "m2561def.dat"  
'Const Loaderchip = 2561  
  
'$regfile = "m2560def.dat"  
'Const Loaderchip = 2560  
  
'$regfile = "m329def.dat"  
'Const Loaderchip = 329  
  
'$regfile = "m324pdef.dat"  
'Const Loaderchip = 324  
  
$regfile = "m644def.dat"  
'$regfile = "m644Pdef.dat"  
```
Const Loaderchip = 644  
  

```vb
#if Loaderchip = 88 'Mega88  
$loader = $c00 'this address you can find in the datasheet  
'the loader address is the same as the boot vector address  
```
Const Maxwordbit = 5  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 168 'Mega168  
$loader = $1c00 'this address you can find in the datasheet  
'the loader address is the same as the boot vector address  
```
Const Maxwordbit = 6  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 32 ' Mega32  
$loader = $3c00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  

#if Loaderchip = 8 ' Mega8  
$loader = $c00 ' 1024 words  
```
Const Maxwordbit = 5 'Z5 is maximum bit  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  

#if Loaderchip = 161 ' Mega161  
$loader = $1e00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit  

```vb
#endif  

#if Loaderchip = 162 ' Mega162  
$loader = $1c00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 8515 ' Mega8515  
$loader = $c00 ' 1024 words  
```
Const Maxwordbit = 5 'Z6 is maximum bit  
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  
Osccal = &HB3 ' the internal osc needed a new value  

```vb
#endif  
  

#if Loaderchip = 64 ' Mega64  
$loader = $7c00 ' 1024 words  
```
Const Maxwordbit = 7 'Z7 is maximum bit   
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 128 ' Mega128  
$loader = &HFC00 ' 1024 words  
```
Const Maxwordbit = 7 'Z7 is maximum bit  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 2561 ' Mega2561  
$loader = &H1FC00 ' 1024 words  
```
Const Maxwordbit = 7 'Z7 is maximum bit   
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 2560 ' Mega2560  
$loader = &H1FC00 ' 1024 words  
```
Const Maxwordbit = 7 'Z7 is maximum bit   
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 16 ' Mega16  
$loader = $1c00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit   
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 329 ' Mega32  
$loader = $3c00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit  
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  

#if Loaderchip = 324 ' Mega32  
$loader = $3c00 ' 1024 words  
```
Const Maxwordbit = 6 'Z6 is maximum bit   
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  
  

#if Loaderchip = 644 ' Mega644P  
$loader = $7c00 ' 1024 words  
```
Const Maxwordbit = 7 'Z7 is maximum bit   
```vb
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  

#endif  
  
```
Const Maxword =(2 ^ Maxwordbit) * 2 '128  
Const Maxwordshift = Maxwordbit + 1  
Const Cdebug = 0 ' leave this to 0  
  

```vb
#if Cdebug  
Print Maxword  
Print Maxwordshift  

#endif  
  
'Dim the used variables  
Dim Bstatus As Byte , Bretries As Byte , Bblock As Byte , Bblocklocal As Byte  
Dim Bcsum1 As Byte , Bcsum2 As Byte , Buf(128) As Byte , Csum As Byte  
Dim J As Byte , Spmcrval As Byte ' self program command byte value  
Dim Z As Long 'this is the Z pointer word  
Dim Vl As Byte , Vh As Byte ' these bytes are used for the data values  
Dim Wrd As Word , Page As Word 'these vars contain the page and word address  
Dim Bkind As Byte , Bstarted As Byte  
'Mega 88 : 32 words, 128 pages  
  
  
  
Disable Interrupts 'we do not use ints  
'Waitms 100 'wait 100 msec sec  
'We start with receiving a file. The PC must send this binary file  
  
'some constants used in serial com  
```
Const Nak = &H15  
Const Ack = &H06  
Const Can = &H18  
  
```vb
'we use some leds as indication in this sample , you might want to remove it  
Config Pinb.2 = Output  
```
Portb.2 = 1 'the stk200 has inverted logic for the leds  
Config Pinb.3 = Output  
Portb.3 = 1  
  
```vb
$timeout = 400000 'we use a timeout  
'When you get LOADER errors during the upload, increase the timeout value  
'for example at 16 Mhz, use 200000  
  
```
Bretries = 5 'we try 5 times  
Testfor123:  

```vb
#if Cdebug  
Print "Try " ; Bretries  
Print "Wait"  

#endif  
```
Bstatus = Waitkey() 'wait for the loader to send a byte  

```vb
#if Cdebug  
Print "Got "  

#endif  
  
Print Chr(bstatus);  
  
If Bstatus = 123 Then 'did we received value 123 ?  
```
Bkind = 0 'normal flash loader  
Goto Loader  
Elseif Bstatus = 124 Then ' EEPROM  
Bkind = 1 ' EEPROM loader  
Goto Loader  
Elseif Bstatus <> 0 Then  
Decr Bretries  
```vb
If Bretries <> 0 Then Goto Testfor123 'we test again  
End If  
  
For J = 1 To 10 'this is a simple indication that we start the normal reset vector  
Toggle Portb.2 : Waitms 100  
Next  
  

#if Cdebug  
Print "RESET"  

#endif  
Goto _reset 'goto the normal reset vector at address 0  
  
  
'this is the loader routine. It is a Xmodem-checksum reception routine  
```
Loader:  

```vb
#if Cdebug  
Print "Clear buffer"  

#endif  
Do  
```
Bstatus = Waitkey()  
```vb
Loop Until Bstatus = 0  
  
For J = 1 To 3 his is a simple indication that we start the normal reset vector  
Toggle Portb.2 : Waitms 50  
Next  
  
If Bkind = 0 Then  
```
Spmcrval = 3 : Gosub Do_spm ' erase the first page  
Spmcrval = 17 : Gosub Do_spm ' re-enable page  
End If  
  
Bretries = 10 'number of retries  
  
Do  
Bstarted = 0 ' we were not started yet  
Csum = 0 'checksum is 0 when we start  
```vb
Print Chr(nak); ' first time send a nack  
Do  
```
Bstatus = Waitkey() 'wait for status byte  
  
```vb
Select Case Bstatus  
Case 1: ' start of heading, PC is ready to send  
```
Incr Bblocklocal 'increase local block count  
Csum = 1 'checksum is 1  
Bblock = Waitkey() : Csum = Csum + Bblock 'get block  
Bcsum1 = Waitkey() : Csum = Csum + Bcsum1 'get checksum first byte  
For J = 1 To 128 'get 128 bytes  
Buf(j) = Waitkey() : Csum = Csum + Buf(j)  
Next  
Bcsum2 = Waitkey() 'get second checksum byte  
```vb
If Bblocklocal = Bblock Then 'are the blocks the same?  
If Bcsum2 = Csum Then 'is the checksum the same?  
Gosub Writepage 'yes go write the page  
Print Chr(ack); 'acknowledge  
Else 'no match so send nak  
Print Chr(nak);  
End If  
Else  
Print Chr(nak); 'blocks do not match  
End If  
Case 4: ' end of transmission , file is transmitted  
If Wrd > 0 And Bkind = 0 Then 'if there was something left in the page  
```
Wrd = 0 'Z pointer needs wrd to be 0  
Spmcrval = 5 : Gosub Do_spm 'write page  
Spmcrval = 17 : Gosub Do_spm ' re-enable page  
```vb
End If  
' Waitms 100 ' OPTIONAL REMARK THIS IF THE DTR SIGNAL ARRIVES TO EARLY  
Print Chr(ack); ' send ack and ready  
```
Portb.3 = 0 ' simple indication that we are finished and ok  
```vb
Waitms 20  
Goto _reset ' start new program  
Case &H18: ' PC aborts transmission  
Goto _reset ' ready  
Case 123 : Exit Do 'was probably still in the buffer  
Case 124 : Exit Do  
Case Else  
Exit Do ' no valid data  
End Select  
Loop  
If Bretries > 0 Then 'attempte left?  
Waitms 1000  
```
Decr Bretries 'decrease attempts  
```vb
Else  
Goto _reset 'reset chip  
End If  
Loop  
  
'write one or more pages  
```
Writepage:  
```vb
If Bkind = 0 Then  
For J = 1 To 128 Step 2 'we write 2 bytes into a page  
```
Vl = Buf(j) : Vh = Buf(j + 1) 'get Low and High bytes  
! lds r0, {vl} 'store them into r0 and r1 registers  
! lds r1, {vh}

Spmcrval = 1 : Gosub Do_spm 'write value into page at word address  
Wrd = Wrd + 2 ' word address increases with 2 because LS bit of Z is not used  
If Wrd = Maxword Then ' page is full  
Wrd = 0 'Z pointer needs wrd to be 0  
Spmcrval = 5 : Gosub Do_spm 'write page  
Spmcrval = 17 : Gosub Do_spm ' re-enable page  
  
Page = Page + 1 'next page  
Spmcrval = 3 : Gosub Do_spm ' erase next page  
Spmcrval = 17 : Gosub Do_spm ' re-enable page  
```vb
End If  
Next  
  
Else 'eeprom  
For J = 1 To 128  
```
Writeeeprom Buf(j) , Wrd  
Wrd = Wrd + 1  
```vb
Next  
End If  
Toggle Portb.2 : Waitms 10 : Toggle Portb.2 'indication that we write  
Return  
  
  
```
Do_spm:  
Bitwait Spmcsr.0 , Reset ' check for previous SPM complete  
Bitwait Eecr.1 , Reset 'wait for eeprom  
  
Z = Page 'make equal to page  
Shift Z , Left , Maxwordshift 'shift to proper place  
Z = Z + Wrd 'add word  
! lds r30,{Z}  
! lds r31,{Z+1}  
  

#if _romsize > 65536  
! lds r24,{Z+2}  
! sts rampz,r24 ' we need to set rampz also for the M128  

#endif  
  
Spmcsr = Spmcrval 'assign register  
! spm 'this is an asm instruction  
! nop  
! nop  
```vb
Return  
  
  
'How you need to use this program:  
'1- compile this program  
'2- program into chip with sample elctronics programmer  
'3- select MCS Bootloader from programmers  
'4- compile a new program for example M88.bas  
'5- press F4 and reset your micro  
' the program will now be uploaded into the chip with Xmodem Checksum  
' you can write your own loader.too  
'A stand alone command line loader is also available  
  
'How to call the bootloader from your program without a reset ???  
'Do  
' Print "test"  
' Waitms 1000  
' If Inkey() = 27 Then  
' Print "boot"  
' Goto &H1C00  
' End If  
'Loop  
  
'The GOTO will do the work, you need to specify the correct bootloader address  
'this is the same as the $LOADER statement.

```
ATXMEGA Example:

![notice](notice.jpg)NOTICE that there are many Xmega processors and the page size differs.

The example is for the xmega32A4 which uses MAXWORDBIT=7 

Other chips require a different value. See the table after the example.

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' BootloaderXmega32A4.bas  
' This sample demonstrates how you can write your own bootloader  
' in BASCOM BASIC for the XMEGA  
'-----------------------------------------------------------------  
'The loader is supported from the IDE  
$crystal = 32000000 ' xmega128 is running on 32 MHz  
$regfile = "xm32a4def.dat"  
$lib "xmega.lib" ' add a reference to this lib  
  
'first enabled the osc of your choice  
Config Osc = Disabled , 32mhzosc = Enabled 'internal 2 MHz and 32 MHz enabled  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1 ' we will use 32 MHz and divide by 1 to end up with 32 MHz  
  
$loader = &H4000 ' bootloader starts after the application  
  
Config Com1 = 57600 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8 ' use USART C0  
'COM0-USARTC0, COM1-USARTC2, COM2-USARTD0. etc.  
Config Portc.3 = Output 'define TX as output  
Config Pinc.2 = Input  
  
```
Const Maxwordbit = 7 ' Z7 is maximum bit '  
Const Maxword =(2 ^ Maxwordbit) * 2 '128  
Const Maxwordshift = Maxwordbit + 1  
Const Cdebug = 0 ' leave this to 0  
  
```vb
'Dim the used variables  
Dim Bstatus As Byte , Bretries As Byte , Bmincount As Byte , Bblock As Byte , Bblocklocal As Byte  
Dim Bcsum1 As Byte , Bcsum2 As Byte , Buf(128) As Byte , Csum As Byte  
Dim J As Byte , Spmcrval As Byte ' self program command byte value  
Dim Z As Long 'this is the Z pointer word  
Dim Vl As Byte , Vh As Byte ' these bytes are used for the data values  
Dim Wrd As Word , Page As Word 'these vars contain the page and word address  
  
Disable Interrupts 'we do not use ints  
  
'We start with receiving a file. The PC must send this binary file  
  
'some constants used in serial com  
```
Const Nak = &H15  
Const Ack = &H06  
Const Can = &H18  
  
```vb
$timeout = 300000 'we use a timeout  
'When you get LOADER errors during the upload, increase the timeout value  
'for example at 16 Mhz, use 200000  
  
```
Bretries = 5 : Bmincount = 3 'we try 10 times and want to get 123 at least 3 times  
Do  
Bstatus = Waitkey() 'wait for the loader to send a byte  
  
```vb
If Bstatus = 123 Then 'did we received value 123 ?  
If Bmincount > 0 Then  
```
Decr Bmincount  
```vb
Else  
Print Chr(bstatus);  
Goto Loader ' yes so run bootloader  
End If  
Else 'we received some other data  
If Bretries > 0 Then 'retries left?  
```
Bmincount = 3  
Decr Bretries  
Else  
Rampz = 0  
```vb
Goto Proces_reset 'goto the normal reset vector at address 0  
End If  
End If  
Loop  
  
'this is the loader routine. It is a Xmodem-checksum reception routine  
```
Loader:  
Do  
Bstatus = Waitkey()  
Loop Until Bstatus = 0  
  
Spmcrval = &H20 : Gosub Do_spm ' erase all app pages  
  
  
Bretries = 10 'number of retries  
  
Do  
Csum = 0 'checksum is 0 when we start  
```vb
Print Chr(nak); ' first time send a nack  
Do  
  
```
Bstatus = Waitkey() 'wait for status byte  
  
```vb
Select Case Bstatus  
Case 1: ' start of heading, PC is ready to send  
```
Incr Bblocklocal 'increase local block count  
Csum = 1 'checksum is 1  
Bblock = Waitkey() : Csum = Csum + Bblock 'get block  
Bcsum1 = Waitkey() : Csum = Csum + Bcsum1 'get checksum first byte  
For J = 1 To 128 'get 128 bytes  
Buf(j) = Waitkey() : Csum = Csum + Buf(j)  
Next  
Bcsum2 = Waitkey() 'get second checksum byte  
  
```vb
If Bblocklocal = Bblock Then 'are the blocks the same?  
  
If Bcsum2 = Csum Then 'is the checksum the same?  
Gosub Writepage 'yes go write the page  
Print Chr(ack); 'acknowledge  
Else 'no match so send nak  
Print Chr(nak);  
End If  
Else  
Print Chr(nak); 'blocks do not match  
End If  
Case 4: ' end of transmission , file is transmitted  
If Wrd > 0 Then 'if there was something left in the page  
```
Wrd = 0 'Z pointer needs wrd to be 0  
Spmcrval = &H24 : Gosub Do_spm 'write page  
```vb
End If  
Print Chr(ack); ' send ack and ready  
Waitms 20  
Goto Proces_reset  
Case &H18: ' PC aborts transmission  
Goto Proces_reset ' ready  
Case 123 : Exit Do 'was probably still in the buffer  
Case 124 : Exit Do  
Case Else  
Exit Do ' no valid data  
End Select  
Loop  
If Bretries > 0 Then 'attempts left?  
Waitms 1000  
```
Decr Bretries 'decrease attempts  
```vb
Else  
Goto Proces_reset 'reset chip  
End If  
Loop  
  
'write one or more pages  
```
Writepage:  
For J = 1 To 128 Step 2 'we write 2 bytes into a page  
Vl = Buf(j) : Vh = Buf(j + 1) 'get Low and High bytes  
! lds r0, {vl} 'store them into r0 and r1 registers  
! lds r1, {vh}  
Spmcrval = &H23 : Gosub Do_spm 'write value into page at word address  
Wrd = Wrd + 2 ' word address increases with 2 because LS bit of Z is not used  
If Wrd = Maxword Then ' page is full  
Wrd = 0 'Z pointer needs wrd to be 0  
Spmcrval = &H24 : Gosub Do_spm 'write page  
Page = Page + 1 'next page  
```vb
End If  
Next  
Return  
  
```
Do_spm:  
Z = Page 'make equal to page  
Shift Z , Left , Maxwordshift 'shift to proper place  
Z = Z + Wrd 'add word  
! lds r30,{Z}  
! lds r31,{Z+1}  
  

#if _romsize > 65536  
! lds r24,{Z+2}  
! sts rampz,r24 ' we need to set rampz also for the M128  

#endif  
  
Nvm_cmd = Spmcrval  
Cpu_ccp = &H9D  
! spm 'this is an asm instruction  
Do_spm_busy:  
! lds r23, NVM_STATUS  
! sbrc r23,7 ;if busy bit is cleared skip next instruc tion  
! rjmp do_spm_busy  
Return  
  
Proces_reset:  
Rampz = 0  
Goto _reset 'start at address 0  
  


PAGE SIZE 

Processor | Pagesize | Maxwordbit  
---|---|---  
ATxmega128A1 | 512 | 8  
ATxmega128A1U | 512 | 8  
ATxmega128A3 | 512 | 8  
ATxmega128A3U | 512 | 8  
ATxmega128A4U | 256 | 7  
ATxmega128B1 | 256 | 7  
ATxmega128B3 | 256 | 7  
ATxmega128C3 | 512 | 8  
ATxmega128D3 | 512 | 8  
ATxmega128D4 | 256 | 7  
ATxmega16A4 | 256 | 7  
ATxmega16A4U | 256 | 7  
ATxmega16C4 | 256 | 7  
ATxmega16D4 | 256 | 7  
ATxmega16E5 | 128 | 6  
ATxmega192A3 | 512 | 8  
ATxmega192A3U | 512 | 8  
ATxmega192C3 | 512 | 8  
ATxmega192D3 | 512 | 8  
ATxmega256A3 | 512 | 8  
ATxmega256A3B | 512 | 8  
ATxmega256A3BU | 512 | 8  
ATxmega256A3U | 512 | 8  
ATxmega256C3 | 512 | 8  
ATxmega256D3 | 512 | 8  
ATxmega32A4 | 256 | 7  
ATxmega32A4U | 256 | 7  
ATxmega32C3 | 256 | 7  
ATxmega32C4 | 256 | 7  
ATxmega32D3 | 256 | 7  
ATxmega32D4 | 256 | 7  
ATxmega32E5 | 128 | 6  
ATxmega384C3 | 512 | 8  
ATxmega384D3 | 512 | 8  
ATxmega64A1 | 256 | 7  
ATxmega64A1U | 256 | 7  
ATxmega64A3 | 256 | 7  
ATxmega64A3U | 256 | 7  
ATxmega64A4U | 256 | 7  
ATxmega64B1 | 256 | 7  
ATxmega64B3 | 256 | 7  
ATxmega64C3 | 256 | 7  
ATxmega64D3 | 256 | 7  
ATxmega64D4 | 256 | 7  
ATxmega8E5 | 128 | 6

---

## $LOADERSIZE

Action

Instruct the compiler that a boot loader is used so it will not overwrite the boot space.

Syntax

$LOADERSIZE = size

Remarks

size | The amount of space in bytes that is used by the boot loader.  
---|---  
  
When you use a boot loader it will use space from the available flash memory. The compiler does not know if you use a boot loader or not. It also does not know how you have set the fuse bits, so it is impossible to know how big the bootloader size is. When your program exceeds the available space and runs into the boot sector space, it will overwrite the boot loader.

The $loadersize directive will take the boot loader size into account so you will get an error when the target file gets too big.

When you select the MCS boot loader as programmer the IDE also will take into account the specified boot loader size.

The directive can be used when you have a different programmer selected. For example an external programmer that does not know about the boot size.

![notice](notice.jpg)Do not use this directive in the bootloader program itself. You will get an error 344 in that case. $LOADERSIZE is only intended to be used in normal applications. 

See also

[$LOADER](loader.md) , [$BOOT](_boot.md)

ASM

NONE

Example

NONE

---

## $NOCOMPILE

Action

Instruct the compiler not to compile the file.

Syntax

$NOCOMPILE

Remarks

This looks like an odd directive. Since you can split your program in multiple files, and you can create configuration files, you might open a file and try to compile it. Only normal project files can be compiled and you will get a number of errors and also unwanted files like error, report, etc.

To prevent that you compile a file that is intended to be included, you can insert the $NOCOMPILE directive.

Then the file will only be compiled when it is called from your main file, or other include file.

A file that is opened as thus the main file, and which includes the $NOCOMP directive, can not be compiled.

The IDE will see it as a successful compilation. This is important for the Batch Compiler.

See also

[Batch Compiler](toolsbatchcompile.md)

Example

$NOCOMPILE

---

## $NOFRAMEPROTECT

Action

This directive will disable interrupt frame protection.

Syntax

$NOFRAMEPROTECT

Remarks

See the new preferred switch : [$FRAMEPROTECT](frameprotect.md)

See also

[$FRAMEPROTECT](frameprotect.md)

Example

NONE

---

## $NORAMPZ

Action

This compiler directive disables RAMPZ clearing.

Syntax

$NORAMPZ

Remarks

Processors with more then 64 KB of memory need to set the RAMPZ register in order to point to the proper 64 KB page. 

If the RAMPZ register is used, it will be cleared when it is used for something different then accessing the flash.

BASCOM uses the Z register to access flash memory or RAM memory. Since processors with external memory capability can access more then 64KB of RAM, the RAMPZ must be set/cleared when accessing this memory.

Otherwise accessing the flash code could result in a change of RAMPZ, and after this, accessing the RAM would not point to the proper place in memory.

But setting this register requires extra code. When your application just fitted into a M128 or M256 and you do not want this RAMPZ handling because your application works fine, then you can use this $NORAMPZ directive.

To see if your processor 

See also

NONE

Example

NONE

---

## $NOTRANSFORM

Action  
  
This option controls transformation of unsupported ASM mnemonics.

Syntax

$NOTRANSFORM ON|OFF

Remarks

By default, assembler mnemonics that are not supported for a chip or register are transformed into different assembler mnemonics.

The IN and OUT instructions for example only work on hardware registers with an address lower then 64. Most PORT registers are located in this lower address space, but there are many chips that have more ports which are located in extended memory. For such chips, using a IN or OUT on an extended address would result in a failure. 

Thus the compiler changes IN into an LDS and an OUT into an STS. When a register is required, R23 will be used except for SBIS/SBIC, these instructions use R0 when required.

When you develop some ASM code, you might want to get an error when you are using an instruction the wrong way. For this purpose you can turn off the transformation.

$NOTRANSFORM ON will turn off the transformation. And with $NOTRANSFORM OFF you can turn it back on.

You should only use this option in your own code. When you use it on your whole program, it will not compile since the bascom libraries which use CBI, SBI, SBIS, IN, OUT, etc. will use the transformation. 

See also

NONE

Example

NONE

---

## $NOTYPECHECK

Action

This directive will turn off type checking

Syntax

$NOTYPECHECK

Remarks

Type checking is performed on some operations. It is turned on by default. With the $NOTYPECHECK you can turn this feature off.

See also

[$TYPECHECK](typecheck.md)

Example

NONE

---

## $PROGRAMMER

Action

Will set the programmer from the source code.

Syntax

```vb
$PROGRAMMER = number [,"COMx"] 

$PROGRAMMER = number [,"serial"] 

```
Remarks

Number | A numeric constant that identifies the programmer.   
---|---  
COMx | An optional parameter in double quotes that specifies the COM port to use. Future versions might offer additional options. Example : "COM3"  
serial | For MCSEDBG this can be the product name with serial number. Use this when you have multiple programmers connected.  
  
The $PROGRAMMER directive requires that you set the option 'Use New Method' in Options, Environment, IDE.

The $PROGRAMMER directive will set the programmer just before it starts programming.

When you press F4 to program a chip, the selected programmer will be made active. This is convenient when you have different projects open and use different programmers.

But it can also lead to frustration as you might think that you have the 'STK200' selected, and the directive will set it to USB-ISP.

The following values can be used :

Value | Programmer  
---|---  
0 | AVR-ISP programmer(old AN 910) *  
1 | STK200/STK300 *  
2 | PG302 *  
3 | External programmer  
4 | Sample Electronics *  
5 | Eddie Mc Mullen *  
6 | KITSRUS K122 *  
7 | STK500  
8 | Universal MCS Interface *  
9 | STK500 extended  
10 | Lawicel Bootloader *  
11 | MCS USB  
12 | USB-ISP I *  
13 | MCS Bootloader  
14 | Proggy *  
15 | FLIP (Atmel)  
16 | USBprog Programmer/ AVR ISP mkII (Atmel)  
17 | Kamprog for AVR  
18 | MyAVR MKII/AVR910  
19 | USBASP  
20 | JTAG MKII  
21 | STK600  
22 | ARDUINO (using stk500v1 protocol)  
23 | ARDUINO V2 (using stk500v2 protocol)  
24 | MINI-MAX/AVR-C (BIPOM)  
25 | mySmart USB light STK500 mode  
26 | MSC UPDI programmer  
27 | MCS EDBG programmer  
  
* - not recommended for purchase/use

The file prog.inc in the \INC subfolder contains constants for all programmers.

We recommend to use the constant since it is more clear which programmer is used.

An additional parameter can be used to specify the COM port to use. Like : $PROGRAMMER 26, "COM45"

Notice that there is no double point after the COM port number.

```vb
For the MCS EDBG programmer you can specify an optional product name with serial number. 

For example : 

$programmer = prgMCSEDBG,"mEDBG CMSIS-DAP:SNAP"

```
See also

[$PROG](_prog.md)

ASM

NONE

Example

```vb
$regfile = "AVRX64EA28.dat"  
$crystal = 20000000  
$hwstack = 64  
$swstack = 64  
$framesize = 64

  
$programmer = Prgmcsedbg , "nEDBG CMSIS-DAP:MC020059804RYN000236"  
' use MCS EDBG programmer. The USB product name is nEDBG CMSIS-DAP and the serial is MC020059804RYN000236

```

---

## $REDUCEIVR

Action

This directive will inform the compiler to reduce the IVR (interrupt vector table) to the smallest possible size.

Syntax

$REDUCEIVR

Remarks

The flash memory of the processor always starts with the IVR (interrupt vector table). The user code is placed after this table.

So what is this IVR ?

This table contains an address for each interrupt. When an interrupt occurs, the processor will jump to a specific and fixed address in code memory.

The address depends on the interrupt itself, and on the processor. For example the MEGA88 has 25 interrupt sources. You can find them in the dat file :

INTname1=INT0,$001,EIMSK.INT0,EIFR.INTF0

INTname2=INT1,$002,EIMSK.INT1,EIFR.INTF1

INTname3=PCINT0,$003,PCICR.PCIE0,PCIFR.PCIF0

INTname4=PCINT1,$004,PCICR.PCIE1,PCIFR.PCIF1

INTname5=PCINT2,$005,PCICR.PCIE2,PCIFR.PCIF2

INTname6=WDT@WATCHDOG,$006,WDTCSR.WDIE,WDTCSR.WDIF

INTname7=OC2A@COMPARE2A,$007,TIMSK2.OCIE2A,TIFR2.OCF2A

INTname8=OC2B@COMPARE2B,$008,TIMSK2.OCIE2B,TIFR2.OCF2B

INTname9=OVF2@TIMER2,$009,TIMSK2.TOIE2,TIFR2.TOV2

INTname10=ICP1@CAPTURE1,$00A,TIMSK1.TICIE1,TIFR1.ICF1

INTname11=OC1A@COMPARE1A,$00B,TIMSK1.OCIE1A,TIFR1.OCF1A

INTname12=OC1B@COMPARE1B,$00C,TIMSK1.OCIE1B,TIFR1.OCF1B

INTname13=OVF1@TIMER1,$00D,TIMSK1.TOIE1,TIFR1.TOV1

INTname14=OC0A@COMPARE0A,$00E,TIMSK0.OCIE0A,TIFR0.OCF0A

INTname15=OC0B@COMPARE0B,$00F,TIMSK0.OCIE0B,TIFR0.OCF0B

INTname16=OVF0@TIMER0,$010,TIMSK0.TOIE0,TIFR0.TOV0

INTname17=SPI,$011,SPCR.SPIE,SPSR.SPIF

INTname18=URXC@SERIAL,$012,UCSR0B.RXCIE0,UCSR0A.RXC0

INTname19=UDRE,$013,UCSR0B.UDRIE0,UCSR0A.UDRE0

INTname20=UTXC,$014,UCSR0B.TXCIE0,UCSR0A.TXC0

INTname21=ADCC@ADC,$015,ADCSRA.ADIE,ADCSRA.ADIF

INTname22=ERDY,$016,EECR.EERIE

INTname23=ACI,$017,ACSR.ACIE,ACSR.ACI

INTname24=TWI,$018,TWCR.TWIE,TWCR.TWINT

INTname25=SPM,$019,SPMCSR.SPMIE

You can see that INT0 comes first. And that the address is $001 which is &H0001. So when INT0 occurs, the processor will jump to address 1.

When you did not define an ISR (ON INT0) , the compiler will insert a RETI instruction. So nothing bad will happen to your code.

When you did define an ISR , the compiler will insert a JUMP to your interrupt routine. When your interrupt ends, the RETI will let the processor continue where it was when the interrupt occurred.

In the example when we only use the ISR with the lowest address all other addresses in the table would get a RETI instruction. And the user code could start at &H1A (one address after $19). 

Now that is not so bad but there are also processors with bigger tables and with tables that require 2 words for a JUMP. You waste a lot of space this way.

So what does $REDUCEIVR do? It will determine which interrupt you have used has the highest address. And it will use the address after that as the user code start.

This means that if we use only INT0 and we use $REDUCEIVR, the user code will start at address &H2 ($2). So you will save a lot of code space this way.

Ok so why isn't this enabled by default? There is a catch : when your code has an interrupt enabled and there is no matching ON <INT> the processor will jump into the user code and this will create a crash almost for sure.

So our advise : use this when you understand what this option does, and use it when your application is finished. In any case, retest the complete application when the option is enabled.

See also

[$LOADER](loader.md) , [CONFIG INTVECTORSELECTION](config_intvectorselection.md) , [$BOOTVECTOR](bootvector.md)

Example

$REDUCEIVR

---

## $REGFILE

Action

Instruct the compiler to use the specified register file instead of the selected dat file.

Syntax

$REGFILE = "name"

Remarks

Name | The name of the register file. The register files are stored in the BASCOM-AVR application directory and they all have the DAT extension. The register file holds information about the chip such as the internal registers and interrupt addresses. The register file info is derived from atmel definition files.  
---|---  
  
The $REGFILE statement overrides the setting from the Options, Compiler, Chip menu.

The settings are stored in a <project>.CFG file.

The $REGFILE directive must be the first statement in your program. It may not be put into an included file since only the main source file is checked for the $REGFILE directive.

![notice](notice.jpg) It is good practice to use the $REGFILE directive. It has the advantage that you can see in the source which chip it was written for. The $REGFILE directive is also needed when the [PinOut](viewpinout.md) viewer or the [PDF](viewpdfviewer.md) viewer is used.

The register files contain the hardware register names from the micro. They also contain the bit names. These are constants that you may use in your program. But the names can not be used to dim a variable for example.

Example :

DIM PORTA As Byte

This will not work since PORTA is a register constant.

See also

[$SWSTACK](_swstack.md) , [$HWSTACK](_hwstack.md) , [$FRAMESIZE](_framesize.md), [Memory usage](memory_usage.md)

ASM

NONE

Example

$REGFILE = "8515DEF.DAT"

---

## $RESOURCE

Action

Instruct the compiler to use a special resource file for multi language support.

Syntax

```vb
$RESOURCE [DUMP] "lang1" [, "lang2"]

$RESOURCE ON | OFF

```
Remarks

lang1 | This is the name of the first and default language. You can add a maximum of 8 languages. The names will be used in the resource editor. But they are only intended as a reference. The resource names will not end up in your application. They are used for the column names in the resource editor.  
---|---  
lang2 | The second language. You can add multiple languages separated by a comma. The language must be specified within double quotes.  
ON | This will turn on the languages resource handling. In some cases you need to turn the language handling ON or OFF which is explained later  
OFF | This will turn OFF the language handling  
DUMP | This mode will create a <project>.BCS file which contains all used string constants  
  
Some applications require that the interface is available in multiple languages. You write your application the same way as you always do. 

When it is ready, you can add the $RESOURCE directive to make the application suited for multiple languages. 

The $RESOURCE option will generate a BYTE variable named LANGUAGE. You can change the value in your application. The compiler will take care that the proper string is shown.

But first you need to translate the strings into the languages of your choice.

For this purpose you can use the Resource Editor. The [Resource Editor](tools_resource_editor.md) can import a BCS file (BASCOM String file) which contains the languages and the strings.

You can then add a string for all languages.

So first make sure your application works. Then compile using the $RESOURCE DUMP option.

When you test the languages.bas sample the content will look like this :

"English" , "Dutch" , "German" , "Italian"

"Multi language test"

"This"

" is a test"

"Name "

"Hello "

As you can see, the first line contains the languages. The other lines only contain a string. Each string is only stored once in BASCOM. So even while "Mark" can have multiple meanings, it will only end up once in the BCS file. 

After you have translated the strings, the content of the BCR (BASCOM Resource) file will look like :

"English","Dutch","German","Italian"

"This","Dit","Dies","Questo"

"Name ","Naam","Name","Nome"

"Multi language test","Meertalen test","","Test multilingua"

"Hello ","Hallo","Hallo","Ciao"

" is a test"," is een test","ist ein test","Ã¨ un test"

"mark","Mark","Marcus","Marco"

You may edit this file yourself, using Notepad or you can use the Resource Editor. Untranslated strings will be stored as "". Untranslated strings will be shown in the original language !

Now recompile your project and the compiler will handle every string it will find in the resource file (BCR) in a special way. Strings that are not found in the BCR file, are not processed and handled like normal. For example when you have a PRINT "check this out" , and you did not put that in the BCR file, it will show the same no matter which value the LANGUAGE variable has.

But for each string found in the BCR file, the compiler will show the string depending on the LANGUAGE variable. When one of the languages is not translated, it will show as the original language. 

When LANGUAGE is 0, it will show the first string (the string from the first column). When languages is 1, it will show the string from the second column, and so on.

You must take care that the LANGUAGE variables has a valid value. 

So by switching/changing 1 variable, you can change the language in the entire application. Strings are used for PRINT, LCD and other commands. It will work on every string that is in the BCR file. But that also brings us to the next option.

Image this code :

```vb
If S = "mark" Then

Print "we can not change names"

End If

```
As you can see, we use a string. The code will fail if the string is translated (and is different in each language). You can simply remove the this string from the Resource file. But when you also need the word "mark" in the interface, you have a problem. For this purpose you can turn off the resource handling using $RESOURCE OFF

The compiler will then not process the code following the directive with the special resource handling.

And when you are done, you can turn the resource handling on again using $RESOURCE ON.

See also

[Resource Editor](tools_resource_editor.md)

Example

```vb
'------------------------------------------------------------------------------

' language.bas

' (c) 1995-2025 , MCS Electronics

'This example will only work with the resource add on

'resources are only needed for multi language applications

'By changing the LANGUAGE variable all strings used will be shown in the proper language

'------------------------------------------------------------------------------

$regfile = "m88def.dat"

$crystal = 8000000

$baud = 19200

'a few steps are needed to create a multi language application

'STEP 1, make your program as usual

'STEP 2, generate a file with all string resources using the $RESOURCE DUMP directive

'$resource Dump , "English" , "Dutch" , "German" , "Italian" 'we will use 4 languages

'STEP 3, compile and you will find a file with the BCS extesion

'STEP 4, use Tools, Resource Editor and inport the resources

'STEP 5, add languages, translate the original strings

'STEP 6, compile your program this time with specifying the languages without the DUMP option

$resource "English" , "Dutch" , "German" , "Italian"

'this must be done before you use any other resource !

'in this sample 4 languages are used

'this because all resources found are looked up in the BCR file(BasCom Resource)

Dim S As String * 20

Dim B As Byte

Print "Multi language test"

Do

Print "This" ;

```
S = " is a test" : Print S

```vb
Input "Name " , S

Print "Hello " ; S

'now something to look out for !

'all string data not found in the BCR file is not resourced. so there is no problem with the following:

If S = "mark" Then

Print "we can not change names"

End If

'but if you want to have "mark" resourced for another sentence you have a problem.

'the solution is to turn off resourcing

$resource Off

Print "mark"

If S = "mark" Then

Print "we can not change names"

End If

$resource On

```
Language = Language + 1

```vb
If Language > 3 Then Language = 0

Loop

```

---

## $SERIALINPUT

Action

Specifies that serial input must be redirected.

Syntax

$SERIALINPUT = label

Remarks

Label | The name of the assembler routine that must be called when a character is needed by the INPUT routine. The character must be returned in R24.  
---|---  
  
With the redirection of the INPUT command, you can use your own input routines.

This way you can use other devices as input devices.

Note that the INPUT statement is terminated when a RETURN code (13) is received.

By default when you use INPUT or INKEY(), the compiler will expect data from the COM port. When you want to use a keyboard or remote control as the input device you can write a custom routine that puts the data into register R24 once it needs this data.

See also

[$SERIALOUTPUT](serialoutput.md)

Example

```vb
'--------------------------------------------------------------------------------

'name : $serialinput.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates $SERIALINPUT redirection of serial input

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'--------------------------------------------------------------------------------

$regfile = "m48def.dat"

'define used crystal

$crystal = 4000000

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 'default use 10 for the SW stack

$framesize = 40 'default use 40 for the frame space

'dimension used variables

Dim S As String * 10

Dim W As Long

'inform the compiler which routine must be called to get serial characters

$serialinput = Myinput

'make a never ending loop

Do

'ask for name

Input "name " , S

Print S

'error is set on time out

Print "Error " ; Err

Loop

End

'custom character handling routine

'instead of saving and restoring only the used registers

'and write full ASM code, we use Pushall and PopAll to save and restore

'all registers so we can use all BASIC statements

'$SERIALINPUT requires that the character is passed back in R24

```
Myinput:

Pushall 'save all registers

W = 0 'reset counter

Myinput1:

Incr W 'increase counter

! Sbis USR, 7 ' Wait for character

! Rjmp myinput2 'no charac waiting so check again

Popall 'we got something

Err = 0 'reset error

! In _temp1, UDR ' Read character from UART

Return 'end of routine

Myinput2:

If W > 1000000 Then 'with 4 MHz ca 10 sec delay

! rjmp Myinput_exit 'waited too long

```vb
Else

Goto Myinput1 'try again

End If

```
Myinput_exit:

Popall 'restore registers

Err = 1 'set error variable

! ldi R24, 13 'fake enter so INPUT will end

Return

---

## $SERIALOUTPUT

Action

Specifies that serial output must be redirected.

Syntax

$SERIALOUTPUT = label

Remarks

Label | The name of the assembler routine that must be called when a character is send to the serial buffer (UDR). The character is placed into R24.  
---|---  
  
With the redirection of the PRINT and other serial output related commands, you can use your own routines.

This way you can use other devices as output devices.

See also

[$SERIALINPUT](serialinput.md) , [$SERIALINPUT2LCD](serialinput2lcd.md) , [$SERIALINPUT1](_serialinput1.md) , [$SERIALOUTPUT1](_serialoutput1.md)

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

$serialoutput = Myoutput

'your program goes here

Do

Print "Hello"

Loop

End

```
myoutput:

```vb
'perform the needed actions here

'the data arrives in R24

'just set the output to PORTB

```
!outportb,r24

!ret

---

## $SIM

Action

Instructs the compiler to generate empty wait loops for the WAIT and WAITMS statements. This to allow faster simulation.

Syntax

$SIM

Remarks

Simulation of a WAIT statement can take a long time especially when memory view windows are opened.

The $SIM compiler directive instructs the compiler to not generate code for WAITMS and WAIT. This will of course allows faster simulation.

When your application is ready you must remark the $SIM directive or otherwise the WAIT and WAITMS statements will not work as expected.

When you forget to remove the $SIM option and you try to program a chip you will receive a warning that $SIM was used.

See also

NONE

ASM

NONE

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

$sim

Do

Wait 1

Print "Hello"

Loop

```

---

## $STACKDUMP

Action

Makes the compiler hook up the reset vector and includes code, which allows to get a dump of the stack residing in SRAM.

Syntax

$stackdump

Preface

Using $stackdump presumes certain knowledge of assembler code, i.e. reading and understanding disassembled code. On the other hand it's possible that an user, who has little to no experience in assembly reading, simply uses $stackdump, while an assembly-experienced user evaluates the dumped result. This allows sharing of experience, knowledge and active debugging of difficult code via Internet, without having actual hardware available.

Remarks

Additional code in Bascom-Basic is used to put out the content of the saved stack to whatever target, in the provided example code the dump is written to the serial interface, however any other reasonable target for receiving the dump is feasible. For example, a dump can be saved to EEProm also, the user is free to modify the target himself.

Function

After each reset an AVR micrcontroller executes the reset-vector, the $stackdump code hooks this vector and executes a small routine, which saves a certain amount of stack to a protected memory range. This is possible, as SRAM memory keeps its content even after a reset. After saving the stack, a routine is executed which clears SRAM, excluding the previously saved range. In the following it's save to put out the saved stack content by

regular Bascom code. Without $stackdump this can't be done, as a) the stack would be destroyed by normal SRam-clearing code, and b) because every Bascom-code modifies, i.e overwrite the stack itself.

Usage

Stack can contain two types of data, 1) data, i.e. saved registers and 2) return addresses, which were pushed on

the stack by previous calls. The most interesting is the latter, as it can point to faulty code. If followed these

return addresses (which of course needs also some guesswork to distinguish it apart from saved registers), it's

possible to find out interrupting code, and this way difficult to find bugs.

Options

Depending whether the stack pointer is intact at reset, one of the two options can be used:

Ignore_SP = 1

Ignore_SP = 0

If a hard-rest occurs, for example by a watchdog reset, the stack pointer is reset to its default values, and this way can't be used to determine the stack pointers last position. For this case Ignore_SP = 1 is useful.

In this mode the amount of bytes given by Stck_siz_sav beginning from stack end is saved. This can be used for tracking down randomly occurring resets by whatever reasons. Be aware that without knowing the stack pointers last position, it's much harder to find out the last executed call, but it's still possible.

In contrary, if a soft reset occurs, the stack pointer is likely intact and the the option Ignore_SP = 0 is useful.

Here the stack is saved from the stack pointers last position to the amount of Stck_siz_sav bytes till ramend/stack-end. In case ram-end comes first, only the stack range between stack pointer and ram-end is saved.

The method using Ignore_SP = 0 is useful to redirect any interrupt to the reset vector by writing:

```vb
On interrupt_xy my_isr NOSAVE

Enable interrupt_xy

Enable Interrupts

'...

```
my_isr:

!jmp 0

```vb
return

If using an external interrupt, for example INT0 for my_isr, a signal on INT0 will create the stack dump, pointing to code executed at occurrence of the signal. This works like an on-chip hardware debugger. In certain chips a watchdog timer interrupt is available, this interrupt can be used and a watchdog timeout will then create a dump.

```
Notice: Previous mentioned functionality for Ignore_SP = 0 needs enabled interrupts. In case these special, or also global interrupts get disabled by code, it will fail. But also a disabled interrupt can point to the source of a bug. Using Ignore_SP = 1 will work in any case, but with said restrictions.

Closing note

$stackdump can only increase the chance to trap down a nasty bug or do some special type debugging. It's for sure no cure-all type of tool. Because of certain restrictions given by AVR hardware it can't be universal.

---

## $TYPECHECK

Action

This directive will turn on type checking

Syntax

$TYPECHECK

Remarks

Type checking is performed on some operations. It is turned on by default. With the $NOTYPECHECK you can turn this feature off. And with $TYPECHECK you can turn it on again.

See also

[$NOTYPECHECK](notypecheck.md)

Example

NONE

---

## $USER

Action

This directive will let the compiler create an .usr file that contains the data following this directive. Switch back to normal DATA statements with $DATA

Syntax

$USER

Remarks

Some new UPDI processors have a large User Signature data area. While smaller User Signature areas can be changed by the UPDI programmer, it is not practical when the size is larger than 64 bytes.

The MCS EDBG programmer has a new TAB : User Signature where you can change data similar as the EEPROM TAB. 

You can create an .USR file using the $USER directive followed by DATA statements. Switch back to normal Flash DATA using $DATA, the default. 

The file the compiler creates is a binary file. The MCS EDBG programmer will load the data automatically when it exists.

See also

[READUSERSIG](readusersig.md) , [$DATA](data_2.md) , [DATA](data_1.md)

Partial Example

  
```vb
'create .usr data file  
$user  
```
Data 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16  
```vb
' ^ address 0  
'switch back to normal DATA lines  
$data  
```
Data 10 , 20

---

## $XA

Action

Compiler directive to activate external memory access.

![notice](notice.jpg)[CONFIG XRAM ](configxram.md)should be used instead.

Syntax

$XA

Remarks

The $XA directive can be used to override the Compiler Chip Options setting.

This way you can store the setting in your program code. It is strongly advised to do this.

See also

[$WAITSTATE](_waitstate.md) , [CONFIG XRAM](configxram.md)

Example

$XA

---

## $XRAMSIZE

Action

Specifies the size of the external RAM memory.

Syntax

$XRAMSIZE = [&H] size

Remarks

Size | A constant with the size of the external RAM memory chip.  
---|---  
  
The size of the chip can be selected from the [Options Compiler Chip](options_compiler_chip.md) menu.

The $XRAMSIZE overrides this setting. It is important that $XRAMSTART precedes $XRAMSIZE

See also

[$XRAMSTART](xramstart.md) , [CONFIG XRAM](configxram.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : m128.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrate using $XRAM directive

'micro : Mega128

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m128def.dat" ' specify the used micro

$crystal = 1000000 ' used crystal frequency

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$xramstart = &H1000

$xramsize = &H1000

Dim X As X

```

---

## $XRAMSTART

Action

Specifies the location of the external RAM memory.

Syntax

$XRAMSTART = [&H]address

Remarks

Address | The (hex)-address where the data is stored. Or the lowest address that enables the RAM chip. You can use this option when you want to run your code in systems with external RAM memory. Address must be a constant.  
---|---  
  
By default the extended RAM will start after the internal memory so the lower addresses of the external RAM can't be used to store information.

When you want to protect an area of the chip, you can specify a higher address for the compiler to store the data. For example, you can specify &H400. The first dimensioned variable will be placed in address &H400 and not in &H260.

It is important that when you use $XRAMSTART and $XRAMSIZE that $XRAMSTART comes before $XRAMSIZE.

See also

[$XRAMSIZE](xramsize.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : m128.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrate using $XRAM directive

'micro : Mega128

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m128def.dat" ' specify the used micro

$crystal = 1000000 ' used crystal frequency

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$xramstart = &H1000

$xramsize = &H1000

Dim X As X

```

---

## $XTEAKEY

Action

This directive accepts a 16 byte XTEA key and informs the compiler to encrypt the binary image.

Syntax

$XTEAKEY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16

Remarks

$XTEAKEY accepts 16 parameters. These are the 16 bytes which together form a 128 bit key.

When your code is compiled, the resulting binary code will be encrypted with the provided key.

A boot loader could then use XTEA and decrypt the binary file before writing to flash memory.

The XTEADECODE statement can be used inside a boot loader to decrypt the encrypted blocks.

The XTEA encoder uses 32 rounds. The same as used in the xtea.lib

![notice](notice.jpg)Only the binary image is encrypted, the HEX file is not encrypted!

You can not simulate an encrypted program. Add this option when your project is ready.

See also

[$AESKEY](_aeskey.md) , [XTEAENCODE](xteaencode.md) , [XTEADECODE](xteadecode.md)

Example

NONE

---

## About MCS Electronics

About the Founder

Since I was young, I was intrigued by remote control, robots, transmitters, in short, all kinds of electronics. I created countless electronic devices. I designed a lot of PCB's by hand using ink and later using tape.

At the ETS(electronic technical school in Amsterdam) we had a Philips main frame with terminals which could be programmed in a simple form of BASIC.

When working at Philips in Hilversum i also worked with an industrial computer that could be programmed in BASIC. 

The Apple II we got later on at the ETS could also be programmed in BASIC. 

When the ATARI came with the 1040ST and an affordable PCB design tool, I bought my first real computer. I bought the ATARI just for the purpose of PCB design. The netlists had to be manually entered.

Only Dot matrix printers where available at that time. And the prints were not really usable. That only changed when laser printers became available.

I found out that a nice BASIC interpreter, which was similar to GW-BASIC, was included in the OS(TOS). For some reason, I liked this language. It was easy to master and very intuitive. 

I made some programs for the PTT(now KPN) that were revolutionary at that time.

For hobby purpose i used the 8052AH BASIC programmable processor from Intel. I made a lot of interfaces using PIO, relay, etc. My home was automated in 1986. Because of my work for the PTT i was also able to get caller info, something not available as a service yet. I used the 8052AH to show the caller info on an LCD.

The 8052 was great but the UV eeproms had to be erased using UV light. It was slow.

I found out, that Atmel made the 89C2051, which was a 20 pin chip with flash memory. I was excited to find out that there was a small micro processor that could be erased/reprogrammed without the need to UV erase the EPROM. 

In those days, electronic circuits consisted of numerous CMOS and TTL chips. I saw the 89C2051 as an ideal replacement for a lot of CMOS/TTL chips. It would make PCB design much simpler. So the 2051 became a replacement chip. Like a small black box chip. Now one was able to design his own chips! 

The idea to be able to change the behaviour of an electronic circuit, just by reprogramming it without using a solder iron, intrigued me. Today, it is a common practice, to update firmware, to fix bugs or add features. In 1993, it was not so common, at least not to my knowledge.

I initially wrote a complete tool for DOS. I rewrote the tool, when I was reasonably satisfied that Windows 3.1 was stable. The tool was for my own usage. When I discovered that it would be usable to others, I decided to add Help files and a simulator and to sell it for a small fee to support my hobby. Today you can get electronic devices for little money. But a resistor used to cost 5 cents !

In 1995, MCS started to sell BASCOM-LT, a BASIC compiler for Windows 3.1. It was the first Windows application that offered a complete and affordable solution, editor, compiler, simulator and programmer. BASCOM-LT was a 8051 BASIC compiler. The reason it became popular was that it included a lot of functionality that was easy to use from BASIC. Using an LCD display was simple, just a configuration line to define the used pins and voila, a working application in minutes. When you needed a different LCD display, you could simply change the CONFIG line. 

When a different processor was needed, you only had to change the name of the definition file. No need for a lot of .h files. 

Another reason for its success, was that we hide much of the complexity for the user. No ASM to deal with, simple statements. Of course free updates and support.

Small companies that used the BASIC Stamp also recognized another advantage : There was no need for expensive modules and the code ran much quicker.

When Windows 95 became an industry standard, users also wanted a 32 bit version. A big part of BASCOM-LT was rewritten with the additional support for arrays and floating point (single). 

With the many different 8051 variants, it was impossible to support all the chips. Having device definition âDATâ files, made it easy for the user to configure the 8051 variants.

When Atmel launched the AVR chip, the 8051 compiler was rewritten, once again, to support the powerful AVR chips. The result was BASCOM-AVR.

The AVR chip has a lot of internal memory. It uses simple linear memory addressing. The best part, is that you can make the chip program itself. No wonder this chip family became so popular.

Since the AVR chip is so powerful, we could extend the compiler as well. We could add features, which are almost impossible to add to the 8051. 

With more and more users, there was no way I could manage everything in my spare time. So in order to guarantee the future of BASCOM, I decided to work full time for MCS.

Today, MCS is still a small company, with only 3 employees and a few contract workers. 

We believe in free updates and support. With the number of (demo) users, it is however not possible to support everybody. You need to realize that reading and answering emails is time consuming. 

Not to mention to duplicate used hardware. We are unique, in that we even support hardware!

In order to migrate to a new version, it is important that you keep your software up to date. This will make migration more simple.

Things we find important : 

•| The environment. We reuse all usable packing material like foam, plastic bubbles, when we ship your order.   
---|---  
  
•| That everybody can use micro processors. They are like all other chips but you can define their behaviour.  
---|---  
  
•| Customer privacy: We keep your name, details and code confidential. We do not sell or share any of your details.   
---|---  
  
•| Free updates. They have been free since 1995 but there is no guarantee that they will remain free for ever. The intention is to keep them free. In order to apply for free updates you MUST register your software within 1 year.   
---|---  
  
•| Free, but limited, support. Limited only, because we do not have the resources to read/answer all emails. Professional users can get an SLA with guaranteed response time. This is a paid option/service.  
---|---  
  
•| Support for new chips. It is important to be able to support newly released chips.   
---|---  
  
•| The customer : We simply add what is requested most. It does not matter what, as long as it is requested a lot and it does makes sense and doesn't conflict with other features.  
---|---  
  
•| That you have fun with electronics, no matter where you live, no matter which religion you have, no matter how old you are, if you are male or female, purple or white.  
---|---  
  
•| That you can use the demo for free. The DEMO has no nag screens. You should purchase the full version if you use it commercial. Please do not use cracked software. Only download from the www.mcselec.com domain. Copies from other sites may contain spy ware, virus or other malware. When we detect a cracked version the compiler generates tiny bugs at random which are hard to detect. We ban all IP numbers of users with a cracked version.   
---|---  
  
Mark Alberts

Managing Dire

MCS Electronics

---

## About this Help

This help manual is available in CHM format for the IDE. And also in HTML on line.

A PDF version can also be downloaded. You can do that using the Tools, PDF function of the IDE.

Some topics show examples. Some examples are partial samples. Some examples demonstrate a number of statements.

And some topics contain full examples. 

When you want to use examples you can best load the examples that come with the IDE. 

By default they are installed in the SAMPLES folder.

The samples from the distribution are checked with each release since they are intended to be compiled. 

So they contain a $regfile directive, and default stack settings. And when print is used, communication set up.

The samples from the help are only intended to demonstrate a statement or function and are extremely simple. Often $regfile and stack is omitted. 

When you want to use the sample from the help you can copy & paste it. 

Do not forget to include $regfile, $hwstack, $swstack and $framesize when it is not included in the sample. The sample will compile without this info too but for later reference it is best to include this info.

Some examples from the help are from 1995 and the compiler has been extended. 

When you encounter a sample from the help that does not work, send an email to support so it can be corrected.

---

## ABS

Action

Returns the absolute value of a numeric signed variable.

Syntax

var = ABS(var2)

Remarks

Var | Variable that is assigned with the absolute value of var2.  
---|---  
Var2 | The source variable to retrieve the absolute value from.  
  
var : Integer , Long, Single or Double.

var2 : Integer, Long, Single or Double.

![notice](notice.jpg) The absolute value of a number is always positive.

See also

NONE

ASM

Calls: _abs16 for an Integer and _abs32 for a Long

Input: R16-R17 for an Integer and R16-R19 for a Long

Output:R16-R17 for an Integer and R16-R19 for a Long

Calls _Fltabsmem for a single from the fp_trig library.

Example

Dim a as Integer, c as Integer

a =-1000

c = Abs(a)

```vb
Print c

End

```

---

## ACOS

Action

Returns the arccosine of a float in radians.

Syntax

var = ACOS( x )

Remarks

Var | A floating point variable such as single or double, that is assigned with the ACOS of variable x.  
---|---  
X | The float to get the ACOS of. Input is valid from â1 to +1 and returns p to 0. If Input is < -1 than p and input is > 1 than 0 will returned.  
  
If Input is cause of rounding effect in float-operations a little bit over 1 or -1, the value for 1.0 (-1.0) will be returned. This is the reason to give the value of the limit-point back, if Input is beyond limit. Generally the user have to take care, that Input to this function lies within â1 to +1.

All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [COS](cos.md) , [SIN](sin.md) , [TAN](tan.md) , [ATN](atn.md) , [ASIN](asin.md) , [ATN2](atn2.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As Single , X As Single

```
x= 0.5 : S = Acos(x)

```vb
Print S

End

```

---

## Adding XRAM with External Memory Interface

With ATMEGA AVR like ATMEGA128, ATMEGA1280 or older types like 90S8515 you can access external RAM (SRAM) or other peripherals through its External Memory Interface. Search in the Atmel ATMEGA datasheets for "External Memory Interface"

```vb
For ATXMEGA devices see App Note: [AVR1312: Using the XMEGA External Bus Interface](<http://www.atmel.com/Images/doc8058.pdf>) for details.

For example for an ATMEGA1280 the external memory interface consist of PORTA (multiplexed data and address low byte), PORTC (address high byte), and PORTG[2:0] (RD, WR and ALE).

```
ATMEGA1280 pin connections to SRAM device:

Port A = Multiplexed Address low byte (A0....A7) / Data (D0....D7) <\--------> Direct connection to SRAM (D0...D7) and connected to Input D of octal latch (typically â74 x 573â or equivalent) to (A0.....A7) of SRAM chip

Port C = Address high byte (A8....A15) <\--------> direct connection to for example SRM (A8....A15)

Port G Pin 0 = WR (Write strobe to external memory) <\--------> direct connection to for example SRAM WR

Port G Pin 1 = RD (Read strobe to external memory) <\--------> direct connection to for example SRAM RD

Port G Pin 2 = ALE (Address Latch Enable to external memory) <\--------> Connected to G Input of octal latch (typically â74 x 573â like 74 x 573)

Example for 74HTC573 (TTL variant):

<http://www.nxp.com/documents/data_sheet/74HC_HCT573.pdf>

Address latch with octal latch:

The data bus and the low byte of the address bus is multiplexed on Port A. The ALE signal indicates when the address is present. This low byte must be stored by a latch until the memory access cycle is completed.

Schematics for connecting the ATMEGA with octal latch and sram can be found in:

•| Atmel AVR Studio Help File (AVR tools user guide) search for: "external memory interface" and scroll down to APPENDIX. There you also find a list of 3.3 or 5V compatible SRAM's that can be used with ATMEGA's and there is a link to STK503.pdf which is part of the help file.  
---|---  
  
•| The list of compatible SRAM devices can be also found here: <http://www.atmel.com/images/stk503_ug.pdf> (page 16)  
---|---  
  
•| The datasheet of for example ATMEGA1280 also include a picture which show the connections between AVR, Octal Latch external SRAM device.  
---|---  
  
The data memory map for example for ATmega640/1280/1281/2560/2561:

Hex-Address:

&H00 .... &H1F 32 Registers

&H20 .... &H5F 64 I/O Registers

&H60 .... &H1FF 416 external I/O Registers

&H200 .... &H21FF Internal SRAM (8K in this case)

&H2200 .... &HFFFF External SRAM (XRAM)

XRAM will use an area in the remaining address locations in the 64K address space (&HFFFF). This starts at the address following the internal SRAM. 

Internal SRAM use the lowest 4,608/8,704 bytes, so when using 64KB (65,536 bytes) of XRAM, 60,478/56,832 Bytes of XRAM are available.

See datasheet of ATMEGA device for a way to use the complete 64KByte.

XRAM will be enabled by [CONFIG XRAM](configxram.md) (config XRAM is setting SRE bit of the atmega 1280 XMCRA Register)

The Pins of Port A, Port C and Port G from ATMEGA1280 are automatically enabled for XRAM and can not be used for other tasks by default if XRAM is enabled. The external memory address space can be divided in two sectors (upper and lower sector) with different wait-state bits. You can also release some Port C pins for other tasks (in the XMCRB Register) . See atmega 1280 datasheet for details.

See also: [$XRAMSIZE](xramsize.md) and [$XRAMSTART](xramstart.md)

You can clear the XRAM for example with:

For N = Ramstart To Ramend 'replace RamStart and RamEnd with the real values  
Out N , 0 'zero or any value you like  
Next

With XRAM, you should dim all your global variables with XRAM. Example: Dim Var As Xram Byte

This will leave the internal memory for the stacks and local created variables.

You can also use $default Xram when you do not want to add the XRAM to each DIM. 

Example 1:

A real Example for using SRAM and another Bus-mode device is WIZ200WEB from Wiznet.

Here an ATMEGA128L, an external 32K SRAM and a W5300 Ethernet Chip is used. See also [CONFIG TCPIP](config_tcpip.md)

The data memory map for ATMEGA128:

Hex-Address:

&H00 .... &H1F 32 Registers

&H20 .... &H5F 64 I/O Registers

&H60 .... &HFF 160 external I/O Registers

&H100 .... &H10FF Internal SRAM (4K in this case)

&H1100 Start of External SRAM (XRAM)

So the config is following (&H8000 = 32kByte):

```vb
$xramstart = &H1100  
$xramsize = &H8000  
Config Xram = Enabled

```
The W5300 Chip from Wiznet is setup to use Base Address &H8000.

So the data memory map for ATMEGA128 is:

Hex-Address:

&H00 .... &H1F 32 Registers

&H20 .... &H5F 64 I/O Registers

&H60 .... &HFF 160 external I/O Registers

&H100 .... &H10FF Internal SRAM (4K in this case)

&H1100 Start of External SRAM (XRAM)

&H8000 Base Address of W5300 Chip from WIZNET

&H8400 .... &HFFFF Not in use

See also [CONFIG TCPIP](config_tcpip.md) for further details on W5300 Chip from Wiznet.

Example 2:

We use now an WIZ830mj module (which uses a W5300 Chip from Wiznet) on a board with an 64/128KByte SRAM in combination with ATMEGA1280:

Hex-Address:

&H00 .... &H1F 32 Registers

&H20 .... &H5F 64 I/O Registers

&H60 .... &H1FF 416 external I/O Registers

&H200 .... &H21FF Internal SRAM (8K in this case)

&H2200 .... &HFBFF External SRAM (XRAM) upper and lower

&HFC00 Base Address of W5300 Chip over memory address selector

XRAM configuration here is:

```vb
$xramstart = &H2200  
$xramsize = &HFBFF  
Config Xram = Enabled

```
Writing to the first XRAM address is done by:

Out &H2200 , &H01

Reading from first XRAM is done by:

Var = Inp(&H2200)

The datasheet of W5300 say: "In the case of using an 8bit data bus width, ADDR[9:0] is used " so we have Address 0.......Address 9 but the SRAM need Address 0.....15.

Here an example of additional circuit between ATMEGA and W5300 and SRAM to solve the difference of address (A0...A15) for SRAM and (A0...A9) for W5300:

![adding_xram_2](adding_xram_2.png)  


The Base Address for W5300 (WIZ830mj) in this case is &HFC00

Address Bit | A15 | A14 | A13 | A12 | A11 | A10 | A9 | A8 | A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0  
---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---  
Binary: | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0  
Hex: | FC00 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   
  
For older 90S8515 chips for example the maximum size of XRAM can be 64 Kbytes.

Example: The STK200 has a 62256 ram chip (32K x 8 bit).

Here is some info from the BASCOM user list :

If you do go with the external ram , be careful of the clock speed.

Using a 4 MHz crystal , will require a SRAM with 70 nS access time or less. Also the data latch (74HC573) will have to be from a faster

family such as a 74FHC573 if you go beyond 4 MHz.

You can also program an extra wait state, to use slower memory.

Here you will find a pdf file showing the STK200 schematics:

See Stk200_schematic.pdf for more information.

If you use a 32 KB SRAM, then connect the /CS signal to A15 which give to the range of &H0000 to &H7FFF, if you use a 64 KB SRAM, then

tie /CS to GND, so the RAM is selected all the time.

![xram](xram.jpg)

---

## ADR ,  ADR2

Action

Create label address.

Syntax

ADR  label

ADR2  label

Remarks

label | The name of a label.  
---|---  
  
The AVR uses WORD addresses. ADR will create the word address. To find a byte in memory, you need to multiply by 2. For this purpose ADR2 is available. It will create the address of the label multiplied by 2.

Using ADR2 you can use tables. The sample program demonstrates this together with some more advanced ASM code.

The sample includes ADR2.LIB. This lib contains a special version of _MoveConst2String .

The normal routine in MCS.LIB will stop printing once a null byte (zero) is encountered that indicates the end of a string.

But for the sample program, we may not change the address, so the address is restored when the null byte is found.

See Also

NONE

Example

```vb
'===============================================================================

' This is an example of how to create an interactive menu system supporting

' sub-menus and support routines using the !ADR and !ADR2 statements

'===============================================================================

$regfile = "M644def.dat"

$crystal = 8000000

$hwstack = 64 ' specify the hardware stack depth

$swstack = 64 ' specify the software stack depth

$framesize = 64 ' specify the framesize (local stack depth)

$lib "adr2.lib"

'-------------------------------------------------------------------------------

Dim Menupointer As Word

Dim Actionpointer As Word

Dim Entries As Byte

Dim Dummy As Byte

Dim Message As String * 32

Dim Local1 As Byte

Dim Local_loop1 As Byte

```
Const Menu_id = &HAA ' sub-menu ID byte

Const Routine_id = &H55 ' service routine ID byte

'-------------------------------------------------------------------------------

Restore Main_menu ' point to the start of the 'main' menu

! sts {MenuPointer}, R8 ' }

! sts {MenuPointer + 1}, R9 ' } store the pointer to the start of the menu

Display_new_menu:

! lds R8, {MenuPointer} ' }

! lds R9, {MenuPointer + 1} ' } restore the pointer to the start of the menu

Read Entries ' get the number of entries in the menu including the title

```vb
Print

For Local_loop1 = 1 To Entries

```
Read Message ' read the message

```vb
Print Message ' send it to the console

Next

```
Read Dataptr ' get the pointer to the menu's action table

! sts {ActionPointer}, R8 ' }

! sts {ActionPointer + 1}, R9 ' } store the pointer to the start of the menu's action list

```vb
Input "Entry ? " , Local1 ' ask the user which menu entry

If Local1 = 0 Then ' is it valid ?

Goto Display_new_menu ' if not, re-display the menu

End If

If Local1 => Entries Then ' is it valid ?

Goto Display_new_menu ' if not, re-display the menu

End If

```
! lds R8,{ActionPointer} ' }

! lds R9,{ActionPointer + 1} ' } restore the pointer to the menu's action list

```vb
If Local1 <> 1 Then

For Local_loop1 = 2 To Local1 '

```
! ldI R30,4 ' }

! clr R1 ' }

! add R8,R30 ' }

! adc R9,R1 ' }

```vb
Next ' } calculate the location of the selected entry's function ID

End If

```
Read Local1 ' get the menu entry's function ID

Read Dummy ' to handle the uP expecting WORDS in DATA statements

If Local1 = Menu_id Then ' did the user select an entry that points to another menu ?

Read Dataptr

! sts {MenuPointer}, R8 ' }

! sts {MenuPointer + 1}, R9 ' } store the start of the menu

```vb
Goto Display_new_menu

End If

```
Read Dataptr ' get the address of this entry's support routine

! movw R30,R8

! icall ' pass control to the entry's support routine

```vb
Goto Display_new_menu ' re-display the last menu displayed

'-------------------------------------------------------------------------------

' Test support routines

'-------------------------------------------------------------------------------

```
Hello_message:

```vb
Print

Print "You asked to print 'Hello'" ' confirmation that Menu Entry 3 was selected

Return

```
2nd_menu_1st_entry_routine:

```vb
Print

Print "You selected Entry 1 of the 2nd menu" ' confirmation that Menu Entry 1 was selected

Return

```
2nd_menu_2nd_entry_routine:

```vb
Print

Print "You selected Entry 2 of the 2nd menu" ' confirmation that Menu Entry 2 was selected

Return

```
3rd_menu_1st_entry_routine:

```vb
Print

Print "You selected Entry 1 of the 3rd menu" ' confirmation that Menu Entry 1 was selected

Return

```
3rd_menu_2nd_entry_routine:

```vb
Print

Print "You selected Entry 2 of the 3rd menu" ' confirmation the Menu Entry 2 was selected

Return

End

'===============================================================================

' Data Statements

'===============================================================================

$data

'-------------------------------------------------------------------------------

' Main Menu

'-------------------------------------------------------------------------------

```
Main_menu:

Data 4 ' number of entries in the menu including title

Data "MAIN MENU" ' } menu title

Data "1. Go to Menu 2" ' } 1st menu entry

Data "2. Go to Menu 3" ' } 2nd menu entry

Data "3. Print 'Hello' message" ' } 3rd menu entry

Adr2 Mainmenu_supporttable ' point to this menu support table

'-------------------------------------------------------------------------------

Mainmenu_supporttable:

Data Menu_id ' identify this menu entry as a menu

Adr2 Second_menu ' address of next menu

Data Menu_id ' identify this menu entry as a menu

Adr2 Third_menu ' address of next menu

Data Routine_id ' identify this menu entry as support routine

Adr Hello_message ' address of the support routine

```vb
'-------------------------------------------------------------------------------

' Second Menu

'-------------------------------------------------------------------------------

```
Second_menu:

Data 4 ' number of entries in the menu

Data "SECOND MENU" ' } menu title

Data "1. 2nd Menu Entry #1" ' } 1st menu entry

Data "2. 2nd Menu Entry #2" ' } 2nd menu entry

Data "3. Go to previous menu" ' } 3rd menu entry

Adr2 Secondmenu_supporttable ' point to this menu support table

'-------------------------------------------------------------------------------

Secondmenu_supporttable:

Data Routine_id ' identify this menu entry as a support routine

Adr 2nd_menu_1st_entry_routine ' support routine for 1st menu entry

Data Routine_id ' identify this menu entry as a support routine

Adr 2nd_menu_2nd_entry_routine ' support routine for 2nd menu entry

Data Menu_id ' identify this menu entry as a menu

Adr2 Main_menu ' support routine for 3rd menu entry

```vb
'-------------------------------------------------------------------------------

' Third Menu

'-------------------------------------------------------------------------------

```
Third_menu:

Data 4 ' number of entries in the menu

Data "THIRD MENU" ' } menu title

Data "1. 3rd Menu Entry #1" ' } 1st menu entry

Data "2. 3rd Menu Entry #2" ' } 2nd menu entry

Data "3. Go to previous menu" ' } 3rd menu entry

Adr2 Thirdmenu_supporttable ' point to this menu support table

'-------------------------------------------------------------------------------

Thirdmenu_supporttable:

Data Routine_id ' identify this menu entry as a support routine

Adr 3rd_menu_1st_entry_routine ' support routine for 1st menu entry

Data Routine_id ' identify this menu entry as a support routine

Adr 3rd_menu_2nd_entry_routine ' support routine for 2nd menu entry

Data Menu_id ' identify this menu entry as a menu

Adr2 Main_menu ' support routine for 3rd menu entry

---

## AESDECRYPT

Action

This statement of function uses the Xmega AES encryption engine to decrypt a block of data.

Syntax

AESDECRYPT  key, var , size

targ = AESDECRYPT ( key, var , size)

Remarks

key | The name of a label that contains 16 bytes of key data. Or an array holding 16 bytes of key data.  
---|---  
var | A variable or array containing the data to be encrypted. When you use the statement, this variable will contain the encrypted data after the conversion.  
size | The number of bytes to encrypt. Encryption is done with blocks of 16 bytes. So the size should be a multiple of 16. If you supply only 14 bytes this is ok too, but the result will still be 16 bytes.  ![notice](notice.jpg)It is important that your array is big enough to hold the result.  Without the full 16 byte result, you can not decrypt the data.  
targ | In case you use the function, this variable will hold the result.   
  
This function only works for Xmega chips that have an AES encryption unit.

128 bit encryption is used.

You can either use a label with a fixed key, or use a variable.

You should use the same key data for encryption and decryption.

See also

[$LOADER](loader.md) , [$AESKEY](_aeskey.md) , [AESENCRYPT](aesencrypt.md) , [DESENCRYPT](desencrypt.md) , [DESDECRYPT](desdecrypt.md) , [$XTEAKEY](xteakey.md) , [XTEAENCODE](xteaencode.md), [XTEADECODE](xteadecode.md)

Example

```vb
'----------------------------------------------------------------  
' (c) 1995-2025 MCS  
' xm128-AES.bas  
' This sample demonstrates the Xmega128A1 AES encryption/decryption  
'-----------------------------------------------------------------  
  
$regfile = "xm128a1def.dat"  
$crystal = 32000000  
$hwstack = 64  
$swstack = 40  
$framesize = 40  
  
  
'first enable the osc of your choice  
Config Osc = Enabled , 32mhzosc = Enabled  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1  
  
Config Com1 = 38400 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
  
'$external _aes_enc  
  
Dim Key(16) As Byte ' room for key  
Dim Ar(34) As Byte  
Dim Arenc(34) As Byte  
Dim J As Byte  
Print "AES test"  
  
```
Restore Keydata  
For J = 1 To 16 ' load a key to memory  
Read Key(j)  
```vb
Next  
  
'load some data  
For J = 1 To 32 ' fill some data to encrypt  
```
Ar(j) = J  
Next  
  
  
Aesencrypt Keydata , Ar(1) , 32  
```vb
Print "Encrypted data"  
For J = 1 To 32 ' fill some data to encrypt  
Print Ar(j)  
Next  
  
  
```
Aesdecrypt Keydata , Ar(1) , 32  
```vb
Print "Decrypted data"  
For J = 1 To 32 ' fill some data to encrypt  
Print Ar(j)  
Next  
  
Print "Encrypt function"  
```
Arenc(1) = Aesencrypt(keydata , Ar(1) , 32)  
```vb
For J = 1 To 32 ' fill some data to encrypt  
Print Ar(j) ; "-" ; Arenc(j)  
Next  
  
Print "Decrypt function"  
```
Ar(1) = Aesdecrypt(keydata , Arenc(1) , 32)  
  
```vb
For J = 1 To 32  
Print J ; ">" ; Ar(j) ; "-" ; Arenc(j)  
Next  
  
End  
  
  
  
```
Keydata:  
Data 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16

---

## AESENCRYPT

Action

This statement of function uses the Xmega AES encryption engine to encrypt a block of data.

Syntax

AESENCRYPT  key, var , size

targ = AESENCRYPT ( key, var , size)

Remarks

key | The name of a label that contains 16 bytes of key data. Or an array holding 16 bytes of key data.  
---|---  
var | A variable or array containing the data to be encrypted. When you use the statement, this variable will contain the encrypted data after the conversion.  
size | The number of bytes to encrypt. Encryption is done with blocks of 16 bytes. So the size should be a multiple of 16. If you supply only 14 bytes this is ok too, but the result will still be 16 bytes. It is important that your array is big enough to hold the result.  Without the full 16 byte result, you can not decrypt the data.  
targ | In case you use the function, this variable will hold the result.   
  
This function only works for Xmega chips that have an AES encryption unit.

128 bit encryption is used.

You can either use a label with a fixed key, or use a variable.

You should use the same key data for encryption and decryption.

See also

[$LOADER](loader.md) , [$AESKEY](_aeskey.md) , [AESDECRYPT](aesdecrypt.md) , [DESENCRYPT](desencrypt.md) , [DESDECRYPT](desdecrypt.md) , [$XTEAKEY](xteakey.md) , [XTEAENCODE](xteaencode.md), [XTEADECODE](xteadecode.md)

Example

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' xm128-AES.bas  
' This sample demonstrates the Xmega128A1 AES encryption/decryption  
'-----------------------------------------------------------------  
  
$regfile = "xm128a1def.dat"  
$crystal = 32000000  
$hwstack = 64  
$swstack = 40  
$framesize = 40  
  
  
'first enable the osc of your choice  
Config Osc = Enabled , 32mhzosc = Enabled  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1  
  
Config Com1 = 38400 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
  
'$external _aes_enc  
  
Dim Key(16) As Byte ' room for key  
Dim Ar(34) As Byte  
Dim Arenc(34) As Byte  
Dim J As Byte  
Print "AES test"  
  
```
Restore Keydata  
For J = 1 To 16 ' load a key to memory  
Read Key(j)  
```vb
Next  
  
'load some data  
For J = 1 To 32 ' fill some data to encrypt  
```
Ar(j) = J  
Next  
  
  
Aesencrypt Keydata , Ar(1) , 32  
```vb
Print "Encrypted data"  
For J = 1 To 32 ' fill some data to encrypt  
Print Ar(j)  
Next  
  
  
```
Aesdecrypt Keydata , Ar(1) , 32  
```vb
Print "Decrypted data"  
For J = 1 To 32 ' fill some data to encrypt  
Print Ar(j)  
Next  
  
Print "Encrypt function"  
```
Arenc(1) = Aesencrypt(keydata , Ar(1) , 32)  
```vb
For J = 1 To 32 ' fill some data to encrypt  
Print Ar(j) ; "-" ; Arenc(j)  
Next  
  
Print "Decrypt function"  
```
Ar(1) = Aesdecrypt(keydata , Arenc(1) , 32)  
  
```vb
For J = 1 To 32  
Print J ; ">" ; Ar(j) ; "-" ; Arenc(j)  
Next  
  
End  
  
  
  
```
Keydata:  
Data 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16

---

## ALIAS

Action

Indicates that the variable can be referenced with another name.

Syntax

newvar ALIAS oldvar

Remarks

oldvar | Name of the variable such as PORTB.1  
---|---  
newvar | New name of the variable such as direction  
  
Aliasing port pins can give the pin names a more meaningful name. For example, when your program uses 4 different pins to control 4 different relays, you could name them portb.1, portb.2, portb.3 and portb.4.

But it would be more convenient to refer to them as relais1, relais2, relais3 and realais4.

When you later on change your PCB and decide that relays 4 must be connected to portD.4 instead of portb.4, you only need to change the ALIAS line, and not your whole program.

See also

[CONST](const.md)

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates ALIAS

'-------------------------------------------------------------------------------

$regfile = "m48def.dat"

$crystal = 4000000 ' 4 MHz crystal

```
Const On = 1

Const Off = 0

Config Portb = Output

Relais1 Alias Portb.1

Relais2 Alias Portb.2

Relais3 Alias Portd.5

Relais4 Alias Portd.2

Set Relais1

Relais2 = 0

Relais3 = On

Relais4 = Off

End

---

## AlphaFunc

Action

Specify the Alpha Test Function

Syntax

AlphaFunc ref, func 

Remarks

ref | Specifies the reference value for the alpha test. The initial value is 0  
---|---  
func | Specifies the test function, one of NEVER, LESS, LEQUAL, GREATER, GEQUAL, EQUAL, NOTEQUAL, or ALWAYS. The default value is ALWAYS.   
  
Graphics Context

The values of func and ref are part of the graphics context, as described in section 4.1 in FT800 Series Programmer Guide.PDF from FTDI.

---

## AND

Action

This logical operator returns the AND of two numeric variables.

Syntax

target = source1 AND source2

Remarks

The AND operator works on two bits. It returns a '1' if both inputs are '1'. 

A | B | R  
---|---|---  
0 | 0 | 0  
0 | 1 | 0  
1 | 0 | 0  
1 | 1 | 1  
  
The truth table above shows all possible values. A and B represent the 2 inputs. R is the Return or output value. As you can see, you will only get a '1' when both inputs are '1'

It is like having 2 switches in series. You have to switch them both on in order to have a closed circuit.

While you can use AND on bits, you can also perform the same operation on bytes, integers, etc. In such a case, all bits of the variables will be AND-ed.

Example :

Dim A as Byte, B as Byte, R as byte

A=&B1100_0001

B=&B1001_0000

R=A AND B

R=&B1000_0000

As you can see, only bit 7 of both variables is '1'. So in the result, only bit 7 is set. This makes the AND operation perfect for isolating or clearing bits. If you want a value to be in a range of say 0-7 you can set the value to 7 : result= var AND &B111

See also

[OR](or.md) , [XOR](xor.md), [NOT](not.md)

Example

```vb
'--------------------------------------------------------------------------------  
'name : boolean.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demo: AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
'suited for demo : yes  
'commercial add on needed : no  
'use in simulator : possible  
'--------------------------------------------------------------------------------  
'This very same program example can be used in the Help-files for  
' AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
  
  
$baud = 19200  
$crystal = 8000000  
$regfile = "m88def.dat"  
  
$hwstack = 40  
$swstack = 20  
$framesize = 20  
  
Dim A As Byte , B1 As Byte , C As Byte  
Dim Aa As Bit , I As Integer  
  
```
A = 5 : B1 = 3 ' assign values  
C = A And B1 ' and a with b  
Print "A And B1 = " ; C ' print it: result = 1  
  
  
C = A Or B1  
Print "A Or B1 = " ; C ' print it: result = 7  
  
C = A Xor B1  
Print "A Xor B1 = " ; C ' print it: result = 6  
  
A = 1  
C = Not A  
Print "c = Not A " ; C ' print it: result = 254  
C = C Mod 10  
```vb
Print "C Mod 10 = " ; C ' print it: result = 4  
  
  
If Portb.1 = 1 Then 'test a bit from a PORT (which is not the same as testing the input state)  
Print "Bit set"  
Else  
Print "Bit not set"  
End If 'result = Bit not set  
  
Config Pinb.0 = Input : Portb.0 = 1 'configure as input pin  
Do  
Loop Until Pinb.0 = 0 ' repeat this loop until the logic level becomes 0  
  
```
Aa = 1 'use this or ..  
```vb
Set Aa 'use the set statement  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit set (aa=1)  
  
```
Aa = 0 'now try 0  
```vb
Reset Aa 'or use reset  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit not set(aa=0)  
  
```
C = 8 'assign variable to &B0000_1000  
```vb
Set C 'use the set statement without specifying the bit  
Print C 'print it: result = 9 ; bit0 has been set  
  
```
B1 = 255 'assign variable  
```vb
Reset B1.0 'reset bit 0 of a byte variable  
Print B1 'print it: result = 254 = &B11111110  
  
```
B1 = 8 'assign variable to &B00001000  
```vb
Set B1.7 'set it  
Print B1 'print it: result = 9 = &B00001001  
End

```

---

## Application Notes

When you want to show your application at our web as a reference example on what you can achieve with BASCOM, we like to show it at our web, but of course with your permission.

We never publish anything without your explicit permission.

AN's are also welcome. When you developed a great AN you want to share with other BASCOM users, just send it and we will make an AN out of it. It is important that the comment in the source is in English. 

You can also share your code at the MCS Electronics user forum.

---

## ARDUINO

The ARDUINO is a hardware platform based on AVR processors. ARDUINO boards/chips are programmed with a bootloader. This bootloader is the old STK500 protocol, not longer supported by Atmel in Studio. There are various programmers for ARDUINO, AVRDUDE is probably the most versatile. 

BASCOM also supports the ARDUINO/STK500 v1 protocol. the DTR/RTS lines are used to reset the board.

You can program/read flash/EEPROM but you can not read/write fuse/lock bytes. The STK500 bootloader for ARDUINO does not support this.

Under options you only need to select the programmer, and the COM port. Since an FTDI chip is used on most ARDUINO boards, this is a virtual COM port. Only present when the USB cable is connected to your PC.

Select 57600 baud for the baud rate. Older ARDUINO boards work with 19200 baud.

ARDUINO V2

The developers of the ARDUINO finally implemented the STK500V2 protocol. This protocol is supported by Atmel and of course by BASCOM.

Select the ARDUINO STK500V2 programmer in BASCOM programmer options to use this protocol.

A board like the MEGA2560 R3 uses this protocol and probably all newer AVR based ARDUINO boards will support this protocol. The baud rate should be 115200 but could be different for your board.

ARDUINO Leonardo

For some reason each arduino board seems to use a different bootloader method. The leonardo implements a virtual COM port. When opened at 1200 baud, the board resets into another virtual COM device with a different COM port number.

In BASCOM you need to chose the myAVR MK2 / AVR910 programmer since Leonardo uses the AVR910 loader from Atmel.

You need to select the COM port that you get at Boot time. The baud is 115200. 

To program, press the reset button, wait till the USB is enumerated and the Virtual COM port is ready, then press F4 to program the processor.

Using Bascom-AVR with Arduino Optiboot Bootloader (under Windows 7)

For more information on Optiboot visit following website: http://code.google.com/p/optiboot/

1.| Download AVRDUDE from http://www.nongnu.org/avrdude/  
---|---  
  
2.| Latest Windows Version (April 2012): avrdude-5.11-Patch7610-win32.zip  
---|---  
  
Complete link: http://download.savannah.gnu.org/releases/avrdude/avrdude-5.11-Patch7610-win32.zip

3.| Create a folder like c:\AVRDUDE   
---|---  
  
4.| Copy the content of avrdude-5.11-Patch7610-win32.zip in this new folder  
---|---  
  
5.| Open Bascom-AVR  
---|---  
  
6.| Click on Options >>> Programmer  
---|---  
  
7.| Choose External programmer  
---|---  
  
8.| Checkmark Use HEX file  
---|---  
  
9.| Include the path to avrdude.exe  
---|---  
  
10.| User Parameter:   
---|---  
  
-C c:\avrdude\avrdude.conf -p m328p -P com19 -c arduino -b 115200 -U flash:w:{FILE}:i

![optiboot_bascom_1](optiboot_bascom_1.png)

Explanation of Parameter:

-C 

c:\avrdude\avrdude.conf The config file tells avrdude about all the different ways it can talk to the programmer.

-p 

m328p This is just to tell it what microcontroller its programming. For example, if you are programming an Atmega328p, use m328p as the partnumber

-P 

com19 This is the communication port to use to talk to the programmer (COM19) in this case. Change it to your COM port.

-c

arduino

Here is where we specify the programmer type, if you're using an STK500 use stk500, use arduino for Optiboot

-b

115200

Set serial baudrate for programmer. Use 115200 baud for Optiboot.

-U

flash:w:{FILE}:i

You define here:

•| the memory type: flash or eeprom (this could be also hfuse, lfuse or effuse if you want to verfiy this)  
---|---  
  
•| r (read), w (write) or v (verify)  
---|---  
  
•| Use {FILE} to insert the filename {EEPROM} to insert the filename of the generated EEP file.  
---|---  
  
•| i = Intel Hex File   
---|---  
  
After clicking on the F4 (Program Chip) Button in Bascom-AVR you see the CMD window of Windows 7 until AVRDUDE is ready flashing the Arduino.

![Optiboot_bascom_2](optiboot_bascom_2.png)

Complete documentation of AVRDUDE parameters:

http://www.nongnu.org/avrdude/user-manual/avrdude_4.html#Option-Descriptions

---

## ASC

Action

Assigns a numeric variable with the ASCII value of the first character of a string.

Syntax

var = ASC(string [,index])

Remarks

Var | Target numeric variable that is assigned.  
---|---  
String | String variable or constant from which to retrieve the ASCII value.  
Index | An optional index value. The index has a range from 1 to the length of the string. When no index is provided, the default value 1 will be used.  
  
Note that only the first character of the string will be used.

When the string is empty, a zero will be returned. 

ASCII stands for American Standard Code for Information Interchange. Computers can only understand numbers, so an ASCII code is the numerical representation of a character such as 'a' or '@' or an action of some sort. ASCII was developed a long time ago and now the non-printing characters are rarely used for their original purpose. Below is the ASCII character table and this includes descriptions of the first 32 non-printing characters. ASCII was actually designed for use with teletypes and so the descriptions are somewhat obscure. If someone says they want your CV however in ASCII format, all this means is they want 'plain' text with no formatting such as tabs, bold or underscoring - the raw format that any computer can understand. This is usually so they can easily import the file into their own applications without issues. Notepad.exe creates ASCII text, or in MS Word you can save a file as 'text only'

![ascii_table](ascii_table.png)

Extended ASCII

As people gradually required computers to understand additional characters and non-printing characters the ASCII set became restrictive. As with most technology, it took a while to get a single standard for these extra characters and hence there are few varying 'extended' sets. The most popular is presented below.

![ascii_table_ext](ascii_table_ext.png)

See also

[CHR](chr.md)

ASM

NONE

Example

```vb
'------------------------------------------------------------------------------  
'name : asc.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demonstrates ASC function  
'micro : Mega88  
'suited for demo : yes  
'commercial addon needed : no  
'------------------------------------------------------------------------------  
  
$RegFile = "m88def.dat" ' specify the used micro  
$crystal = 8000000 ' used crystal frequency  
$baud = 19200 ' use baud rate  
$hwstack = 32 ' default use 32 for the hardware stack  
$swstack = 10 ' default use 10 for the SW stack  
$framesize = 40 ' default use 40 for the frame space  
  
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  
  
  
Dim A As Byte , S As String * 10 , idx as Byte  
Print "ASC demo"  
```
S = "ABC"  
A = Asc(s)  
```vb
Print A 'will print 65  
  
print "test with index"  
```
a= asc(s,0) : print a 'invalid range will return 0  
a= asc(s,2) : print a  
a= asc(s,100) : print a 'invalid range will return 0  
  
  
End

---

## ASCII chart

Decimal Octal Hex Binary Value

\------- ----- --- ------ -----

000 000 000 00000000 NUL (Null char)

001 001 001 00000001 SOH (Start of Header)

002 002 002 00000010 STX (Start of Text)

003 003 003 00000011 ETX (End of Text)

004 004 004 00000100 EOT (End of Transmission)

005 005 005 00000101 ENQ (Enquiry)

006 006 006 00000110 ACK (Acknowledgment)

007 007 007 00000111 BEL (Bell)

008 010 008 00001000 BS (Backspace)

009 011 009 00001001 HT (Horizontal Tab)

010 012 00A 00001010 LF (Line Feed)

011 013 00B 00001011 VT (Vertical Tab)

012 014 00C 00001100 FF (Form Feed)

013 015 00D 00001101 CR (Carriage Return)

014 016 00E 00001110 SO (Shift Out)

015 017 00F 00001111 SI (Shift In)

016 020 010 00010000 DLE (Data Link Escape)

017 021 011 00010001 DC1 (XON) (Device Control 1)

018 022 012 00010010 DC2 (Device Control 2)

019 023 013 00010011 DC3 (XOFF)(Device Control 3)

020 024 014 00010100 DC4 (Device Control 4)

021 025 015 00010101 NAK (Negative Acknowledgement)

022 026 016 00010110 SYN (Synchronous Idle)

023 027 017 00010111 ETB (End of Trans. Block)

024 030 018 00011000 CAN (Cancel)

025 031 019 00011001 EM (End of Medium)

026 032 01A 00011010 SUB (Substitute)

027 033 01B 00011011 ESC (Escape)

028 034 01C 00011100 FS (File Separator)

029 035 01D 00011101 GS (Group Separator)

030 036 01E 00011110 RS (Request to Send)(Record Separator)

031 037 01F 00011111 US (Unit Separator)

032 040 020 00100000 SP (Space)

033 041 021 00100001 ! (exclamation mark)

034 042 022 00100010 " (double quote)

035 043 023 00100011 # (number sign)

036 044 024 00100100 $ (dollar sign)

037 045 025 00100101 % (percent)

038 046 026 00100110 & (ampersand)

039 047 027 00100111 ' (single quote)

040 050 028 00101000 ( (left/opening parenthesis)

041 051 029 00101001 ) (right/closing parenthesis)

042 052 02A 00101010 * (asterisk)

043 053 02B 00101011 + (plus)

044 054 02C 00101100 , (comma)

045 055 02D 00101101 - (minus or dash)

046 056 02E 00101110 . (dot)

047 057 02F 00101111 / (forward slash)

048 060 030 00110000 0

049 061 031 00110001 1

050 062 032 00110010 2

051 063 033 00110011 3

052 064 034 00110100 4

053 065 035 00110101 5

054 066 036 00110110 6

055 067 037 00110111 7

056 070 038 00111000 8

057 071 039 00111001 9

058 072 03A 00111010 : (colon)

059 073 03B 00111011 ; (semi-colon)

060 074 03C 00111100 < (less than)

061 075 03D 00111101 = (equal sign)

062 076 03E 00111110 > (greater than)

063 077 03F 00111111 ? (question mark)

064 100 040 01000000 @ (AT symbol)

065 101 041 01000001 A

066 102 042 01000010 B

067 103 043 01000011 C

068 104 044 01000100 D

069 105 045 01000101 E

070 106 046 01000110 F

071 107 047 01000111 G

072 110 048 01001000 H

073 111 049 01001001 I

074 112 04A 01001010 J

075 113 04B 01001011 K

076 114 04C 01001100 L

077 115 04D 01001101 M

078 116 04E 01001110 N

079 117 04F 01001111 O

080 120 050 01010000 P

081 121 051 01010001 Q

082 122 052 01010010 R

083 123 053 01010011 S

084 124 054 01010100 T

085 125 055 01010101 U

086 126 056 01010110 V

087 127 057 01010111 W

088 130 058 01011000 X

089 131 059 01011001 Y

090 132 05A 01011010 Z

091 133 05B 01011011 [ (left/opening bracket)

092 134 05C 01011100 \ (back slash)

093 135 05D 01011101 ] (right/closing bracket)

094 136 05E 01011110 ^ (caret/circumflex)

095 137 05F 01011111 _ (underscore)

096 140 060 01100000 `

097 141 061 01100001 a

098 142 062 01100010 b

099 143 063 01100011 c

100 144 064 01100100 d

101 145 065 01100101 e

102 146 066 01100110 f

103 147 067 01100111 g

104 150 068 01101000 h

105 151 069 01101001 i

106 152 06A 01101010 j

107 153 06B 01101011 k

108 154 06C 01101100 l

109 155 06D 01101101 m

110 156 06E 01101110 n

111 157 06F 01101111 o

112 160 070 01110000 p

113 161 071 01110001 q

114 162 072 01110010 r

115 163 073 01110011 s

116 164 074 01110100 t

117 165 075 01110101 u

118 166 076 01110110 v

119 167 077 01110111 w

120 170 078 01111000 x

121 171 079 01111001 y

122 172 07A 01111010 z

123 173 07B 01111011 { (left/opening brace)

124 174 07C 01111100 | (vertical bar)

125 175 07D 01111101 } (right/closing brace)

126 176 07E 01111110 ~ (tilde)

127 177 07F 01111111 DEL (delete)

---

## ASIN

Action

Returns the arcsine of a float in radians.

Syntax

var = ASIN( x )

Remarks

Var | A float variable such as single or double that is assigned with the ASIN of variable x.  
---|---  
X | The float to get the ASIN of. Input is valid from â1 to +1 and returns -p/2 to +p/2. If Input is < -1 than -p/2 and input is > 1 than p/2 will returned.  
  
If Input is cause of rounding effect in single-operations a little bit over 1 or -1, the value for 1.0 (-1.0) will be returned. This is the reason to give the value of the limit-point back, if Input is beyond limit. Generally the user have to take care, that Input to this function lies within â1 to +1.

All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [COS](cos.md) , [SIN](sin.md) , [TAN](tan.md) , [ATN](atn.md) , [ACOS](acos.md) , [ATN2](atn2.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As Single , X As Single

```
X = 0.5 : S = Asin(x)

```vb
Print S '0.523595867

End

```

---

## ASM Libraries and Add-Ons

ASM Libs are libraries that are used by the compiler.

They contain machine language statements for various statements and functions.

A library can also be used to modify an existing function.

For example when you use a conversion routine num<>string with a byte variable only, the routine from the MCS.LIB has some overhead as it can also convert integers,word and longs.

You can specify the MCSBYTE.LIB or MCSBYTE.LBX library then to override the function from MCS.LIB.

When you write a user sub/function that calls a user lib and passed parameters, you must include some code to restore the frame protection.

In the bcd.lib you can find code like :

#IF _FPROTECT

Out sreg,r3 ; restore I flag

#ENDIF

The bcd.lib and bin2bcd.bas demonstrate how to write a user lib.

The mylib.lib example contains more details about passing variables. 

A lib must be included with the $LIB directive.

When the library contains an overloaded version of a sub/function it is important that you put the $LIB directive early in your code. 

You can also change the behavior of a sub by putting the code in your own lib.

For example consider the _FLIPBYTE code from mcs.lib 

;flip or mirror bits in register R24

;1001_0000 becomes 0000_1001

[_FLIPBYTE]

_FLIPBYTE: 

push r16 ; save regs 

push r17 

ldi r16,8 ; num of bits 

_FLIPBYTE2: 

rol r24 ; rotate left through carry

ror r17 ; get in r17 rotate right 

dec r16 ; next 

brne _FLIPBYTE2

mov r24, r17 

pop r17 

pop r16 

ret 

[END]

you could put this code into a new lib named fliplib.lib

Then include it with $|LIB "fliplib.lib"

The compiler will use the code from your lib when you include it. The lib code is automatically called when using FLIP() .

You may not share libs where you copied the code from the BASCOM libraries. These are protected by copyright. So when it is required to share libs you need to ask permission. 

When you share a forked lib with another user that has a valid license there is no problem. But when you modify some code and put it on the internet, it could be a problem. 

You can access variables by using brackets :

lds r24, {bSomeVar} ; load into r24 the content from the byte variable bSomeVar

When you want to compile your own lib using LibManager, you should put a asterisk infrom of the code like :

* lds r24, {bSomeVar} ; load into r24 the content from the byte variable bSomeVar

This will leave the line as it is. This is required because when you compile the lib there is no reference to the variable. This variable exist only in your main program

The * will leave the line alone and it will be compiled during compilation of the main program.

What to save?

There is no need to save registers. You can trash them all.

When it is required to change RAMPZ you should protect the value. Then like with normal asm programming, there are some registers you should not alter like R4,R5,R6,R8-R9 and the Y pointer R28-R29.

---

## Assembler mnemonics

BASCOM supports the mnemonics as defined by Atmel.

The Assembler accepts mnemonic instructions from the instruction set.

A summary of the instruction set mnemonics and their parameters is given here. For a detailed description of the Instruction set, refer to the AVR Data Book.

Mnemonics | Operands | Description | Operation | Flags | Clock  
---|---|---|---|---|---  
ARITHMETIC AND LOGIC INSTRUCTIONS |  |  |  |  |   
ADD | Rd, Rr | Add without Carry | Rd = Rd + Rr | Z,C,N,V,H | 1  
ADC | Rd, Rr | Add with Carry | Rd = Rd + Rr + C | Z,C,N,V,H | 1  
SUB | Rd, Rr | Subtract without Carry | Rd = Rd â Rr | Z,C,N,V,H | 1  
SUBI | Rd, K | Subtract Immediate | Rd = Rd â K | Z,C,N,V,H | 1  
SBC | Rd, Rr | Subtract with Carry | Rd = Rd - Rr - C | Z,C,N,V,H | 1  
SBCI | Rd, K | Subtract Immediate with Carry | Rd = Rd - K - C | Z,C,N,V,H | 1  
AND | Rd, Rr | Logical AND | Rd = Rd Â· Rr | Z,N,V | 1  
ANDI | Rd, K | Logical AND with Immediate | Rd = Rd Â· K | Z,N,V | 1  
OR | Rd, Rr | Logical OR | Rd = Rd v Rr | Z,N,V | 1  
ORI | Rd, K | Logical OR with Immediate | Rd = Rd v K | Z,N,V | 1  
EOR | Rd, Rr | Exclusive OR | Rd = Rd Ã Rr | Z,N,V | 1  
COM | Rd | Ones Complement | Rd = $FF - Rd | Z,C,N,V | 1  
NEG | Rd | Twos Complement | Rd = $00 - Rd | Z,C,N,V,H | 1  
SBR | Rd,K | Set Bit(s) in Register | Rd = Rd v K | Z,N,V | 1  
CBR | Rd,K | Clear Bit(s) in Register | Rd = Rd Â· ($FFh - K) | Z,N,V | 1  
INC | Rd | Increment | Rd = Rd + 1 | Z,N,V | 1  
DEC | Rd | Decrement | Rd = Rd - 1 | Z,N,V | 1  
TST | Rd | Test for Zero or Minus | Rd = Rd Â· Rd | Z,N,V | 1  
CLR | Rd | Clear Register | Rd = Rd Ã Rd | Z,N,V | 1  
SER | Rd | Set Register | Rd = $FF | None | 1  
ADIW Adiw r24, K6 | Rdl, K6 | Add Immediate to Word | Rdh:Rdl = Rdh:Rdl + K | Z,C,N,V,S | 2  
SBIW Sbiw R24,K6 | Rdl, K6 | Subtract Immediate from Word | Rdh:Rdl = Rdh:Rdl - K | Z,C,N,V,S | 2  
MUL | Rd,Rr | Multiply Unsigned | R1, R0 = Rd * Rr | C | 2 *  
BRANCH INSTRUCTIONS |  |  |  |  |   
RJMP | K | Relative Jump | PC = PC + k + 1 | None | 2  
IJMP |  | Indirect Jump to (Z) | PC = Z | None | 2  
JMP | K | Jump | PC = k | None | 3  
RCALL | K | Relative Call Subroutine | PC = PC + k + 1 | None | 3  
ICALL |  | Indirect Call to (Z) | PC = Z | None | 3  
CALL | K | Call Subroutine | PC = k | None | 4  
RET |  | Subroutine Return | PC = STACK | None | 4  
RETI |  | Interrupt Return | PC = STACK | I | 4  
CPSE | Rd,Rr | Compare, Skip if Equal | if (Rd = Rr) PC = PC + 2 or 3 | None | 1 / 2  
CP | Rd,Rr | Compare | Rd - Rr | Z,C,N,V,H, | 1  
CPC | Rd,Rr | Compare with Carry | Rd - Rr - C | Z,C,N,V,H | 1  
CPI | Rd,K | Compare with Immediate | Rd - K | Z,C,N,V,H | 1  
SBRC | Rr, b | Skip if Bit in Register Cleared | If (Rr(b)=0) PC = PC + 2 or 3 | None | 1 / 2  
SBRS | Rr, b | Skip if Bit in Register Set | If (Rr(b)=1) PC = PC + 2 or 3 | None | 1 / 2  
SBIC | P, b | Skip if Bit in I/O Register Cleared | If(I/O(P,b)=0) PC = PC + 2 or 3 | None | 2 / 3  
SBIS | P, b | Skip if Bit in I/O Register Set | If(I/O(P,b)=1) PC = PC + 2 or 3 | None | 2 / 3  
BRBS | s, k | Branch if Status Flag Set | if (SREG(s) = 1) then PC=PC+k + 1 | None | 1 / 2  
BRBC | s, k | Branch if Status Flag Cleared | if (SREG(s) = 0) then PC=PC+k + 1 | None | 1 / 2  
BREQ | K | Branch if Equal | if (Z = 1) then PC = PC + k + 1 | None | 1 / 2  
BRNE | K | Branch if Not Equal | if (Z = 0) then PC = PC + k + 1 | None | 1 / 2  
BRCS | K | Branch if Carry Set | if (C = 1) then PC = PC + k + 1 | None | 1 / 2  
BRCC | K | Branch if Carry Cleared | if (C = 0) then PC = PC + k + 1 | None | 1 / 2  
BRSH | K | Branch if Same or Higher | if (C = 0) then PC = PC + k + 1 | None | 1 / 2  
BRLO | K | Branch if Lower | if (C = 1) then PC = PC + k + 1 | None | 1 / 2  
BRMI | K | Branch if Minus | if (N = 1) then PC = PC + k + 1 | None | 1 / 2  
BRPL | K | Branch if Plus | if (N = 0) then PC = PC + k + 1 | None | 1 / 2  
BRGE | K | Branch if Greater or Equal, Signed | if (N V= 0) then PC = PC+ k + 1 | None | 1 / 2  
BRLT | K | Branch if Less Than, Signed | if (N V= 1) then PC = PC + k + 1 | None | 1 / 2  
BRHS | K | Branch if Half Carry Flag Set | if (H = 1) then PC = PC + k + 1 | None | 1 / 2  
BRHC | K | Branch if Half Carry Flag Cleared | if (H = 0) then PC = PC + k + 1 | None | 1 / 2  
BRTS | K | Branch if T Flag Set | if (T = 1) then PC = PC + k + 1 | None | 1 / 2  
BRTC | K | Branch if T Flag Cleared | if (T = 0) then PC = PC + k + 1 | None | 1 / 2  
BRVS | K | Branch if Overflow Flag is Set | if (V = 1) then PC = PC + k + 1 | None | 1 / 2  
BRVC | K | Branch if Overflow Flag is Cleared | if (V = 0) then PC = PC + k + 1 | None | 1 / 2  
BRIE | K | Branch if Interrupt Enabled | if ( I = 1) then PC = PC + k + 1 | None | 1 / 2  
BRID | K | Branch if Interrupt Disabled | if ( I = 0) then PC = PC + k + 1 | None | 1 / 2  
DATA TRANSFER INSTRUCTIONS |  |  |  |  |   
MOV | Rd, Rr | Copy Register | Rd = Rr | None | 1  
LDI | Rd, K | Load Immediate | Rd = K | None | 1  
LDS | Rd, k | Load Direct | Rd = (k) | None | 2  
LD | Rd, X | Load Indirect | Rd = (X) | None | 2  
LD | Rd, X+ | Load Indirect and Post-Increment | Rd = (X), X = X + 1 | None | 2  
LD | Rd, -X | Load Indirect and Pre-Decrement | X = X - 1, Rd =(X) | None | 2  
LD | Rd, Y | Load Indirect | Rd = (Y) | None | 2  
LD | Rd, Y+ | Load Indirect and Post-Increment | Rd = (Y), Y = Y + 1 | None | 2  
LD | Rd, -Y | Load Indirect and Pre-Decrement | Y = Y - 1, Rd = (Y) | None | 2  
LDD | Rd,Y+q | Load Indirect with Displacement | Rd = (Y + q) | None | 2  
LD | Rd, Z | Load Indirect | Rd = (Z) | None | 2  
LD | Rd, Z+ | Load Indirect and Post-Increment | Rd = (Z), Z = Z+1 | None | 2  
LD | Rd, -Z | Load Indirect and Pre-Decrement | Z = Z - 1, Rd = (Z) | None | 2  
LDD | Rd, Z+q | Load Indirect with Displacement | Rd = (Z + q) | None | 2  
STS | k, Rr | Store Direct | (k) = Rr | None | 2  
ST | X, Rr | Store Indirect | (X) = Rr | None | 2  
ST | X+, Rr | Store Indirect and Post-Increment | (X) = Rr, X = X + 1 | None | 2  
ST | -X, Rr | Store Indirect and Pre-Decrement | X = X - 1, (X) = Rr | None | 2  
ST | Y, Rr | Store Indirect | (Y) = Rr | None | 2  
ST | Y+, Rr | Store Indirect and Post-Increment | (Y) = Rr, Y = Y + 1 | None | 2  
ST | -Y, Rr | Store Indirect and Pre-Decrement | Y = Y - 1, (Y) = Rr | None | 2  
STD | Y+q,Rr | Store Indirect with Displacement | (Y + q) = Rr | None | 2  
ST | Z, Rr | Store Indirect | (Z) = Rr | None | 2  
ST | Z+, Rr | Store Indirect and Post-Increment | (Z) = Rr, Z = Z + 1 | None | 2  
ST | -Z, Rr | Store Indirect and Pre-Decrement | Z = Z - 1, (Z) = Rr | None | 2  
STD | Z+q,Rr | Store Indirect with Displacement | (Z + q) = Rr | None | 2  
LPM |  | Load Program Memory | R0 =(Z) | None | 3  
IN | Rd, P | In Port | Rd = P | None | 1  
OUT | P, Rr | Out Port | P = Rr | None | 1  
PUSH | Rr | Push Register on Stack | STACK = Rr | None | 2  
POP | Rd | Pop Register from Stack | Rd = STACK | None | 2  
BIT AND BIT-TEST INSTRUCTIONS |  |  |  |  |   
LSL | Rd | Logical Shift Left | Rd(n+1) =Rd(n),Rd(0)= 0,C=Rd(7) | Z,C,N,V,H | 1  
LSR | Rd | Logical Shift Right | Rd(n) = Rd(n+1), Rd(7) =0, C=Rd(0) | Z,C,N,V | 1  
ROL | Rd | Rotate Left Through Carry | Rd(0) =C, Rd(n+1) =Rd(n),C=Rd(7) | Z,C,N,V,H | 1  
ROR | Rd | Rotate Right Through Carry | Rd(7) =C,Rd(n) =Rd(n+1),CÂ¬Rd(0) | Z,C,N,V | 1  
ASR | Rd | Arithmetic Shift Right | Rd(n) = Rd(n+1), n=0..6 | Z,C,N,V | 1  
SWAP | Rd | Swap Nibbles | Rd(3..0) Â« Rd(7..4) | None | 1  
BSET | S | Flag Set | SREG(s) = 1 | SREG(s) | 1  
BCLR | S | Flag Clear | SREG(s) = 0 | SREG(s) | 1  
SBI | P, b | Set Bit in I/O Register | I/O(P, b) = 1 | None | 2  
CBI | P, b | Clear Bit in I/O Register | I/O(P, b) = 0 | None | 2  
BST | Rr, b | Bit Store from Register to T | T = Rr(b) | T | 1  
BLD | Rd, b | Bit load from T to Register | Rd(b) = T | None | 1  
SEC |  | Set Carry | C = 1 | C | 1  
CLC |  | Clear Carry | C = 0 | C | 1  
SEN |  | Set Negative Flag | N = 1 | N | 1  
CLN |  | Clear Negative Flag | N = 0 | N | 1  
SEZ |  | Set Zero Flag | Z = 1 | Z | 1  
CLZ |  | Clear Zero Flag | Z = 0 | Z | 1  
SEI |  | Global Interrupt Enable | I = 1 | I | 1  
CLI |  | Global Interrupt Disable | I = 0 | I | 1  
SES |  | Set Signed Test Flag | S = 1 | S | 1  
CLS |  | Clear Signed Test Flag | S = 0 | S | 1  
SEV |  | Set Twos Complement Overflow | V = 1 | V | 1  
CLV |  | Clear Twos Complement Overflow | V = 0 | V | 1  
SET |  | Set T in SREG | T = 1 | T | 1  
CLT |  | Clear T in SREG | T = 0 | T | 1  
SHE |  | Set Half Carry Flag in SREG | H = 1 | H | 1  
CLH |  | Clear Half Carry Flag in SREG | H = 0 | H | 1  
NOP |  | No Operation |  | None | 1  
SLEEP |  | Sleep |  | None | 1  
WDR |  | Watchdog Reset |  | None | 1  
  
|  | XMEGA ONLY |  |   
|   
  
LAC |  | Load and clear RAM loc |  | None | 2  
LAT |  | Load and toggle RAM loc |  | None | 2  
LAS |  | Load and set RAM loc |  | None | 2  
XCH |  | Exchange RAM loc |  | None | 2  
  
* ) Not available in base-line microcontrollers

The Assembler is not case sensitive.

The operands have the following forms:

Rd: R0-R31 or R16-R31 (depending on instruction)

Rr: R0-R31

b: Constant (0-7)

s: Constant (0-7)

P: Constant (0-31/63)

K: Constant (0-255)

k: Constant, value range depending on instruction.

q: Constant (0-63)

Rdl: R24, R26, R28, R30. For ADIW and SBIW instructions

---

## AT86RF401

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![AT86RF401](at86rf401.jpg)

---

## AT90PWM2-3

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![at90pwm2_3_soic24](at90pwm2_3_soic24.png)

![at90pwm_2_3_soic32](at90pwm_2_3_soic32.png)

---

## AT90PWM216

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![at90pwm_216_316](at90pwm_216_316.jpg)

---

## AT90S1200

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![at90s1200](at90s1200.jpg)

---

## AT90S2313

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![2313](2313.gif)

The ATTiny2313 should be used for new designs.

---

## AT90S2323

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![2323](2323.gif)

---

## AT90S2333

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![2333_4433](2333_4433.gif)

---

## AT90S2343

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.  
  
![2343](2343.gif)

[tip from Martin Verschuren]

When using the AT90S2343 with BASCOM-AVR 1.11.6.4 and the STK200. Programming must be done with jumper ext-clk.

The BASCOM build in programmer will detect a Tiny22, which seems to have the same ID string as the 2343 (Atmel source) so no wonder.

By using the internal clock RCEN=0, then the jumper of the STK200 must be on int.clk after programming.

Don't leave this away, some AT90S2343 will not correctly startup.

In your own project notice that you have to pull up the clk pin(2) at power up else it won't work. (I just looked for it for a day to get this problem solved:-)

Note : the at90s2343 and tiny22 have the same chip ID. In BASCOM you need to choose the tiny22 even if you use the 2343.

I note from MCS : only the AT23LS43-1 has the internal oscillator programmed by default! All other 2343 chips need an external clock signal. Tip: use a AT90S2313 and connect X2 to the clock input of the 2343.

[tip from David Chambers]

Using the AT90S2343 with BASCOM 1.11.7.3 the DT006 hardware there are no problems with programming the chip ie no special jumper conditions to enable programming. However it is best to remove links connecting ports to the DT006 LEDâs before programming. If access to PB3 and PB4 is desired then jumpers J11 & J12 must be installed with pins 2 and 3 linked in both cases. Note that PB3 and PB4 are each connected to a momentary pushbutton on the DT006 board. These can be used to check contact closure functions, so bear this in mind when writing code for contact monitoring.

The current ATMEL data sheet specifies that all versions â1, -4 and â10 are supplied with a fuse bit set for the internal clock that operates at approximately 1Mhz. If using the internal clock make sure to enter 1000000 under Options\Compiler\Communication\frequency.

A great little chip with minimal external components. Only the resistor and capacitor required for RESET during power up.

Note that the LEDâs on the DT006 are not connected to the same programmed port pins when changing the chip type. This is because the special functions assigned ports varies between the 8pin, 20 pin and 28 pin products eg the MOSI, MISI and SCK functions are assigned to PB0, PB1 and PB2 for an 8 pin processor and PB5, PB6 and PB7 for a 20 pin processor. The result is that for a given program the LEDâs that respond are different.

---

## AT90S4414

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![90S4414](90s4414.jpg)

---

## AT90S4433

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![2333_4433](2333_4433.gif)

---

## AT90S4434

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![4434_8535](4434_8535.gif)

---

## AT90S8515

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![90S4414](90s4414.jpg)

---

## AT90S8535

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![4434_8535](4434_8535.gif)

---

## AT90US82

The USB82 is supported by the optional USB Add On. PORTC.4 is used to sense the power of the USB bus.

![at90usb_82_162](at90usb_82_162.png)

---

## AT_EMULATOR

The PS2 AT Keyboard emulator library is an optional add on library you can [purchase](<http://www.mcselec.com/index.php?page=shop.product_details&flypage=shop.flypage&product_id=35&category_id=6&option=com_phpshop&Itemid=1>).

The library allows you to emulate an AT PS/2 keyboard or mouse.

The following statements become available:

[CONFIG ATEMU](config_atemu.md)

[SENDSCANKBD](sendscankbd.md)

---

## ATMEGA103

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![image181352516](image181352516.jpg)

---

## ATMEGA128

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![128](128.gif)

\- When using XRAM and IDLE, the micro need the CONFIG XRAM after returing from the power down mode.

\- The register mapping for PORTF is not in sequence. Which means that PINF, DDRF and PORTF are not placed in memory after each other. This has some impact on some of the functions that use the ability. 1wire and soft i2c for example. But also serin will not work. It is best to use PORTF for normal digital tasks.

---

## ATMEGA1280

![m1280_2560](m1280_2560.png)

---

## ATMEGA1281

![m1281_2561](m1281_2561.png)

---

## ATMEGA1284

![m1284p](m1284p.png)

The M1284 seems to have an internal problem where large amounts of serial data can choke the processor.

A capacitor of 100pF on the RX pin to ground can solve this problem.

More info : [http://www.mcselec.com/index2.php?option=com_forum&Itemid=59&page=viewtopic&p=60860#60860](<http://www.mcselec.com/index2.php?option=com_forum&Itemid=59&page=viewtopic&p=60860#60860>)

PORTC is connected to AVCC and not VCC. This can cause the brown out detection to trigger.

---

## ATMEGA1284P

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m1284p](m1284p.png)

The M1284 seems to have an internal problem where large amounts of serial data can choke the processor.

A capacitor of 100pF on the RX pin to ground can solve this problem.

More info : [http://www.mcselec.com/index2.php?option=com_forum&Itemid=59&page=viewtopic&p=60860#60860](<http://www.mcselec.com/index2.php?option=com_forum&Itemid=59&page=viewtopic&p=60860#60860>)

---

## ATMEGA128RFA1

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atnega128rfa1](atnega128rfa1.png)

---

## ATMEGA16

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega16](atmega16.jpg)

---

## ATMEGA1608

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) and [MEGAX](megax.md).

The ATMEGA1680 comes in different casings. It has 16KB of flash and a maximum of 32 pins. 

The ATMEGA1609 has more pins : 40 and 48

![mega808_ssop28](mega808_ssop28.png)

VQFN/TQFP 32

![mega808_tqfp32](mega808_tqfp32.png)

---

## ATMEGA161

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![161](161.gif)

---

## ATMEGA162

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![image1118913073](image1118913073.jpg)

The M162 has a clock-16 divider enabled by default. See the M162.bas sample file

---

## ATMEGA163

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega163](atmega163.jpg)

The M163 by default uses the internal clock running at 1 MHz

When you have problems with timing set the right fuse bit A987= 0101. This will solve this problem.

I have just found a small difference in PortB when using the Mega163 in place of a 8535. The difference is in regard to PortB.4 - PortB.7 when not used as a SPI

interface. The four upper bits of PortB are shared with the hardware SPI unit.

If the SPI is configured in SLAVE mode (DEFAULT) the MOSI , SCK , /SS

Are configured as inputs, Regardless of the DDRB setting !

The /SS (slave select) pin also has restrictions on it when using it as a general input.- see data sheet ATmega163 - p57.

This sample allows you to use the upper nibble of PortB as outputs.

Portb = &B0000_0000

DDRB = &B1111_0000 'set upper bits for output.

Spcr = &B0001_0000 ' set SPI to Master and Disable.

If The SPCR register is not set for Master, you cannot set the pins for

Output.

---

## ATMEGA164P

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

While the data sheet might make you believe this processor has a TIMER3, there is NO TIMER3 in the MEGA164.

You need a MEGA1284 when you need a TIMER3.

![atmega164p_324p_644p](atmega164p_324p_644p.png)

---

## ATMEGA164PA

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

While the data sheet might make you believe this processor has a TIMER3, there is NO TIMER3 in the MEGA164.

You need a MEGA1284 when you need a TIMER3.

![atmega164p_324p_644p](atmega164p_324p_644p.png)

---

## ATMEGA165

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![mega165](mega165.png)

---

## ATMEGA165A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega165a](atmega165a.png)

---

## ATMEGA168

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m48_88_168](m48_88_168.png)

---

## ATMEGA168P

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m48_88_168_328P](m48_88_168_328p.png)

---

## ATMEGA168PB

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega48pb_88pb_168pb](atmega48pb_88pb_168pb.png)

NO DIP version available

---

## ATMEGA169

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m169](m169.png)

---

## ATMEGA169P

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m169](m169.png)

---

## ATMEGA169PA

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m169](m169.png)

---

## ATMEGA16A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega16](atmega16.jpg)

---

## ATMEGA16M1

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![ATMEGA16M1_32M1_64M1](atmega16m1_32m1_64m1.png)

---

## ATMEGA16U2

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega8u2_16u2_32u2](atmega8u2_16u2_32u2.png)

---

## ATMEGA16U4

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega16U_32U](atmega16u_32u.png)

---

## ATMEGA2560

![m1280_2560](m1280_2560.png)

---

## ATMEGA2561

![m1281_2561](m1281_2561.png)

---

## ATMEGA32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m32](m32.png)

---

## ATMEGA3208

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) and [MEGAX](megax.md).

The ATMEGA3280 comes in different casings. It has 32KB of flash and a maximum of 32 pins. 

The ATMEGA3209 has more pins : 40 and 48

![mega808_ssop28](mega808_ssop28.png)

VQFN/TQFP 32

![mega808_tqfp32](mega808_tqfp32.png)

---

## ATMEGA323

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![323](323.gif)

The JTAG interface is enabled by default. This means that portC.2-portC.5 pins can not be used. Program the JTAG fuse bit to disable the JTAG interface.

---

## ATMEGA324A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega164p_324p_644p](atmega164p_324p_644p.png)

---

## ATMEGA324P

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega164p_324p_644p](atmega164p_324p_644p.png)

---

## ATMEGA324PA

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega164p_324p_644p](atmega164p_324p_644p.png)

---

## ATMEGA324PB

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m324pb](m324pb.png).

There is a bug in the chip : When you configure the second UART, the timer1 channel B will not work.

This info came from microchip :

Yes, your observation is correct. It is a known device bug. We already 

report this bug to our concern team.

This is due to the fact that timer 1 channel B is shared with XCK1 pin 

of UART1

Usually this functionality should take priority over timer 1 channel B 

only when UART is configured in Synchronous mode but after discussing 

with our internal team confirmed that timer 1 channel B is 

disconnected based on UART1 activation

No matter even if the UART is configured in Asynchronous mode(in which 

case there is no use of XCK1) timer 1 channel B still gets disconnected.

This issue also presents in UART2 XCK2/OC2A.

---

## ATMEGA325

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega325_645](atmega325_645.png)

---

## ATMEGA3250P

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega325p_3250p](atmega325p_3250p.png)

---

## ATMEGA328

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m48_88_168](m48_88_168.png)

---

## ATMEGA328P

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m48_88_168](m48_88_168.png)

---

## ATMEGA328PB

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m328PB](m328pb.png)

Notice that this processor is compatible with M328 but that extra pins have been added at location of VCC/GND.

---

## ATMEGA329

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega329_649](atmega329_649.png)

---

## ATMEGA32A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega32A](atmega32a.png)

---

## ATMEGA32C1

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![ATMEGA16M1_32M1_64M1](atmega16m1_32m1_64m1.png)

---

## ATMEGA32M1

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![ATMEGA16M1_32M1_64M1](atmega16m1_32m1_64m1.png)

\- FOR ISP programming, notice that pin PD.2, PD.3 and PD4 are used.

---

## ATMEGA32U2

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega8u2_16u2_32u2](atmega8u2_16u2_32u2.png)

---

## ATMEGA32U4

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega16U_32U](atmega16u_32u.png)

---

## ATMEGA406

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

The image is from a preliminary data sheet. It is not clear yet if SCL and SDA have pin names too. 

This chip can only programmed parallel and with JTAG. Normal (serial) ISP programming is not available.

![atmega406](atmega406.png)

---

## ATMEGA48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.  
  
![m48_88_168](m48_88_168.png)

---

## ATMEGA4808

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) and [MEGAX](megax.md).

The ATMEGA4808 comes in VQFN and TQFP. It has 48KB of flash and 32 pins. 

The ATMEGA4808 also comes in SSOP. It has 48KB of flash and 28 pins. 

![4808_SSOP28](4808_ssop28.png)

![4808_vqfn_tqfp_32](4808_vqfn_tqfp_32.png)

---

## ATMEGA48P-ATMEGA48PA

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m48_88_168_328P](m48_88_168_328p.png)

---

## ATMEGA48PB

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega48pb_88pb_168pb](atmega48pb_88pb_168pb.png)

NO DIP version available

---

## ATMEGA603

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

When you have a better image available, please send it to support@mcselec.com

![603_103](603_103.gif)

---

## ATMEGA64

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega64](atmega64.jpg)

---

## ATMEGA640

![m1280_2560](m1280_2560.png).

---

## ATMEGA644

![atmega644](atmega644.png)

---

## ATMEGA644P

Notice that there are Mega644 and Mega644P chips.

P stand for PICO power. You should use the P-version for new designs.

These Pico version usual add some functionality such as a second UART.

![atmega164p_324p_644p](atmega164p_324p_644p.png)

---

## ATMEGA644PA

Notice that there are Mega644 and Mega644P chips.

P stand for PICO power. You should use the P-version for new designs.

These Pico version usual add some functionality such as a second UART.

![atmega164p_324p_644p](atmega164p_324p_644p.png)

---

## ATMEGA645

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega325_645](atmega325_645.png)

---

## ATMEGA6450P

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega325p_3250p](atmega325p_3250p.png)

---

## ATMEGA649

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega329_649](atmega329_649.png)

---

## ATMEGA649PA

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m169](m169.png)

---

## ATMEGA64C1

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![ATMEGA16M1_32M1_64M1](atmega16m1_32m1_64m1.png)

---

## ATMEGA64M1

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![ATMEGA16M1_32M1_64M1](atmega16m1_32m1_64m1.png)

---

## ATMEGA8

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![8M](8m.gif)

---

## ATMEGA808

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) and [MEGAX](megax.md).

The ATMEGA808 comes in different casings. It has 8KB of flash and a maximum of 32 pins. 

The ATMEGA809 has more pins : 40 and 48

![mega808_ssop28](mega808_ssop28.png)

VQFN/TQFP 32

![mega808_tqfp32](mega808_tqfp32.png)

---

## ATMEGA8515

![atmega8515](atmega8515.jpg)

---

## ATMEGA8535

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega8535](atmega8535.png)

---

## ATMEGA88

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m48_88_168](m48_88_168.png)

---

## ATMEGA88A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.  
  
![m48_88_168](m48_88_168.png)

---

## ATMEGA88P-ATMEGA88PA

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![m48_88_168_328P](m48_88_168_328p.png)

---

## ATMEGA88PB

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega48pb_88pb_168pb](atmega48pb_88pb_168pb.png)

NO DIP version available

---

## ATMEGA8A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![8M](8m.gif)

---

## ATMEGA8U2

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![atmega8u2_16u2_32u2](atmega8u2_16u2_32u2.png)

---

## ATN

Action

Returns the Arctangent of a floating point variable in radians.

Syntax

var = ATN( float )

Remarks

Var | A float variable that is assigned with the arctangent of variable float.  
---|---  
float | The float variable to get the arctangent of.   
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

Floating point variables can be of the single or double data type.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [COS](cos.md) , [SIN](sin.md) , [TAN](tan.md) , [ATN2](atn2.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As Single , X As Single

```
S = Atn(1) * 4

```vb
Print S ' prints 3.141593 PI

End

```

---

## ATN2

Action

ATN2 is a four-quadrant arc-tangent.

While the ATN-function returns from -p/2 (-90Â°) to p/2 (90Â°), the ATN2 function returns the whole range of a circle from -p (-180Â°) to +p (180Â°). The result depends on the ratio of Y/X and the signs of X and Y.

Syntax

var = ATN2( y, x )

Remarks

Var | A floating point variable that is assigned with the ATN2 of variable y and x.  
---|---  
X | The float variable with the distance in x-direction.  
Y | The float variable with the distance in y-direction  
  
![atn2](atn2.gif)

Quadrant | Sign Y | Sign X | ATN2  
---|---|---|---  
I | + | + | 0 to p/2  
II | + | - | p/2 to p  
III | - | - | -p/2 to -p  
IV | - | + | 0 to âp/2  
  
If you go with the ratio Y/X into ATN you will get same result for X greater zero (right side in coordinate system) as with ATN2. ATN2 uses X and Y and can give information of the angle of the point over 360Â° in the coordinates system.

All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [COS](cos.md) , [SIN](sin.md) , [TAN](tan.md) , [ATN](atn.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As Single , X As Single

```
X = 0.5 : S = 1.1

S = Atn2(s , X)

```vb
Print S ' prints 1.144164676

End

```

---

## ATTINY12

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![12](12.gif)

---

## ATTINY13

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![tiny13](tiny13.png)

---

## ATTINY13A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![tiny13](tiny13.png)

---

## ATTINY15

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![15](15.gif)

---

## ATTINY1634

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny1634](attiny1634.png)

---

## ATTINY167

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny87_167](attiny87_167.jpg)

The TINY167/87 have a special LIN/UART. In version 2077 this UART is supported in normal mode. Buffered input/output is not supported.

---

## ATTINY20

The ATTINY20 is a 14 pins AVR chip. It has NO EEPROM. It also does not have a UART.

The TWI slave interface is not compatible with TWI found in other AVR chips.

The chip has a PDI programming interface and does not support ISP or JTAG.

The watchdog is also different compared to other AVR chips. It is using a CCP register which is similar as the Xmega.

The processor also only has 16 registers (R16-R31) and is missing registers R0-R15.

This does not make the chip a good choice for using with BASCOM since BASCOM uses the lower registers as well.

![attiny20](attiny20.png)

---

## ATTINY22

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![22](22.gif)

---

## ATTINY2313

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![tiny2313](tiny2313.zoom80.png)

The tiny2313 has an internal oscillator that can run at various frequencies. The 4 MHz seems not to work precise. when using the UART for serial communication you can get wrong output. You can best use the 8 MHz internal oscillator , or tweak the UBRR register. For example, UBRR=UBRR+1

That worked for 4 Mhz, at 19200 baud.

---

## ATTINY2313A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny2313A_4313A](attiny2313a_4313a.png)

---

## ATTINY24

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny24_44_84](attiny24_44_84.png)

The data sheet does not specify that HWMUL is supported. The DAT file reflect this :

HWMUL=0 ; this chip does not have hardware multiplication

Some users reported that the HWMUL did work. Some batches might support the HW MUL, but since we found chips that did not, the value is set to 0. You can change it at your own risk.

---

## ATTINY25

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![tiny25-45-85](tiny25-45-85.png)

---

## ATTINY26

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![tiny26](tiny26.png)

---

## ATTINY261

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny261_461_861](attiny261_461_861.png)

---

## ATTINY4313

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![tiny2313](tiny2313.zoom80.png)

The tiny4313 has an internal oscillator that can run at various frequencies. The 4 MHz seems not to work precise. when using the UART for serial communication you can get wrong output. You can best use the 8 MHz internal oscillator , or tweak the UBRR register. For example, UBRR=UBRR+1

That worked for 4 Mhz, at 19200 baud.

---

## ATTINY4313A

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny2313A_4313A](attiny2313a_4313a.png)

---

## ATTINY43U

![attiny43u](attiny43u.png)

---

## ATTINY44

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny24_44_84](attiny24_44_84.png)

The data sheet does not specify that HWMUL is supported. The DAT file reflect this :

HWMUL=0 ; this chip does not have hardware multiplication

Some users reported that the HWMUL did work. Some batches might support the HW MUL, but since we found chips that did not, the value is set to 0. You can change it at your own risk.

---

## ATTINY441

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

The Tiny441 has 256 bytes of EEPROM memory.

Usually this means that the high byte EEPROM address register is missing since it has no purpose.

The tiny441 however has an EEARH register. And it seems to cause problems.

The data sheet says :

Devices with 256 bytes of EEPROM, or less, do not require a high address registers (EEARH). In such devices the high

address register is therefore left out but, for compatibility issues, the remaining register is still referred to as the low byte

of the EEPROM address register (EEARL).

Devices that to do not fill an entire address byte, i.e. devices with an EEPROM size not equal to 256, implement readonly

bits in the unused locations. Unused bits are located in the most significant end of the address register and they

always read zero.

The bascom write/read EEPROM code checks if the EEPROM size > 256\. If that is the case, the EEARH is addressed.

But in this case this register is not touched. 

When you have problems, set EEARH register to 0 in your code.

While we could always write this register, it is a waste of code. 

When having problems contact support. 

![attiny441_841](attiny441_841.png)

---

## ATTINY45

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![tiny25-45-85](tiny25-45-85.png)

---

## ATTINY461

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny261_461_861](attiny261_461_861.png)

The processor has only one PCINT interrupt. But there are two PCINT interrupt masks to serve all the PCINTx pins. Most processors have their own interrupt for each PCINT mask register so you have better control over the different pins which caused the interrupt.

Since there is only one interrupt, the [ENABLE](enable.md) and [DISABLE](disable.md) statements, set/reset both the PCIE0 and PCIE1 flags in the GIMSK register. You still have to set the PCMSK0 and PCMSK1 registers to specify which bits can cause a PCINT interrupt.

---

## ATTINY48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Notice that the TINY48 is NOT the same as the MEGA48. The TINY48 does not have a UART.

![attiny44_88](attiny44_88.png)

---

## ATTINY828

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny828](attiny828.png)

---

## ATTINY84

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny24_44_84](attiny24_44_84.png)

The data sheet does not specify that HWMUL is supported. The DAT file reflect this :

HWMUL=0 ; this chip does not have hardware multiplication

Some users reported that the HWMUL did work. Some batches might support the HW MUL, but since we found chips that did not, the value is set to 0. You can change it at your own risk.

---

## ATTINY841

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny441_841](attiny441_841.png)

---

## ATTINY85

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![tiny25-45-85](tiny25-45-85.png)

---

## ATTINY861

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny261_461_861](attiny261_461_861.png)

The processor has only one PCINT interrupt. But there are two PCINT interrupt masks to serve all the PCINTx pins. Most processors have their own interrupt for each PCINT mask register so you have better control over the different pins which caused the interrupt.

Since there is only one interrupt, the [ENABLE](enable.md) and [DISABLE](disable.md) statements, set/reset both the PCIE0 and PCIE1 flags in the GIMSK register. You still have to set the PCMSK0 and PCMSK1 registers to specify which bits can cause a PCINT interrupt.

---

## ATTINY87

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

![attiny87_167](attiny87_167.jpg)

The TINY167/87 have a special LIN/UART. In version 2077 this UART is supported in normal mode. Buffered input/output is not supported.

---

## ATTINY88

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Notice that the TINY88 is NOT the same as the MEGA88. The TINY88 does not have a UART.

![attiny44_88](attiny44_88.png)

---

## AVR

This topic describes some general hardware related problems that were found by users.

Unexpected brown out

\- Processors with analog ports (used for A/D) are connected to AVCC and not VCC. This can cause the brown out detection to trigger. For example this is true for the Mega1284 PORTC. Using the ports to switch a small load would trigger the brown out while using a different port, powered from VCC would not give this problem. 

Errata

The Errata you will find in the data sheet of the processor. It contains information about bugs in the hardware. Some times there are work around's, and some times there is no solution. It is a good idea to read the Errata BEFORE you begin to use the processor for a new design.

---

## AVR ISP Programmer

The AVRISP programmer is AVR ICP910 based on the AVR910.ASM application note.

The old ICP910 does not support Mega chips. Only a modified version of the AVR910.ASM supports Universal commands so all chips can be programmed.

The new AVRISP from Atmel that can be used with AVR Studio, is not compatible! You need to select [STK500 programmer](stk500_programmer.md) because the new AVRISP programmer from Atmel, uses the STK500 protocol.

When you do not want to use the default baud rate that AVR910 is using, you can edit the file bascavr.ini from the Windows directory.

Add the section [AVRISP]

Then add: COM=19200,n,8,1

This is the default. When you made your own dongle, you can increase the baud rate

You need to save the file and restart BASCOM before the settings will be in effect.

![avr-isp](avr-isp.png)

This programmer is not available from Atmel/Microchip and is not recommended.

---

## AVR128DA28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR128DA28 comes in 28 pins SPDIP, SSOP and SOIC. It has 128KB of flash and 28 pins.

The PDIP is ideal for hobbyists. The difference with the DB series is that there is no MVIO (multi voltage IO). 

![avr128da28](avr128da28.png)

---

## AVR128DA32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR128DA32 comes in 32 pins VQFN and TQFP. It has 128KB of flash and 32 pins.

The difference with the DB series is that there is no MVIO (multi voltage IO). 

![avr128da32](avr128da32.png)

---

## AVR128DA48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR128DA48 comes in 48 pins VQFN and TQFP. It has 128KB of flash and 48 pins.

The difference with the DB series is that there is no MVIO (multi voltage IO). 

![avr128da48](avr128da48.png)

---

## AVR128DA64

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR128DA64 comes in TQFP and VQFN. It has 128KB of flash and a maximum of 64 pins. It has 8KB SRAM and 512 bytes EEPROM. 

![avr64da64](avr64da64.png)

---

## AVR128DB32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVRDB128DB32 comes in 32 pin VQFN and TQFP. It has 128KB of flash and 32 pins. 

![AVR128DB32](avr128db32.png)

---

## AVR128DB48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVRDB128DB48 comes in 48 pin VQFN and TQFP. It has 128KB of flash and 48 pins. 

![AVR128db48](avr128db48.png)

---

## AVR16DD14

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR16DD14 comes in SOIC-14. It has 16KB of flash and 14 pins. It has 2KB SRAM and 256 bytes EEPROM.

![AVR32DD14](avr32dd14.png)

---

## AVR16DD20

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR16DD20 comes in SOIC-20 and VQFN20. It has 16KB of flash and 20 pins. It has 2KB SRAM and 256 bytes EEPROM.

![avr16dd20](avr16dd20.png)

![avrdd20_vqfn](avrdd20_vqfn.png)

---

## AVR16DD28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR16DD28 comes as SPDIP, SSDOP, SOIC and VQFN. It has 16KB of flash, 2KB SRAM and 256 bytes EEPROM.

![AVR64DD28](avr64dd28.png)

![avrdd28_vqfn](avrdd28_vqfn.png)

---

## AVR16DD32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR16DD32 comes as VQFN and TQFP. It has 16KB of flash, 2KB SRAM and 256 bytes EEPROM.

![avrdd32](avrdd32.png)

---

## AVR16EA28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR16EA28 comes as SPDIP, SSOP and VQFN. It has 16KB of flash, 2KB SRAM and 512 bytes EEPROM.

![avrEA28](avrea28.png)

![avrea28-vqfn](avrea28-vqfn.png)

---

## AVR16EA32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR16EA32 comes as VQFN and TQFP. It has 16KB of flash, 2KB SRAM and 512 bytes EEPROM.

![avrEA-vqfn32](avrea-vqfn32.png)

---

## AVR16EA48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR16EA48 comes as VQFN and TQFP. It has 16KB of flash, 2KB SRAM and 512 bytes EEPROM.

![avrEA-vqfn48](avrea-vqfn48.png)

---

## AVR32DA28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DA28 comes in SPDIP, SSOP and SOIC. It has 32KB of flash and a maximum of 48 pins. Internal SRAM size is 4KB with 512 bytes EEPROM

![avrDA32](avrda32.png)

---

## AVR32DA32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DA32 comes in VQFN and TQFP. It has 32KB of flash and a maximum of 48 pins. Internal SRAM size is 4KB with 512 bytes EEPROM

.![avrDA32vqfn](avrda32vqfn.png)

---

## AVR32DA48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DA48 comes in TQFP and VQFN. It has 32KB of flash and a maximum of 48 pins. Internal SRAM size is 4KB with 512 bytes EEPROM

![AVR32DA48](avr32da48.png)

---

## AVR32DB28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DB28 comes in SSOP, SOIC and SPDIP. It has 32KB of flash and 28 pins. Internal SRAM size is 4KB with 512 bytes EEPROM

![avrDB28](avrdb28.png)

---

## AVR32DB32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DB32 comes in VQFN and TQFP. It has 32KB of flash and 32 pins. Internal SRAM size is 4KB with 512 bytes EEPROM

![avrDB32-vqfn](avrdb32-vqfn.png)

---

## AVR32DB48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DB48 comes in TQFP and VQFN. It has 32KB of flash and 32 pins. Internal SRAM size is 4KB with 512 bytes EEPROM

![AVR32DB48](avr32db48.png)

---

## AVR32DD14

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DD14 comes in SOIC-14. It has 32KB of flash and 14 pins. It has 4KB SRAM and 256 bytes EEPROM.

![AVR32DD14](avr32dd14.png)

---

## AVR32DD20

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DD20 comes in SOIC and VQFN. It has 32KB of flash and 20 pins. It has 4KB SRAM and 256 bytes EEPROM.

![avr16dd20](avr16dd20.png)

![avr32dd20vqfn](avr32dd20vqfn.png)

---

## AVR32DD28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DD28 comes in SPDIP, SSOP, SOIC and VQFN. It has 32KB of flash and 28 pins. It has 4KB SRAM and 256 bytes EEPROM.

![avrDD28](avrdd28.png)

![avr32dd28vqfn](avr32dd28vqfn.png)

---

## AVR32DD32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32DD32 comes in VQFN and TQFP. It has 32KB of flash and 32 pins. It has 4KB SRAM and 256 bytes EEPROM.

![avr32dd32vqfn](avr32dd32vqfn.png)

---

## AVR32EA28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32EA28 comes in SPDIP, SSOP and VQFN. It has 32KB of flash and 28 pins. It has 4KB SRAM and 512 bytes EEPROM.

![avrEA28](avrea28.png)

![avrea28-vqfn](avrea28-vqfn.png)

---

## AVR32EA32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32EA32 comes in VQFN and TQFP. It has 32KB of flash and 32 pins. It has 4KB SRAM and 512 bytes EEPROM.

![avrEA-vqfn32](avrea-vqfn32.png)

---

## AVR32EA48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR32EA48 comes as VQFN and TQFP. It has 32KB of flash, 4KB SRAM and 512 bytes EEPROM.

![avrEA-vqfn48](avrea-vqfn48.png)

---

## AVR64DA28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DA28 comes in 28 pin SPDIP, SSOP and SOIC. It has 64KB of flash and 28 pins. The SRAM size is 8KB and EEPROM 512 bytes

![AVR64DA28](avr64da28.png)

---

## AVR64DA32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DA32 comes in 32 pin VQFN and TQFP. It has 64KB of flash and 32 pins. The SRAM size is 8KB and EEPROM 512 bytes

![avr128da32](avr128da32.png)

---

## AVR64DA48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DA48 comes in 48 pins VQFN and TQFP. It has 64KB of flash and 48 pins. 8KB SRAM and 512 bytes EEPROM.

The difference with the DB series is that there is no MVIO (multi voltage IO). 

![avr128da48](avr128da48.png)

---

## AVR64DA64

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DA64 comes in TQFP and VQFN. It has 64KB of flash and a maximum of 64 pins. It has 8KB SRAM and 512 bytes EEPROM. 

![avr64da64](avr64da64.png)

---

## AVR64DB28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DB28 comes in SSOP, SOIC and SPDIP. It has 64KB of flash, 8KB SRAM and 512 bytes EEPROM

![avr64DB28](avr64db28.png)

---

## AVR64DB32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DB32 comes in TQFP and VQFN. It has 64KB of flash, 8 KB SRAM and 512 bytes EEPROM

![AVR128DB32](avr128db32.png)

---

## AVR64DB48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DB48 comes in TQFP and VQFN. It has 64KB of flash, 8 KB SRAM and 512 bytes EEPROM

![AVR64DB48](avr64db48.png)

---

## AVR64DB64

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DB64 comes in 64 TQFP and VQFN. It has 64KB of flash, 8KB of SRAM and 512 bytes EEPROM. 

![AVR64DB64](avr64db64.png)

---

## AVR64DD14

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DD14 comes in SOIC. It has 64KB of flash, 8KB SRAM and 256 bytes EEPROM.

![AVR32DD14](avr32dd14.png)

---

## AVR64DD20

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DD20 comes in SOIC and VQFN. It has 64KB of flash and 20 pins. It has 8KB SRAM and 256 bytes EEPROM.

![avr16dd20](avr16dd20.png)

![avr32dd20vqfn](avr32dd20vqfn.png)

---

## AVR64DD28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DD28 comes SPDIP, SSDOP and SOIC. It has 64KB of flash, 8KB SRAM and 256 bytes EEPROM.

![AVR64DD28](avr64dd28.png)

![avr32dd28vqfn](avr32dd28vqfn.png)

---

## AVR64DD32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64DD32 comes in VQFN and TQFP. It has 64KB of flash and 32 pins. It has 8KB SRAM and 256 bytes EEPROM.

![avr32dd32vqfn](avr32dd32vqfn.png)

---

## AVR64EA28

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64EA28 comes in SPDIP, SSOP and VQFN. It has 64KB of flash and 28 pins. It has 6KB SRAM and 512 bytes EEPROM.

![avrEA28](avrea28.png)

![avrea28-vqfn](avrea28-vqfn.png)

---

## AVR64EA32

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64EA32 comes in VQFN and TQFP. It has 64KB of flash and 32 pins. It has 6KB SRAM and 512 bytes EEPROM.

![avrEA-vqfn32](avrea-vqfn32.png)

---

## AVR64EA48

This page is intended to show the outline of the chip and to provide additional information that might not be clear from the data sheet.

Read the generic info about [Xtiny](xtiny.md) , [MEGAX](megax.md) and [AVRX](avrx.md)

The AVR64EA48 comes as VQFN and TQFP. It has 64KB of flash, 8KB SRAM and 512 bytes EEPROM.

![avrEA-vqfn48](avrea-vqfn48.png)

---

## BASCOM Editor Keys

Key | Action  
---|---  
LEFT ARROW | One character to the left  
RIGHT ARROW | One character to the right  
UP ARROW | One line up  
DOWN ARROW | One line down  
HOME | To the beginning of a line  
END | To the end of a line  
PAGE UP | Up one window  
PAGE DOWN | Down one window  
CTRL+LEFT | One word to the left  
CTRL+RIGHT | One word to the right  
CTRL+HOME | To the start of the text  
CTRL+END | To the end of the text  
CTRL+ Y | Delete current line  
INS | Toggles insert/over strike mode  
F1 | Help (context sensitive)  
F2 | Run simulator  
F3 | Find next text  
F4 | Send to chip (run flash programmer)  
F5 | Run  
F7 | Compile File  
F8 | Step  
F9 | Set breakpoint  
F10 | Run to  
F11 | Collapse Code Toggle Sub/Function  
SHIFT+F11 or CTRL+ENTER | Collapse Code Toggle current block  
CTRL+F7 | Syntax Check  
CTRL+F | Find text  
CTRL+G | Go to line  
CTRL+K+x | Toggle bookmark. X can be 1-8  
CTRL+L | LCD Designer  
CTRL+M | File Simulation  
CTRL+N | New File  
CTRL+O | Load File  
CTRL+P | Print File  
CTRL+Q+x | Go to Bookmark. X can be 1-8  
CTRL+R | Replace text  
CTRL+S | Save File  
CTRL+T | Terminal emulator  
CTRL+P | Compiler Options  
CTRL+W | Show result of compilation  
CTRL+X | Cut selected text to clipboard  
CTRL+Z | Undo last modification  
SHIFT+CTRL+Z | Redo last undo  
CTRL+INS | Copy selected text to clipboard  
SHIFT+INS | Copy text from clipboard to editor  
CTRL+SHIFT+J | Indent Block  
CTRL+SHIFT+U | Unindent Block  
Select text | Hold the SHIFT key down and use the cursor keys to select text. or keep the left mouse key pressed and drag the cursor over the text to select.  
CTRL+SPACE | Code help.   
SHIFT + MOUSE | Hover on indention lines to see to which group they belong. Hover on an element in your code to get info about that element.  
CTRL+BACKSPACE | Jump back  
CTRL+CLICK | Hold the CTRL key down and hover with the mouse till an element is underlined like an URL. Click the left mouse to jump to the implementation.

---

## BASCOMP

BASCOMP.EXE is a command line compiler utility.

It can be called from your own favorite editor when using linux. Or when compiling projects from a batch file.

The bascomp.exe utility must be placed in the same folder as bascavr.exe.

It depends on the bascom-avr license dll and the basc-avr.dll compiler DLL.

It also depends on the DAT files and the LIB folder with the libraries.

For this reason the files is best placed into the bascom-avr application folder.

Change in 2085

The utility used to work by passing the chip ID. But since some processors are binary compatible and share the same ID this could result in problems.

bascomp requires only one parameter : the source file you want to compile. When the path contains spaces you need to enclose it in double quotes.

Example : bascomp "c:\some folder\mycode example.bas"

bascomp will read the source and extract info about the dat file and stack. Specifically it will look for $regfile, $hwstack,$swstack and $framesize

If these settings are not found you need to provide them using SS for $softstack, HW for $hwstack and FR for $framesize

Example : bascomp "myfile.bas" HW=64

This would use a $hwstack of 64 bytes. Note that even if your source would contain a different value, a value of 64 would be used.

In order to override the processor dat file, you need to use the new DEVICE parameter. It accepts only the official processor name.

Example : bascomp "myfile.bas" device=atmega88

When you specify a device name that does not exist, a list will be shown with all device names.

The command line utility will set the DOS errorcode to 0 when no error is found, or to a non zero value when there is a problem.

Parameters 

HW | Hardware stack ($hwstack)  
---|---  
FR | Frame size ($framesize)  
SS | Soft stack ($swstack)  
DEVICE | Device name. Stored in the DAT files with the name device= The name is not case sensitive.  
  
This is a list of device names which will change when new DAT files are added.

available devices:

AT90S1200

AT90S2313

AT90S2323

AT90S2333

AT90S2343

AT90S4414

AT90S4433

AT90S4434

AT90S8515

AT90S8535

AT86RF401

AT90PWM1

AT90PWM216

AT90PWM3

ATtiny12

ATtiny13

ATtiny13A

ATtiny15

ATtiny1634

ATtiny167

ATtiny20

ATtiny22

ATtiny2313

ATtiny2313A

ATtiny24

ATtiny24A

ATtiny25

ATtiny26

ATtiny261

ATtiny4313

ATtiny43U

ATtiny44

ATtiny441

ATtiny45

ATtiny461

ATtiny48

ATtiny828

ATtiny84

ATtiny841

ATtiny85

ATtiny861

ATtiny87

ATtiny88

ATtiny1604

ATtiny1606

ATtiny1607

ATtiny1614

ATtiny1616

ATtiny1617

ATtiny202

ATtiny204

ATtiny212

ATtiny214

ATtiny3216

ATtiny3217

ATtiny402

ATtiny404

ATtiny406

ATtiny412

ATtiny414

ATtiny1416

ATtiny417

ATtiny804

ATtiny806

ATtiny807

ATtiny814

ATtiny816

ATtiny817

AVR128DB28

AVR128DB32

AVR128DB64

AVR64DB32

ATMega103

ATMega1280

ATMega128

ATMega1281

ATMEGA1284

ATMEGA1284P

AT90CAN128

ATMega128

ATMega128RFA1

ATMEGA161

ATmega162

ATMEGA163

ATMEGA164A

ATMEGA164PA

ATMEGA164P

ATMega165A

ATMega165

ATmega168

ATmega168PA

ATmega168PB

ATmega168P

ATmega169A

ATmega169

ATmega169PA

ATmega169P

ATmega16A

ATmega16

ATMEGA16M1

ATMEGA16U2

ATMEGA16U4

ATMega2560

ATMega2561

ATMEGA323

ATMEGA324A

ATMEGA324PA

ATMEGA324PB

ATMEGA324P

ATMEGA3250A

ATMEGA3250PA

ATMEGA3250P

ATMEGA325

ATmega328

ATmega328PB

ATmega328P

ATmega329

ATMEGA32A

ATMEGA32C1

AT90CAN32

ATMEGA32

ATMEGA32M1

ATMEGA32U2

ATMEGA32U4

ATmega406

ATmega48

ATmega48PA

ATmega48PB

ATmega48P

ATmega603

ATMega640

ATMEGA644A

ATMEGA644

ATMEGA644PA

ATMEGA644P

ATMEGA6450P

ATMEGA645

ATmega6490

ATmega649A

ATmega649

ATmega649P

ATMEGA64C1

AT90CAN64

atmega64

ATMEGA64M1

ATmega8515

ATmega8535

ATmega88A

ATmega88

ATmega88PA

ATmega88PB

ATmega88P

ATmega8A

ATmega8

ATMEGA8U2

ATmega4808

ATmega4809

AT90USB1286

AT90USB1287

AT90USB162

AT90USB646

AT90USB82

ATXMega128A1

ATXMega128A1U

ATXMega128A3

ATXMega128A3U

ATxmega128A4U

ATxmega128B1

ATxmega128B3

ATXMega128C3

ATXMega128D3

ATxmega128D4

ATxmega16A4

ATxmega16D4

ATxmega16E5

ATXMega192A3

ATXMega192A3U

ATXMega192D3

ATXMega256A3B

ATXMega256A3BU

ATXMega256A3

ATXMega256A3U

ATXMega256D3

ATxmega32A4

ATxmega32A4U

ATXMega32C4

ATxmega32D4

ATxmega32E5

ATXMega384C3

ATXMega64A1

ATXMega64A3

ATXMega64A3U

ATxmega64A4U

ATXMega64D3

ATxmega64D4

ATxmega8E5

---

## BASE64DEC

Action

Converts Base-64 data into the original data.

Syntax

Result = BASE64DEC( source)

array = BASE64DEC( source, elements)

Remarks

Result | A string variable that is assigned with the un-coded string.  
---|---  
Source | The source string that is coded with base-64.  
array | A byte array that is assigned with the un-coded strings  
elements | The number of elements in the resulting array  
  
Base-64 is not an encryption protocol. It sends data in 7-bit ASCII data format. MIME, web servers, and other Internet servers and clients use Base-64 coding.

The provided Base64Dec() function is a decoding function. It was written to add authentication to the web server sample.

When the web server asks for authentication, the client will send the user and password unencrypted, but base-64 coded to the web server.

Base-64 coded strings are always in pairs of 4 bytes. These 4 bytes represent 3 bytes.

Because strings can not contain a 0 byte, there is an alternative syntax. Instead of a string you assign a byte array.

The byte variable ELEMENTS is assigned with the number of elements filled with data.

See also

[CONFIG TCPIP](config_tcpip.md), [GETSOCKET](getsocket.md) , [SOCKETCONNECT](socketconnect.md), [SOCKETSTAT](socketstat.md) , [TCPWRITE](tcpwrite.md), [TCPWRITESTR](tcpwritestr.md), [CLOSESOCKET](socketclose.md) , [SOCKETLISTEN](socketlisten.md) , [BASE64ENC](base64enc.md) , [URL2IP](url2ip.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$lib "tcpip.lbx"

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As String * 15 , Z As String * 15

```
S = "bWFyazptYXJr"

Z = Base64dec(s)

```vb
Print Z 'mark:mark

End

```
Example 2

```vb
$regfile = "m32U4def.dat"  
$crystal = 16000000  
$baud = 19200  
  
Dim S As String * 80 , Z As String * 80 , B As Byte , J As Byte  
Dim Ar(81) As Byte At S Overlay  
  
```
S = "This is a test"  
'while we load the array with string data, we could load it with any data that can contain a 0.  
  
B = Len(s) + 1 'get the length and the 0 byte  
Z = Base64enc(ar(1) , B) 'use an array  
Print Z  
  
Ar(1) = Base64dec(z , B) 'now B will hold the number of elements  
  
```vb
Print B  
  
'Another example  
```
Ar(1) = 0 : Ar(2) = 1 : Ar(3) = 2  
Z = Base64enc(ar(1) , 3) 'use an array  
Print Z  
  
  
Ar(1) = Base64dec(z , B) 'now B will hold the number of elements  
```vb
For J = 1 To B  
Print Ar(j)  
Next  
End  


```

---

## BASE64ENC

Action

Converts a string into the Base-64 representation.

Syntax

Result = BASE64ENC( source)

Result = BASE64ENC( array, length)

Remarks

Result | A string variable that is assigned with the base64 coded string.  
---|---  
Source | The source string that must be coded.  
array | The first element of a byte array.   
length | The number of elements to convert. Maximum 255.   
  
Base-64 is not an encryption protocol. It sends data in 7-bit ASCII data format. MIME, web servers, and other Internet servers and clients use Base-64 coding.

The provided Base64Enc() function is an encoding function. You need it when you want to send attachments with POP3 for example.

The target string will use 1 additional byte for every 3 bytes. This means that the target string is ca. 33 % longer than the source string.

So make sure the target string is dimensioned longer then the original string.

Because strings can not contain a 0 byte, there is an alternative syntax. Instead of a string you pass the address of a byte array that contains the data you want to convert.

Because there is no end of string marker, you must provide the number of elements to convert. 

See also

[CONFIG TCPIP](config_tcpip.md), [GETSOCKET](getsocket.md) , [SOCKETCONNECT](socketconnect.md), [SOCKETSTAT](socketstat.md) , [TCPWRITE](tcpwrite.md), [TCPWRITESTR](tcpwritestr.md), [CLOSESOCKET](socketclose.md) , [SOCKETLISTEN](socketlisten.md) , [BASE64DEC](base64dec.md), [URL2IP](url2ip.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$lib "tcpip.lbx"

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As String * 15 , Z As String * 15

```
S = "bWFyazptYXJr"

Z = Base64dec(s)

Print Z 'mark:mark

s = Base64Enc(z)

```vb
Print s

End

```
Example 2

```vb
$regfile = "m32U4def.dat"  
$crystal = 16000000  
$baud = 19200  
  
Dim S As String * 80 , Z As String * 80 , B As Byte , J As Byte  
Dim Ar(81) As Byte At S Overlay  
  
```
S = "This is a test"  
'while we load the array with string data, we could load it with any data that can contain a 0.  
  
B = Len(s) + 1 'get the length and the 0 byte  
Z = Base64enc(ar(1) , B) 'use an array  
Print Z  
  
Ar(1) = Base64dec(z , B) 'now B will hold the number of elements  
  
```vb
Print B  
  
'Another example  
```
Ar(1) = 0 : Ar(2) = 1 : Ar(3) = 2  
Z = Base64enc(ar(1) , 3) 'use an array  
Print Z  
  
  
Ar(1) = Base64dec(z , B) 'now B will hold the number of elements  
```vb
For J = 1 To B  
Print Ar(j)  
Next  
End  


```

---

## BAUD

Action

Changes the baud rate for the hardware or software UART.

Syntax

BAUD = const

Syntax Software UART

BAUD #x , const

Remarks

X | The channel number of the software UART.  
---|---  
Const | A numeric constant for the baud rate that you want to use.  
  
![notice](notice.jpg) Do not confuse the BAUD statement with the [$BAUD](baud_1.md) compiler directive.

And do not confuse [$CRYSTAL](crystal_1.md) and [CRYSTAL](crystal_2.md)

$BAUD overrides the compiler setting for the baud rate while BAUD will change the current baud rate.

So $BAUD is a global project setting in your source code while BAUD will change the baud rate during run time.

You could use BAUD to change the baud rate during run time after the user changes a setting.

BAUD = ... will work on the hardware UART.

BAUD #x, yyyy will work on the software or HW UART. The specified channel must be the same as used with the OPEN statement.

When you use a software UART and change the baud rate at run time using BAUD, you must set the baud rate after the OPEN statements as well.

When you do not use BAUD, there is no need to set it. So for example :

Open "COMC.1:9600,8,N,1" For Output As #1

print #1 , "this is a test 9600" 'no need for BAUD since one baud rate is used

But when BAUD is changed :

Open "COMC.1:9600,8,N,1" For Output As #1

baud #1 , 9600 'we need to set it since we change baud at run time

print #1 , "this is a test 9600"

baud #1 , 115200

print #1 , "this is a test 115200"

![notice](notice.jpg)Variables are not supported. Only constants. 

See also

[$CRYSTAL](crystal_1.md) , [$BAUD](baud_1.md) , [BAUD1](baud1.md)

ASM

NONE

Example

```vb
$regfile = "m48def.dat"

$crystal = 4000000

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Print "Hello"

'Now change the baud rate in a program

```
Baud = 9600

```vb
Print "Did you change the terminal emulator baud rate too?"

End

```

---

## BAUD1-BAUDx

Action

Changes the baud rate for the specified hardware UART.

Syntax

BAUD = var

BAUD1 = var

BAUD2 = var

BAUD3 = var

Syntax Xmega

BAUD = var

BAUD1 = var

BAUD2 = var

BAUD3 = var

BAUD4 = var

BAUD5 = var

BAUD6 = var

BAUD7 = var

Xmega Syntax

BAUDx = constant

Remarks

Var | The baud rate that you want to use.  
---|---  
baud | COM1, USART0, xmega and normal AVR  
baud1 | COM2, USART1, xmega and normal AVR  
baud2 | COM2, USART2, xmega and normal AVR  
baud3 | COM3, USART3, xmega and normal AVR  
baud4 | COM4, USART4, xmega  
baud5 | COM5, USART5, xmega  
baud6 | COM6, USART6, xmega  
baud7 | COM7, USART7, xmega  
  
Do not confuse the BAUD1 statement with the $BAUD1 compiler directive.

And do not confuse [$CRYSTAL](crystal_1.md) and [CRYSTAL](crystal_2.md)

$BAUD1 overrides the compiler setting for the baud rate while BAUD1 will change the current baud rate.

BAUD1 = ... will work on the hardware UART.

BAUDn = ... will work on the specified hardware UART.

mega

For the mega, the X represents the UART number. BAUD means, the first UART which you refer to with OPEN as COM1, BAUD1 the second UART, and BAUD3 is the last UART. A channel number is not supported.

You need to use a constant for the baud rate. Variables are not supported. 

Xmega

```vb
For the xmega, the X represents the UART number. BAUD means, the first UART which you refer to with OPEN as COM1, BAUD1 the second UART, and BAUD7 is the last UART. A channel number is not supported.

For the Xmega you need to use a constant for the baud rate. Variables are not supported. 

```
See also

[$CRYSTAL](crystal_1.md) , [$BAUD](baud_1.md) , [$BAUD1](_baud1.md) , [BAUD](baud_2.md), [CONFIG COMx](configcomx.md)

ASM

NONE

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega162

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates BAUD1 directive and BAUD1 statement

'-------------------------------------------------------------------------------

$regfile = "M162def.dat"

$baud1 = 2400

$crystal= 14000000 ' 14 MHz crystal

```
Open "COM2:" For BINARY As #1

```vb
Print #1 , "Hello"

'Now change the baud rate in a program

```
Baud1 = 9600 '

Print #1 , "Did you change the terminal emulator baud rate too?"

Close #1

End

---

## BCCALL

Action

Calls a subroutine or procedure in the BasicCard.

Syntax

BCCALL name( nad , cla, ins, p1, p2 [param1 , paramn])

Remarks

name | The name of the procedure to all in the BasicCard. It must be defined first with BCDEF. The name used with BCDEF and BCCALL do not need to be the same as the procedure in the BasicCard but it is advised to use the same names.  
---|---  
NAD | Node address byte. The BasicCard responds to all node address values. Use 0 for default.  
CLA | Class byte. First byte of two byte CLA-INS command. Must match the value in the BasicCard procedure.  
INS | Instruction byte. Second byte of two byte CLA-INS command. Must match the value in the BasicCard procedure.  
P1 | Parameter 1 of CLAâINS header.  
P2 | Parameter 2 of CLA-INS header  
  
![notice](notice.jpg)This statements uses BCCARD.LIB, a library that is available separately from MCS Electronics.

When in your BasicCard basic program you use:

'test of passing parameters

Command &hf6 &h01 ParamTest( b as byte, w as integer,l as long)

b=b+1

w=w+1

l=l+1

end command

You need to use &HF6 for CLA and 1 for INS when you call the program:

Bccall Paramtest(0 , &HF6 , 1 , 0 , 0 , B , W , L)

^ NAD

^CLA

^INS

^P1

^P2

When you use BCCALL, the NAD, CLA, INS, P1 and P2 are sent to the BasicCard. The parameter values are also sent to the BasicCard. The BasicCard will execute the command defined with CLA and INS and will return the result in SW1 and SW2.

The parameter values altered by the BasicCard are also sent by the BasicCard.

You can not sent constant values. Only variables may be sent. This because a constant can not be changed.

See Also

[CONFIG BCCARD](config_bccard.md) , [BCDEF](bcdef.md) , [BCRESET](bcreset.md)

Example

```vb
'------------------------------------------------------------------------------

' BCCARD.BAS

' This AN shows how to use the BasicCard from Zeitcontrol

' www.basiccard.com

'------------------------------------------------------------------------------

'connections:

' C1 = +5V

' C2 = PORTD.4 - RESET

' C3 = PIN 4 - CLOCK

' C5 = GND

' C7 = PORTD.5 - I/O

' /--------------------------------\

' | |

' | C1 C5 |

' | C2 C6 |

' | C3 C7 |

' | C4 C8 |

' | |

' \\--------------------------------/

'

'

'----------- configure the pins we use ------------

Config Bccard = D , Io = 5 , Reset = 4

' ^ PORTD.4

' ^------------ PORTD.5

' ^--------------------- PORT D

'Load the sample calc.bas into the basiccard

' Now define the procedure in BASCOM

' We pass a string and also receive a string

```
Bcdef Calc(string)

```vb
'We need to dim the following variables

'SW1 and SW2 are returned by the BasicCard

'BC_PCB must be set to 0 before you start a session

'Our program uses a string to pass the data so DIM it

Dim S As String * 15

'Baudrate might be changed

$baud = 9600

' Crystal used must be 3579545 since it is connected to the Card too

$crystal = 3579545

'Perform an ATR

```
Bcreset

```vb
'Now we call the procedure in the BasicCard

'bccall funcname(nad,cla,ins,p1,p2,PRM as TYPE,PRM as TYPE)

```
S = "1+1+3" ' we want to calculate the result of this expression

Bccall Calc(0 , &H20 , 1 , 0 , 0 , S)

```vb
' ^--- variable to pass that holds the expression

' ^------- P2

' ^----------- P1

' ^--------------- INS

' ^-------------------- CLA

' ^-------------------------- NAD

'For info about NAD, CLA, INS, P1 and P2 see your BasicCard manual

'if an error occurs ERR is set

' The BCCALL returns also the variables SW1 and SW2

Print "Result of calc : " ; S

Print "SW1 = " ; Hex(sw1)

Print "SW2 = " ; Hex(sw2)

'Print Hex(_bc_pcb) ' for test you can see that it toggles between 0 and 40

Print "Error : " ; Err

'You can call this or another function again in this session

```
S = "2+2"

Bccall Calc(0 , &H20 , 1 , 0 , 0 , S)

```vb
Print "Result of calc : " ; S

Print "SW1 = " ; Hex(sw1)

Print "SW2 = " ; Hex(sw2)

'Print Hex(_bc_pcb) ' for test you can see that it toggles between 0 and 40

Print "Error : " ; Err

'perform another ATR

```
Bcreset

Input "expression " , S

Bccall Calc(0 , &H20 , 1 , 0 , 0 , S)

```vb
Print "Answer : " ; S

'----and now perform an ATR as a function

Dim Buf(25) As Byte , I As Byte

```
Buf(1) = Bcreset()

```vb
For I = 1 To 25

Print I ; " " ; Hex(buf(i))

Next

'typical returns :

'TS = 3B

'T0 = EF

'TB1 = 00

'TC1 = FF

'TD1 = 81 T=1 indication

'TD2 = 31 TA3,TB3 follow T=1 indicator

'TA3 = 50 or 20 IFSC ,50 =Compact Card, 20 = Enhanced Card

'TB3 = 45 BWT blocl waiting time

'T1 -Tk = 42 61 73 69 63 43 61 72 64 20 5A 43 31 32 33 00 00

' B a s i c C a r d Z C 1 2 3

'and another test

'define the procedure in the BasicCard program

```
Bcdef Paramtest(byte , Word , Long )

```vb
'dim some variables

Dim B As Byte , W As Word , L As Long

'assign the variables

```
B = 1 : W = &H1234 : L = &H12345678

Bccall Paramtest(0 , &HF6 , 1 , 0 , 0 , B , W , L)

```vb
Print Hex(sw1) ; Spc(3) ; Hex(sw2)

'and see that the variables are changed by the BasicCard !

Print B ; Spc(3) ; Hex(w) ; " " ; Hex(l)

'try the echotest command

```
Bcdef Echotest(byte)

Bccall Echotest(0 , &HC0 , &H14 , 1 , 0 , B)

```vb
Print B

End 'end program

```
Rem BasicCard Sample Source Code

Rem ------------------------------------------------------------------

Rem Copyright (C) 1997-2001 ZeitControl GmbH

Rem You have a royalty-free right to use, modify, reproduce and

Rem distribute the Sample Application Files (and/or any modified

Rem version) in any way you find useful, provided that you agree

Rem that ZeitControl GmbH has no warranty, obligations or liability

Rem for any Sample Application Files.

Rem ------------------------------------------------------------------

```vb
#Include CALCKEYS.BAS

Declare ApplicationID = "BasicCard Mini-Calculator"

```
Rem This BasicCard program contains recursive procedure calls, so the

Rem compiler will allocate all available RAM to the P-Code stack unless

Rem otherwise advised. This slows execution, because all strings have to

Rem be allocated from EEPROM. So we specify a stack size here:

```vb
#Stack 120

' Calculator Command (CLA = &H20, INS = &H01)

'

' Input: an ASCII expression involving integers, and these operators:

'

' * / % + - & ^ |

'

' (Parentheses are also allowed.)

'

' Output: the value of the expression, in ASCII.

'

' P1 = 0: all numbers are decimal

' P1 <> 0: all numbers are hex

' Constants

```
Const SyntaxError = &H81

Const ParenthesisMismatch = &H82

Const InvalidNumber = &H83

Const BadOperator = &H84

```vb
' Forward references

Declare Function EvaluateExpression (S$, Precedence) As Long

Declare Function EvaluateTerm (S$) As Long

Declare Sub Error (Code@)

'test for passing a string

```
Command &H20 &H01 Calculator (S$)

Private X As Long

S$ = Trim$ (S$)

X = EvaluateExpression (S$, 0)

```vb
If Len (Trim$ (S$)) <> 0 Then Call Error (SyntaxError)

If P1 = 0 Then S$ = Str$ (X) : Else S$ = Hex$ (X)

End Command

'test of passing parameters

```
Command &hf6 &h01 ParamTest( b as byte, w as integer,l as long)

b=b+1

w=w+1

l=l+1

```vb
end command

Function EvaluateExpression (S$, Precedence) As Long

```
EvaluateExpression = EvaluateTerm (S$) 

Do

S$ = LTrim$ (S$)

```vb
If Len (S$) = 0 Then Exit Function

Select Case S$(1)

Case "*"

If Precedence > 5 Then Exit Function

```
S$ = Mid$ (S$, 2)

EvaluateExpression = EvaluateExpression * _

EvaluateExpression (S$, 6)

```vb
Case "/"

If Precedence > 5 Then Exit Function

```
S$ = Mid$ (S$, 2)

EvaluateExpression = EvaluateExpression / _

EvaluateExpression (S$, 6)

```vb
Case "%"

If Precedence > 5 Then Exit Function

```
S$ = Mid$ (S$, 2)

EvaluateExpression = EvaluateExpression Mod _

EvaluateExpression (S$, 6)

```vb
Case "+"

If Precedence > 4 Then Exit Function

```
S$ = Mid$ (S$, 2)

EvaluateExpression = EvaluateExpression + _

EvaluateExpression (S$, 5)

```vb
Case "-"

If Precedence > 4 Then Exit Function

```
S$ = Mid$ (S$, 2)

EvaluateExpression = EvaluateExpression - _

EvaluateExpression (S$, 5)

```vb
Case "&"

If Precedence > 3 Then Exit Function

```
S$ = Mid$ (S$, 2)

EvaluateExpression = EvaluateExpression And _

EvaluateExpression (S$, 4)

```vb
Case "^"

If Precedence > 2 Then Exit Function

```
S$ = Mid$ (S$, 2)

EvaluateExpression = EvaluateExpression Xor _

EvaluateExpression (S$, 3)

```vb
Case "|"

If Precedence > 1 Then Exit Function

```
S$ = Mid$ (S$, 2)

EvaluateExpression = EvaluateExpression Or _

EvaluateExpression (S$, 2)

```vb
Case Else

Exit Function

End Select

Loop

End Function

Function EvaluateTerm (S$) As Long

Do ' Ignore unary plus

```
S$ = LTrim$ (S$)

```vb
If Len (S$) = 0 Then Call Error (SyntaxError)

If S$(1) <> "+" Then Exit Do

```
S$ = Mid$ (S$, 2)

```vb
Loop

If S$(1) = "(" Then ' Expression in parentheses

```
S$ = Mid$ (S$, 2)

EvaluateTerm = EvaluateExpression (S$, 0)

S$ = LTrim$ (S$)

If S$(1) <> ")" Then Call Error (ParenthesisMismatch)

S$ = Mid$ (S$, 2)

Exit Function

ElseIf S$(1) = "-" Then ' Unary minus

S$ = Mid$ (S$, 2)

EvaluateTerm = -EvaluateTerm (S$)

```vb
Exit Function

Else ' Must be a number

If P1 = 0 Then ' If decimal

```
EvaluateTerm = Val& (S$, L@)

Else

EvaluateTerm = ValH (S$, L@)

```vb
End If

If L@ = 0 Then Call Error (InvalidNumber)

```
S$ = Mid$ (S$, L@ + 1)

```vb
End If

End Function

Sub Error (Code@)

```
SW1 = &H64

SW2 = Code@

```vb
Exit

End Sub

```

---

## BCCARD

BCCARD.LIB is a commercial addon library that is available separately from [MCS Electronics](<http://www.mcselec.com/index.php?page=shop.product_details&flypage=shop.flypage&product_id=33&category_id=6&option=com_phpshop&Itemid=1>).

With the BCCARD library you can interface with the BasicCards from [www.basiccard.com](<http://Www.basiccard.com>)

BasicCards are also available from MCS Electronics

A BasicCard is a smart card that can be programmed in BASIC.

The chip on the card looks like this :

![smartcard](smartcard.gif)

To interface it you need a smart card connector.

In the provided example the connections are made as following:

Smart Card PIN | Connect to  
---|---  
C1 | +5 Volt  
C2 | PORTD.4 , RESET  
C3 | PIN 4 of 2313 , CLOCK  
C5 | GND  
C7 | PORTD.5 , I/O  
  
The microprocessor must be clocked with a 3579545 crystal since that is the frequency the Smart Card is working on. The output clock of the microprocessor is connected to the clock pin of the Smart card.

Some global variables are needed by the library. They are dimensioned automatic by the compiler when you use the CONFIG BCCARD statement.

These variables are:

_Bc_pcb : a byte needed by the communication protocol.

Sw1 and SW2 : both bytes that correspondent to the BasicCard variables SW1 and SW2

The following statements are especially for the BasicCard:

[CONFIG BCCARD](config_bccard.md) to init the library

[BCRESET](bcreset.md) to reset the card

[BCDEF](bcdef.md) to define your function in the card

[BCCALL](bccall.md) to call the function in the card

Encryption is not supported by the library yet.

---

## BCD

Action

Converts a variable stored in BCD format into a string.

Syntax

PRINT BCD( var )

LCD BCD( var)

Remarks

Var | Numeric variable to convert.  
---|---  
  
When you want to use an I2C clock device which stores its values in BCD format you can use this function to print the value correctly.

BCD() displays values with a leading zero.

The BCD() function is intended for the PRINT/LCD statements.

Use the MAKEBCD function to convert variables from decimal to BCD.

Use the MAKEDEC function to convert variables from BCD to decimal.

See also

[MAKEDEC](makedec.md) , [MAKEBCD](makebcd.md)

ASM

Calls: _BcdStr

Input: X hold address of variable

Output: R0 with number of bytes, frame with data.

Example

```vb
'--------------------------------------------------------------------------------

'name : bcd.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstration of split and combine BCD Bytes

'suited for demo : yes

'commercial addon needed : no

'use in simulator : possible

'--------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'===============================================================================

' Set up Variables

'===============================================================================

Dim A As Byte 'Setup A Variable

Dim B As Byte 'Setup B Variable

Dim C As Byte 'Setup C Variable

```
A = &H89 

```vb
'===============================================================================

' Main

'===============================================================================

```
Main:

```vb
Print "Combined : " ; Hex(a) 'Print A

'-------------------------------------------------------------------------------

```
B = A And &B1111_0000 'Mask To Get Only High Nibble Of Byte

Shift B , Right , 4 'Shift High Nibble To Low Nibble Position , Store As B

C = A And &B0000_1111 'Mask To Get Only Low Nibble Of Byte , Store As C

```vb
Print "Split : " ; B ; " " ; C 'Print B (High Nibble) , C(low Nibble)

'-------------------------------------------------------------------------------

```
Shift B , Left , 4 'Shift Data From Low Nibble Into High Nibble Position

A = B + C 'Add B (High Nibble) And C(low Nibble) Together

```vb
Print "Re-Combined: " ; Hex(a); " " ; Bcd(a)  'Print A (re -combined Byte)

End 'End Program

```

---

## BCDEF

Action

Defines a subroutine name and itâs parameters in BASCOM so it can be called in the BasicCard.

Syntax

BCDEF name([param1 , paramn])

Remarks

name | The name of the procedure. It may be different than the name of the procedure in the BasicCard but it is advised to use the same names.  
---|---  
Param1 | Optional you might want to pass parameters. For each parameter you pass, you must specify the data type. Supported data types are byte, Integer, Word, Long, Single and String  
  
![notice](notice.jpg)This statements uses BCCARD.LIB, a library that is available separately from MCS Electronics.

BCDEF Calc(string)

Would define a name âCalcâ with one string parameter.

When you use strings, it must be the last parameter passed.

BCDEF name(byte,string)

BCDEF does not generate any code. It only informs the compiler about the data types of the passed parameters.

See Also

[CONFIG BCCARD](config_bccard.md) , [BCCALL](bccall.md) , [BCRESET](bcreset.md)

Partial Example

Bcdef Calc(string)

---

## BCRESET

Action

Resets the BasicCard by performing an ATR.

Syntax

BCRESET

Array(1) = BCRESET()

Remarks

Array(1) | When BCRESET is used as a function it returns the result of the ATR to the array named array(1). The array must be big enough to hold the result. Dim it as a byte array of 25.  
---|---  
  
This statements uses BCCARD.LIB, a library that is available separately from MCS Electronics.

An example of the returned output when used as a function:

```vb
'TS = 3B

'T0 = EF

'TB1 = 00

'TC1 = FF

'TD1 = 81 T=1 indication

'TD2 = 31 TA3,TB3 follow T=1 indicator

'TA3 = 50 or 20 IFSC ,50 =Compact Card, 20 = Enhanced Card

'TB3 = 45 BWT block waiting time

'T1 -Tk = 42 61 73 69 63 43 61 72 64 20 5A 43 31 32 33 00 00

' B a s i c C a r d Z C 1 2 3

```
See the BasicCard manual for more information

When you do not need the result you can also use the BCRESET statement.

See Also

[CONFIG BCCARD](config_bccard.md) , [BCDEF](bcdef.md) , [BCCALL](bccall.md)

Partial Example (no init code shown)

```vb
'----and now perform an ATR as a function

Dim Buf(25)AsByte, I AsByte

```
Buf(1)=Bcreset()

```vb
For I = 1 To 25

Print I ;" ";Hex(buf(i))

Next

'typical returns :

'TS = 3B

'T0 = EF

'TB1 = 00

'TC1 = FF

'TD1 = 81 T=1 indication

'TD2 = 31 TA3,TB3 follow T=1 indicator

'TA3 = 50 or 20 IFSC ,50 =Compact Card, 20 = Enhanced Card

'TB3 = 45 BWT blocl waiting time

'T1 -Tk = 42 61 73 69 63 43 61 72 64 20 5A 43 31 32 33 00 00

' B a s i c C a r d Z C 1 2 3

```

---

## Begin_G

Action

Begin drawing a Graphics Primitive. 

Syntax

Begin_G prim 

Remarks

prim | BITMAPS FTPOINTS LINES LINE_STRIP EDGE_STRIP_R EDGE_STRIP_L EDGE_STRIP_A EDGE_STRIP_B RECTS |  Bitmap Drawing Primitive Point Drawing Primitive Line Drawing Primitive Line Strip Drawing Primitive Edge Strip Right side Drawing Primitive Edge Strip Left side Drawing Primitive Edge Strip Above Drawing Primitive Edge Strip Below Drawing Primitive Rectangle Drawing Primitive  
---|---|---  
  
All primitives supported by the FT800 are defined in the table above. The primitive 

to be drawn is selected by the [Begin_G](begin_g.md) command. Once the primitive is selected, it will be 

valid till the new primitive is selected by the [Begin_G](begin_g.md) command. 

Please Note: The primitive drawing operation will not be performed until [Vertex2ii](vertex2ii.md) or [Vertex2f](vertex2f.md) is executed.

See also

[END_G](end_g.md) , [VERTEX2F](vertex2f.md), [VERTEX2II](vertex2ii.md)

Example

' Pseudocode

Begin_G Lines  
Vertex2F (FT_DispWidth / 4) * 16, (FT_DispHeight - 25) / 2 * 16  
Vertex2F (FT_DispWidth / 4) * 16, (FT_DispHeight + 25) / 2 * 16  
ColorRGB 0, 128, 0  
LineWidth 10 * 16

Begin_G FTPoints  
Vertex2F 50,5,00  
Vertex2F 110,15,0,0

' Drawing points, lines and bitmap

Begin_G FTPOINTS

Vertex2II 50, 5, 0, 0

Vertex2II 110, 15, 0, 0

Begin_G LINES

Vertex2II 50, 45, 0, 0

Vertex2II 110, 55, 0, 0

Begin_G BITMAPS

Vertex2II 50, 65, 31,&H45

Vertex2II 110, 75, 31,&H46

![clip0087](clip0087.png)

---

## BIN

Action

Convert a numeric variable into the binary string representation.

Syntax

Var = Bin(source)

Remarks

Var | The target string that will be assigned with the binary representation of the variable source.  
---|---  
Source | The numeric variable that will be converted.  
  
The BIN() function can be used to display the state of a port.

When the variable source has the value &B10100011 the string named var will be assigned with "10100011".

It can be easily printed to the serial port.

See also

[HEX](hex.md) , [STR](str.md) , [VAL](val.md) , [HEXVAL](hexval.md) , [BINVAL](binval.md)

ASM

NONE

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim B As Byte

' assign value to B

```
B = 45

```vb
Dim S As String * 10

'convert to string

```
S = Bin(b)

'assign value to portb

Portb = 33

```vb
Print Bin(portb)

'of course it also works for other numerics

End

```

---

## BIN2GRAY

Action

Returns the Gray-code of a variable.

Syntax

var1 = Bin2gray(var2)

Remarks

var1 | Variable that will be assigned with the Gray code.  
---|---  
var2 | A variable that will be converted.  
  
Gray code is used for rotary encoders. Bin2gray() works with byte , integer, word and long variables.

The data type of the variable that will be assigned determines if a byte, word or long conversion will be done.

See also

[GRAY2BIN](gray2bin.md) , [ENCODER](encoder.md)

ASM

Depending on the data type of the target variable the following routine will be called from mcs.lbx:

_grey2Bin for bytes , _grey2bin2 for integer/word and _grey2bin4 for longs.

Example

```vb
'-----------------------------------------------------------------------------------------

'name : graycode.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : show the Bin2Gray and Gray2Bin functions

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'Bin2Gray() converts a byte,integer,word or long into grey code.

'Gray2Bin() converts a gray code into a binary value

Dim B As Byte ' could be word,integer or long too

Print "BIN" ; Spc(8) ; "GREY"

For B = 0 To 15

Print B ; Spc(10) ; Bin2gray(b)

Next

Print "GREY" ; Spc(8) ; "BIN"

For B = 0 To 15

Print B ; Spc(10) ; Gray2bin(b)

Next

End

```

---

## BINVAL

Action

Converts a string representation of a binary number into a number.

Syntax

var = Binval( s)

Remarks

Var | A numeric variable that is assigned with the value of s.  
---|---  
S | Variable of the string type. Should contain only 0 and 1 digits.  
  
See also

[STR](str.md) , [HEXVAL](hexval.md) , [HEX](hex.md) , [BIN](bin.md) , [VAL](val.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As String * 8

```
S = "11001100"

```vb
Dim B As Byte

' assign value to B

```
B = Binval(s)

```vb
Print B

End

```

---

## BitmapHandle

Action

Specify the Bitmap Handle

Syntax

BitmapHandle handle 

Remarks

handle |  Bitmap Handle. The initial value is 0. Valid range values 0 to 31.  
---|---  
  
Handles 16 to 31 are defined by the FT800 for built-in font.

Handle 15 is defined in the co-processor engine commands [CmdGradient](cmdgradient.md), [CmdButton](cmdbutton.md), and [CmdKeys](cmdkeys.md). 

Users can define new bitmaps using handles from 0 to 14.

If there is no co-processor engine command [CmdGradient](cmdgradient.md), [CmdButton](cmdbutton.md) and [CmdKeys](cmdkeys.md) in the current display list, users

can even define a bitmap using handle 15. 

Graphics Context

The value of handle is part of the graphics context, as described in section 4.1 in FT800 Series Programmer Guide.PDF from FTDI.

See also

[BitmapLayout](bitmaplayout.md), [BitmapSize](bitmapsize.md)

---

## BitmapLayout

Action

Specify the source bitmap memory format and layout for the current handle.

Syntax

BitmapLayout format, linestride, height

Remarks

format | Bitmap Pixel Formats. ARGB1555 FT_L1 FT_L4 FT_L8 RGB332 ARGB2 ARGB4 RGB565 PALETTED TEXT8x8 TEXTVGA BARGRAPGH  
---|---  
linestride | Bitmap linestride, in bytes. Please note the alignment requirement which is described below.  
height | Bitmap height, in lines  
  
The bitmap formats supported are FT_L1, FT_L4, FT_L8, RGB332, ARGB2, ARGB4, ARGB1555, RGB565 and PALETTED. 

```vb
For FT_L1 format the linestride must be a multiple of 8 bits.

For FT_L4 format the linestride must be multiple of 2 nibbles (Aligned to byte).

For more details about alignment, please refer to the FT800 Series Programmer Guide.PDF from FTDI.

```
See also

[BitmapHandle](bitmaphandle.md), [BitmapSize](bitmapsize.md), [BitmapSource](bitmapsource.md)

Example

![clip0088](clip0088.png)![clip0089](clip0089.png)

---

## BitmapSize

Action

Specify the Screen Drawing Bitmap Size (for the current Bitmap Handle)

Syntax

BitmapSize Filter, Wrapx , Wrapx ,Width, Height 

Remarks

Filter | Bitmap Filtering Mode, NEAREST or BILINEAR  
---|---  
Wrapx | Bitmap x wrap mode, REPEAT or BORDER  
Wrapx | Bitmap y wrap mode, REPEAT or BORDER  
Width | Drawn bitmap Width, in Pixels  
Height | Drawn bitmap Height, in Pixels  
  
This command controls the drawing of bitmaps: the on-screen size of the bitmap, the behavior for wrapping, and

the filtering function. Please note that if Wrapx or Wrapy is using REPEAT then the corresponding memory layout dimension

([BitmapLayout](bitmaplayout.md) linestride or height) must be power of two, otherwise the result is undefined.

See also

[BitmapHandle](bitmaphandle.md), [BitmapLayout](bitmaplayout.md), [BitmapSource](bitmapsource.md)

Example

```vb
' Pseudocode

' Drawing a 64 x 64 bitmap

```
BitmapSource 0

BitmapLayout RGB565, 128, 64

BitmapSIZE NEAREST, BORDER, BORDER, 64, 64

Begin_G BITMAPS

Veterx2II 48, 28, 0, 0

![clip0090](clip0090.png)

'Reducing the size to 32 x 50

BitmapSource 0

BitmapLayout RGB565, 128, 64

BitmapSize NEAREST, BORDER, BORDER, 32, 50

Begin_G BITMAPS

Vertex2II 48, 28, 0, 0

![clip0091](clip0091.png)

' Using the REPEAT wrap mode to tile the bitmap

BitmapSource 0

BitmapLayout RGB565, 128, 64

BitmapSize NEAREST, REPEAT, REPEAT, 160, 120

Begin_G BITMAPS

Vertex2II 0, 0, 0, 0

![clip0092](clip0092.png)

' 4X zoom - 128 X 128 - using a bitmap transform

BitmapSource 0

BitmapLayout RGB565, 128, 64

BitmapTransformA 128

BitmapTransformE 128

BitmapSize NEAREST, BORDER,BORDER, 128, 128

Begin_G BITMAPS

Vertex2II 16, 0, 0, 0

![clip0093](clip0093.png)

---

## BitmapSource

Action

Specify the source address of bitmap data in FT800 graphics memory RAM_G

Syntax

BitmapSource Addr

Remarks

Addr | Bitmap address in graphics FT800 SRAM, aligned with respect to the bitmap format. For example, if the bitmap format is RGB565/ARGB4/ARGB1555, the bitmap source shall be aligned to 2 bytes.  
---|---  
  
The bitmap source address is normally the address in main memory where the bitmap graphic data is loaded.

See also

[BitmapSize](bitmapsize.md), [BitmapLayout](bitmaplayout.md)

Example

' Drawing a 64 x 64 bitmap, loaded at address 0

BitmapSource 0

BitmapLayout RGB565, 128, 64

BitmapSize NEAREST, BORDER, BORDER, 64, 64

Begin_G BITMAPS

Veterx2II 48, 28, 0, 0

![clip0094](clip0094.png)

Using the same graphics data, but with source and size changed to show only a 32 x 32 detail

BitmapSource 128 * 16 + 32

BitmapLayout RGB565, 128, 64

BitmapSize NEAREST, BORDER, BORDER, 32, 32

Begin_G BITMAPS

Vertex2II 48, 28, 0, 0

![clip0095](clip0095.png)

---

## BitmapTransform

Action

Specify the A-F coefficient of the Bitmap Transform Matrix.

Syntax

BitmapTransform CoefValue , CoefName

Remarks

CoefValue | Coefficient value of the Bitmap Transform Matrix in signed 8.8 bit fixed-point form. The initial value is 256.  
---|---  
CoefName | Coeeficient name. There are coefficient A-F. You need to specify a capital letter A,B,C,D,E or F.  
  
BitmapTransform A-F coefficients are used to perform bitmap transform functionalities such as scaling, rotation and translation.

Example

```vb
' Pseudocode

' A value of 0.5 (128) causes the bitmap appear double width:

```
BitmapSource 0

BitmapLayout RGB565, 128,64

BitmapTransform 128, A

BitmapSize Nearest, Border, Border

Begin_G Bitmaps

Vertex2II 16,0,0,0

![clip0112](clip0112.png)

```vb
' Pseudocode

' A value of 2.0 (512) gives a half-width bitmap:

```
BitmapSource 0

BitmapLayout RGB565, 128,64

BitmapTransform 512, A

BitmapSize Nearest, Border, Border

Begin_G Bitmaps

Vertex2II 16,0,0,0

![clip0113](clip0113.png)

---

## BITS

Action

Set all specified bits to 1.

Syntax

Var = Bits( b1 [,bn])

Remarks

Var | The BYTE/PORT variable that is assigned with the constant.  
---|---  
B1 , bn | A list of bit numbers that must be set to 1.  
  
While it is simple to assign a value to a byte, and there is special Boolean notation &B for assigning bits, the Bits() function makes it simple to assign a few bits.

B = &B1000001 : how many zeroâs are there?

This would make it more readable : B = Bits(0, 6)

You can read from the code that bit 0 and bit 6 are set to 1.

It does not save code space as the effect is the same.

It can only be used on bytes and port registers.

Valid bits are in range from 0 to 7.

See Also

[NBITS](nbits.md)

Example

```vb
'--------------------------------------------------------------------------------

'name : bits-nbits.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo for Bits() AND Nbits()

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'use in simulator : possible

'--------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim B As Byte

'while you can use &B notation for setting bits, like B = &B1000_0111

'there is also an alternative by specifying the bits to set

```
B = Bits(0 , 1 , 2 , 7) 'set only bit 0,1,2 and 7

```vb
Print B

'and while bits() will set all bits specified to 1, there is also Nbits()

'the N is for NOT. Nbits(1,2) means, set all bits except 1 and 2

```
B = Nbits(7) 'do not set bit 7

```vb
Print B

End

```

---

## BITWAIT

Action

Wait until a bit is set or reset.

Syntax

BITWAIT x , SET/RESET

Remarks

X | Bit variable or internal register like PORTB.x , where x ranges from 0-7.  
---|---  
  
When using bit variables make sure that they are set/reset by software otherwise your program will stay in a loop.

When you use internal registers that can be set/reset by hardware such as PINB.0 this doesn't apply since this state can change as a result from for example a key press.

See also

NONE

ASM

Calls: NONE

Input: NONE

Output: NONE

Code : shown for address 0-31

label1:

Sbic PINB.0,label2 

Rjmp label1

Label2:

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim A As Bit

```
Bitwait A , Set 'wait until bit a is set

```vb
'the code above will loop forever since the bit 'A' is not set in software

'it could be set in an ISR routine

```
Bitwait Pinb.7 , Reset 'wait until bit 7 of Port B is 0.

End

---

## BlendFunc

Action

Specify pixel arithmetic. 

Syntax

BlendFunc src, dst 

Remarks

src | Specifies how the source blending factor is computed. One of ZERO, ONE, SRC_ALPHA, DST_ALPHA,ONE_MINUS_SRC_ALPHA or ONE_MINUS_DST_ALPHA.  
---|---  
dst | Specifies how the destination blending factor is computed, One of ZERO, ONE, SRC_ALPHA, DST_ALPHA,ONE_MINUS_SRC_ALPHA or ONE_MINUS_DST_ALPHA.  
  
The blend function controls how new color values are combined with the values already in the color buffer.

Given a pixel value source and a previous value in the color buffer destination, the computed color is:

source Ã src + destination Ã dst

```vb
for each color channel: red, green, blue and alpha.

For more details please refer to the FT800 Series Programmer Guide.PDF from FTDI.

```
See also

[Color_A](color_a.md)

Example

```vb
' Pseudocode

' The default blend function of (SRC_ALPHA, ONE_MINUS_SRC_ALPHA) causes drawing 

' to overlay the destination using the alpha value

```
Begin_G BITMAPS

Vertex2II 50, 30, 31, &H47

Color_A 128 

Vertex2II 60, 40, 31, &H47

![clip0096](clip0096.png)

' A destination factor of zero means that destination pixels are not used

Begin_G BITMAPS

BlendFunc SRC_ALPHA, ZERO

Vertex2II 50, 30, 31, &H47

Color_A 128 

Vertex2II 60, 40, 31, &H47

![clip0097](clip0097.png)

' Using the source alpha to control how much of the destination to keep

Begin_G BITMAPS

BlendFunc ZERO, SRC_ALPHA

Vertex2II 60, 40, 31, &H47

![clip0098](clip0098.png)

---

## BLOAD

Action

Writes the Content of a File into SRAM

Syntax

BLoad sFileName, wSRAMPointer

Remarks

sFileName | (String) Name of the File to be read  
---|---  
wSRAMPointer | (Word) Variable, which holds the SRAM Address to which the content of the file should be written  
  
This function writes the content of a file to a desired space in SRAM. A free handle is needed for this function.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _BLoad |   
---|---|---  
Input | X: Pointer to string with filename | Z: Pointer to Long-variable, which holds the start position of SRAM  
Output | r25: Errorcode | C-Flag: Set on Error  
  
Example

```vb
' THIS IS A CODE FRAGMENT, it needs AVR-DOS in order to work

'now the good old bsave and bload

Dim Ar(100)as Byte , I Asbyte

For I = 1 To 100

```
Ar(i) = I ' fill the array

```vb
Next

Wait 2

```
W = Varptr(ar(1))

Bsave"josef.img", W , 100

For I = 1 To 100

Ar(i) = 0 ' reset the array

Next

Bload "josef.img" , W ' Josef you are amazing !

```vb
For I = 1 To 10

Print Ar(i) ; " ";

Next

Print

```

---

## BOX

Action

Create a filled box on a graphical display.

Syntax

BOX (x1,y1) - (x2,y2) , color

Remarks

x1 | The left corner position of the box  
---|---  
y1 | The top position of the box  
x2 | The right corner position of the box  
y2 | The bottom position of the box  
color | The color to use to fill the box  
  
```vb
On COLOR displays, the box will be filled with the specified color.

On B&W displays, the box will not be filled. Only the box is drawn in the specified color. 

On B&W displays you can use the BOXFILL statement to create a solid box.

```
See also

[LINE](line.md), [CIRCLE](circle.md) , [BOXFILL](boxfill.md)

ASM

NONE

Example

```vb
' ----------------------------------------------------------------------------------------

' The support for this display has been made possible by Peter KÃ¼sters from (c) Display3000

' You can buy the displays from Display3000 or MCS Electronics

' ----------------------------------------------------------------------------------------'

'

$lib "lcd-pcf8833.lbx" 'special color display support

$regfile = "m88def.dat" 'ATMega 8, change if using different processors

$crystal = 8000000 '8 MHz

'First we define that we use a graphic LCD

Config Graphlcd = Color , Controlport = Portc , Cs = 1 , Rs = 0 , Scl = 3 , Sda = 2

'here we define the colors

```
Const Blue = &B00000011 ''predefined contants are making programming easier

Const Yellow = &B11111100

Const Red = &B11100000

Const Green = &B00011100

Const Black = &B00000000

Const White = &B11111111

Const Brightgreen = &B00111110

Const Darkgreen = &B00010100

Const Darkred = &B10100000

Const Darkblue = &B00000010

Const Brightblue = &B00011111

Const Orange = &B11111000

'clear the display

Cls

'create a cross

Line(0 , 0) -(130 , 130) , Blue

Line(130 , 0) -(0 , 130) , Red

```vb
Waitms 1000

'show an RLE encoded picture

```
Showpic 0 , 0 , Plaatje

Showpic 40 , 40 , Plaatje

```vb
Waitms 1000

'select a font

```
Setfont Color16x16

'and show some text

Lcdat 100 , 0 , "12345678" , Blue , Yellow

Waitms 1000

Circle(30 , 30) , 10 , Blue

```vb
Waitms 1000

'make a box

```
Box(10 , 30) -(60 , 100) , Red

'set some pixels

Pset 32 , 110 , Black

Pset 38 , 110 , Black

Pset 35 , 112 , Black

End

Plaatje:

```vb
$bgf "a.bgc"

$include "color.font"

$include "color16x16.font"

```

---

## BOXFILL

Action

Create a filled box on a graphical display.

Syntax

BOXFILL (x1,y1) - (x2,y2) , color

Remarks

x1 | The left corner position of the box  
---|---  
y1 | The top position of the box  
x2 | The right corner position of the box  
y2 | The bottom position of the box  
color | The color to use to fill the box  
  
The BOXFILL command will draw a number of lines which will appear as a filled box.

See also

[LINE](line.md), [CIRCLE](circle.md) , [BOX](box.md)

ASM

NONE

Example

'create a bargraph effect

Boxfill(0 , 0) -(60 , 10) , 1

Boxfill(2 , 2) -(40 , 8) , 0

---

## BREAK

Action

This statement will break the simulator/debugger.

Syntax

BREAK

Remarks

A number of new processors support the BREAK instruction. The break instruction will break execution of the simulator. This is support by the BASCOM simulator but also by Atmels Studio.

Processors that do not support the BREAK instruction interpret the BREAK instruction as a NOP (no operation). So it is safe to use on all processors.

The BREAK instruction uses 1 cycle just like the ASM NOP instruction.

See also

[NOP](nop.md)

Example

NONE

---

## BSAVE

Action

Save a range in SRAM to a File

Syntax

BSave sFileName, wSRAMPointer, wLength

Remarks

sFileName | (String) Name of the File to be written  
---|---  
wSRAMPointer | (Word) Variable, which holds the SRAM Address, from where SRAM should be written to a File  
wLength | (Word) Count of Bytes from SRAM, which should be written to the file  
  
This function writes a range from the SRAM to a file. A free file handle is needed for this function.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _BSave |   
---|---|---  
Input | X: Pointer to string with filename | Z: Pointer to Long-variable, which holds the start position of SRAM  
| r20/r21: Count of bytes to be written |   
Output | r25: Errorcode | C-Flag: Set on Error  
  
Example

```vb
' THIS IS A CODE FRAGMENT, it needs AVR-DOS in order to work

'now the good old bsave and bload

Dim Ar(100)as Byte , I Asbyte

For I = 1 To 100

```
Ar(i) = I ' fill the array

```vb
Next

Wait 2

```
W = Varptr(ar(1))

Bsave"josef.img", W , 100

For I = 1 To 100

Ar(i) = 0 ' reset the array

Next

Bload "josef.img" , W ' Josef you are amazing !

```vb
For I = 1 To 10

Print Ar(i) ; " ";

Next

Print

```

---

## BUFSPACE

Action

Returns the amount of free space of a serial buffer.

Syntax

Var = BufSpace(n)

Remarks

Var | A word or integer variable that is assigned with the free buffer space.  
---|---  
N | A constant in the range from 0-15. Odd numbers are for the INPUT buffers. Even numbers are for the OUTPUT buffers. A value of 0 : output buffer USART0 (first UART) A value of 1 : input buffer USART0 (first UART) A value of 2 : output buffer USART1 (second UART) A value of 3 : input buffer USART1 (second UART) A value of 4 : output buffer USART2  A value of 5 : input buffer USART2 A value of 6 : output buffer USART3 A value of 7 : input buffer USART3 A value of 8 : output buffer USART4 A value of 9 : input buffer USART4 A value of 10 : output buffer USART5 A value of 11 : input buffer USART5 A value of 12 : output buffer USART6 A value of 13 : input buffer USART6 A value of 14 : output buffer USART7 A value of 15 : input buffer USART7 The function will only work when the processor has the chosen UART and when it has been setup using CONFIG SERIAL.  
  
While serial buffers are great because you do not have to wait/block the processor, the buffer can become full when the micro has no time to empty the buffer. With the bufspace() function you can determine if there is still room in the buffer.

See Also

[CONFIG SERIAL](config_serialout.md) , [CLEAR](clear.md)

Example

'---------------------------------------------------------

NONE

---

## BYVAL

Action

Specifies that a variable will be passed by value.

Syntax

Sub Test(BYVAL var)

Remarks

Var | Variable name  
---|---  
  
The default for passing variables to SUBS and FUNCTIONS, is by reference(BYREF). When you pass a variable by reference, the address is passed to the SUB or FUNCTION. When you pass a variable by Value, a temp variable is created on the frame and the address of the copy is passed.

When you pass by reference, changes to the variable will be made to the calling variable.

When you pass by value, changes to the variable will be made to the copy so the original value will not be changed.

By default passing by reference is used.

Note that calling by reference will generate less code.

See also

[CALL](call.md) , [DECLARE](declare_sub.md) , [SUB](sub.md) , [FUNCTION](declare_function.md)

ASM

NONE

Example

Declare Sub Test(Byval X As Byte, Byref Y As Byte, Z As Byte)

---

## CALL

Action

Call and execute a subroutine.

Syntax

CALL Test [ (var1, var-n) ]

Remarks

Var1 | Any BASCOM variable or constant.  
---|---  
Var-n | Any BASCOM variable or constant.  
Test | Name of the subroutine. In this case Test.  
  
You can call sub routines with or without passing parameters.

It is important that the SUB routine is DECLARED before you make the CALL to the subroutine. Of course the number of declared parameters must match the number of passed parameters.

It is also important that when you pass constants to a SUB routine, you must DECLARE these parameters with the BYVAL argument. This because a constant has no address, it is assigned at compile time.

With the CALL statement, you can call a procedure or subroutine.

For example: Call Test2

The call statement enables you to implement your own statements.

You don't have to use the CALL statement:

Test2 will also call subroutine test2

When you don't supply the CALL statement, you must leave out the parenthesis.

So Call Routine(x,y,z) must be written as Routine x,y,z

Unlike normal SUB programs called with the GOSUB statement, the CALL statement enables you to pass variables to a SUB routine that may be local to the SUB.

![notice](notice.jpg)By using CONFIG SUBMODE=NEW, you do not need to DECLARE each sub/function.

See also

[DECLARE](declare_sub.md) , [SUB](sub.md) , [EXIT](exit.md) , [FUNCTION](declare_function.md) , [LOCAL](local.md) , [CONFIG SUBMODE](config_submode.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim A As Byte , B As Byte 'dimension some variables

Declare Sub Test(b1 As Byte , Byval B2 As Byte) 'declare the SUB program

```
A = 65 'assign a value to variable A

Call Test(a , 5)'call test with parameter A and constant

Test A , 5 'alternative call

```vb
Print A 'now print the new value

End

Sub Test(b1 As Byte , Byval B2 As Byte) 'use the same variable names as 'the declared one

Print B1 'print it

Print Bcd(b2)

```
B1 = 10 'reassign the variable

B2 = 15 'reassign the variable

End Sub

![notice](notice.jpg) One important thing to notice is that you can change b2 but that the change will not be reflected to the calling program!

Variable A is changed however.

This is the difference between the BYVAL and BYREF argument in the DECLARE ration of the SUB program.

When you use BYVAL, this means that you will pass the argument by its value. A copy of the variable is made and passed to the SUB program. So the SUB program can use the value and modify it, but the change will not be reflected to the calling parameter. It would be impossible too when you pass a numeric constant for example.

If you do not specify BYVAL, BYREF will be used by default and you will pass the address of the variable. So when you reassign B1 in the above example, you are actually changing parameter A.

---

## Call_C

Action

Execute a sequence of commands at another location in the Display List (RAM_DL). 

Syntax

Call_C dest 

Remarks

dest | The destination address in RAM_DL which the display command is to be switched. FT800 has the stack to store the return address. To come back to the next command of source address, the RETURN command can help.   
---|---  
  
Call_C and Return_C have a 4 level stack in addition to the current pointer. 

Any additional Call_C/Return_C done will lead to unexpected behavior.

See also

[JUMP](jump.md), [RETURN_C](return_c.md) , [MACRO_R](macro_r.md) , [DISPLAY_E](display_e.md)

---

## Cell

Action

Specify the bitmap Cell number for the Vertex2f command.

Syntax

Cell Cell 

Remarks

Cell |  Bitmap Cell number.  
---|---  
  
See Also

[VERTEX2F](vertex2f.md)

---

## Changes compared to BASCOM-8051

The design goal was to make BASCOM-AVR compatible with BASCOM-8051.

For the AVR compiler some statements had to be removed.

New statements were also added. And some statements were changed.

They need specific attention, but the changes to the syntax will be made available to BASCOM-8051 too in the future.

Statements that were removed

STATEMENT | DESCRIPTION  
---|---  
```vb
$LARGE | Not needed anymore.  
$ROMSTART | Code always starts at address 0 for the AVR. Added again in 1.11.6.2  
$LCDHEX | Use LCD Hex(var) instead.  
$NOINIT | Not needed anymore. Added in 1.11.6.2  
$NOSP | Not needed anymore  
$NOBREAK | Can't be used anymore because there is no object code that can be used for it.  
$OBJ | Removed.  
```
BREAK | Can't be used anymore because there is no object code that can be used for it.  
PRIORITY | AVR does no allow setting priority of interrupts  
PRINTHEX | You can use Print Hex(var) now  
LCDHEX | You can use Lcd Hex(var) now  
  
Statements that were added

STATEMENT | DESCRIPTION  
---|---  
FUNCTION | You can define your own user FUNCTIONS.  
LOCAL | You can have LOCAL variables in SUB routines or FUNCTIONS.  
^ | New math statement. Var = 2 ^ 3 will return 2*2*2  
SHIFT | Because ROTATE was changed, I added the SHIFT statement. SHIFT works just like ROTATE, but when shifted left, the LS BIT is cleared and the carry doesn't go to the LS BIT.  
LTRIM | LTRIM, trims the leftmost spaces of a string.  
RTRIM | RTRIM, trims the rightmost spaces of a string.  
TRIM | TRIM, trims both the leftmost and rightmost spaces of a string.  
  
Statements that behave differently

STATEMENT | DESCRIPTION  
---|---  
ROTATE | Rotate now behaves like the ASM rotate, this means that the carry will go to the most significant bit of a variable or the least significant bit of a variable.  
CONST | String were added to the CONST statement. I also changed it to be compatible with QB.  
```vb
DECLARE | BYVAL has been added since real subprograms are now supported.  
DIM | You can now specify the location in memory of the variable. Dim v as byte AT 100, will use memory location 100.

```

---

## CHARPOS

Action

Returns the position of a single character in a string.

Syntax

pos = CHARPOS(string , search [,start [,SAFE]])

Remarks

Pos | Numeric variable that will be assigned with the position of the sub string in the string. Returns 0 when the sub string is not found.  
---|---  
String | The string to search.  
Search | The search string. This can be a numeric variable too. For example a byte. When a string is used, only the first character will be used for the search.  
Offset | An optional start position where the searching must start.  
SAFE | If you specify an offset, Charpos will check if the offset is not located after the string. For example , when the string is "abc" and you specify an offset of 10, it will be located after the string. The SAFE option is default. When you specify SPEED, the compiler will add the offset without checking. This will result in shorter and quicker code.  
  
No constant can be used for string it must be a string variable.

![notice](notice.jpg)The search is sensitive to case.

CHARPOS supports [$BIGSTRINGS](bigstrings.md)

See also

[SPLIT](split.md) , [INSTR](instr.md) , [REPLACECHARS](replacechars.md) , [DELCHAR](delchar.md) , [INSERTCHAR](insertchar.md) , [DELCHARS](delchars.md)

Example

```vb
'-------------------------------------------------------------------------------

' charpos.bas

' (c) 1995-2025 MCS Electronics

$regfile = "m88def.dat"

$crystal = 8000000

$baud = 19200

'-------------------------------------------------------------------------------

Dim S As String * 20

Dim Bpos As Byte

Dim Z As String * 1

```
Z = "*"

```vb
Do

Input "S:" , S

```
Bpos = Charpos(s , Z)

```vb
Print Bpos

Loop Until S = ""

Do

Input "S:" , S

```
Bpos = Charpos(s , "A") ' notice charpos is sensitive to case

```vb
Print Bpos

Loop

```

---

## CHDIR

Action

This statement will change the current directory.

Syntax

CHDIR directory

Remarks

CHange DIRectory changes the current folder or directory.

The directory name must be a valid and existing folder or directory. Like in DOS, you can use ".." to go back one directory.

And you can use "\" to go to the root directory.

You can not specify a path.

You may can have multiple open files, and you could copy from one folder to another folder using the file handles. 

The DIR command and the OPEN command works in the current directory. IF you OPEN a file, the position (Sector# and position inside this sector) of the directory entry of the file is stored at the file-handle-part of that file. So you can move to another directory and OPEN there a second file an so on. In Short: Directory nesting is not limited and you can open files in multiple directories.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILELEN](filelen.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [WRITE](write.md) , [INPUT](input.md) , [DIR](dir.md), [MKDIR](mkdir.md), [RMDIR](rmdir.md), [NAME](name.md)

Example

MKDIR "abc"

CHDIR "abc"

---

## CHECKFLOAT

Action

This function validates the value of a floating point variable.

Syntax

targ = CHECKFLOAT(var [,option])

Remarks

targ | A numeric variable that will be assigned with the result of the validation.  The following bits can be set: cBitInfinity = 0 cmBitInfinity = 1 ;(2 ^ cBitInfinity) cBitZero = 1 cmBitZero = 2 ;(2 ^ cBitZero) cBitNAN = 2 cmBitNAN = 4 ;(2 ^ cBitNAN) cBitSign = 7 cmBitSign = 128 ;(2 ^ cBitSign) The byte values are shown in italic. The bit constants are defined in the single and double libraries.  
---|---  
var | A floating point variable such as a single or double to validate.  
option | This is an optional numeric constant that servers as a mask. This allows to test for makes it possible to test for a single error.  
  
A floating point value may contain an illegal value as the result of a calculation. These illegal values are NAN (not a number) and INFINITY.

The two other tests which are performed are a test for zero, and a sign test. 

```vb
If the result bit 0 is '1' then the number is infinity.

If the result bit 1 is '1' then the number is zero.

If the result bit 2 is '1' then the number if NAN.

If the result bit 7 is '1' then the number is negative. 

If you want to test only for NAN and INFINITY you can add the bits and pass this as the optional numeric mask. For NAN and INFINITY this would be 1+4=5

```
The resulting value will be AND-ed and if any of the two bits is set, the result will be non-zero, indicating an error. If both values are 0, the result will be zero.

![notice](notice.jpg)This functions works for both the double and single data types. For the single there is however a note. When you divide a number by a real 0, the result is a zero (0).

In the double data type you actually get an INFinite number. For this reason the sample contains a trick with overlayed variables to test the function.

See also

NONE

Example

```vb
$regfile = "m2561def.dat"  
$crystal = 8000000  
$hwstack = 64  
$swstack = 64  
$framesize = 64  
$baud = 19200  
  
  
$lib "single.lbx"  
  
Dim S1 As Single , S2 As Single , S3 As Single  
dim d1 as Double , d2 as Double , d3 as Double  
dim bCheck as Byte  
dim bs(4) as Byte at s3 overlay  
dim bd(8) as Byte at d3 overlay  
  
  
```
S1 = 0 : Bcheck = Checkfloat(s1) : Print Bin(bcheck)  
  
S1 = 0 : Bcheck = Checkfloat(s1 , 2) : Print Bin(bcheck)  
  
  
  
d1 = 1: d2 = 0 : d3 = d1 / d2 ' 1/0 should result in infinty  
Bcheck = Checkfloat(d3) : Print Bin(bcheck)  
Bcheck = Checkfloat(d3 , 5) : Print Bcheck ' test for infinity and nan  
  
d1 = -1  
d3 = sqr(d1) ' should produce NAN  
Bcheck = Checkfloat(d3) : Print Bin(bcheck)  
  
' single routines must be checked for returning IEEE-Rulues according values  
s1 = 1: s2 = 0 : s3 = s1 / s2 ' 1/0 should result in infinty  
Bcheck = Checkfloat(s3) : Print Bin(bcheck)  
  
s1 = -1  
s3 = sqr(s1) ' should produce NAN  
Bcheck = Checkfloat(s3) : Print Bin(bcheck)  
  
  
' now check with hard-coded values for singles  
bs(1) = &HFF: bs(2) = &HFF: bs(3) = &HFF: bs(4) = &H7F ' NAN  
Bcheck = Checkfloat(s3) : Print Bin(bcheck)  
  
bs(1) = &H00: bs(2) = &H00: bs(3) = &H80: bs(4) = &H7F ' infinity  
Bcheck = Checkfloat(s3) : Print Bin(bcheck)  
  
End

---

## CHECKSUM CHECKSUMXOR

Action

Returns a checksum of a string.

Syntax

PRINT Checksum(var)

b = Checksum(var)

b = ChecksumXOR(var)

Remarks

Var | A string variable.  
---|---  
B | A numeric variable that is assigned with the checksum.  
  
The checksum is computed by counting all the bytes of the string variable.

The checksumXOR is computed by Xor-ing all the bytes of the string variable.

Checksums are often used with serial communication.

The checksum is a byte checksum. The following VB code is equivalent :

Dim Check as Byte

Check = 0

For x = 1 To Len(s$)

Check = check + ASC(mid$(s$,x,1))

Next

The following VB code is equivalent for ChecksumXOR

Dim Check as Byte

Check = 0

For x = 1 To Len(s$)

Check = check XOR ASC(mid$(s$,x,1))

Next

See also

[CRC8](crc8.md) , [CRC16](crc16.md) , [CRC32](crc32.md) , [CRC16UNI](crc16uni.md), [CRCMB](crcmb.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As String * 10 'dim variable

```
S = "test" 'assign variable

```vb
Print Checksum(s) 'print value (192)

End

```

---

## CHR

Action

Convert a numeric variable or a constant to a string with a length of 1 character. The character represents the ASCII value of the numeric value.

Syntax

PRINT CHR(var)

s = CHR(var)

Remarks

Var | Numeric variable or numeric constant.  
---|---  
S | A string variable.  
  
When you want to print a character to the screen or the LCD display,

you must convert it with the CHR() function.

When you use PRINT numvar, the value will be printed.

When you use PRINT Chr(numvar), the ASCII character itself will be printed.

The Chr() function is handy in combination with the LCD custom characters where you can redefine characters 0-7 of the ASCII table.

Since strings are terminated with a null byte which is the same as Chr(0) , you can not embed a Chr(0) into a string.

When using Chr(0) with the LCD to display a customer character, use : LCD "tekst" ; chr(0) ; "more tekst"

See also

[ASC](asc.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : chr.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : shows how to use the CHR() and BCD() function and

' HEX() function in combination with a PRINT statement

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim K As Byte

```
K = 65

```vb
Print K ; Chr(k) ; K ; Chr(66) ; Bcd(k) ; Hex(k)

End

```

---

## CIRCLE

Action

Draws a circle on a graphic display.

Syntax

CIRCLE(x0,y0) , radius, color

Remarks

X0 | Starting horizontal location of the line.  
---|---  
Y0 | Starting vertical location of the line.  
Radius | Radius of the circle  
Color | Color of the circle  
  
See Also

[LINE](line.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : t6963_240_128.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : T6963C graphic display support demo 240 * 128

'micro : Mega8535

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m8535.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'-----------------------------------------------------------------

' (c) 1995-2025 MCS Electronics

' T6963C graphic display support demo 240 * 128

'-----------------------------------------------------------------

'The connections of the LCD used in this demo

'LCD pin connected to

' 1 GND GND

'2 GND GND

'3 +5V +5V

'4 -9V -9V potmeter

'5 /WR PORTC.0

'6 /RD PORTC.1

'7 /CE PORTC.2

'8 C/D PORTC.3

'9 NC not conneted

'10 RESET PORTC.4

'11-18 D0-D7 PA

'19 FS PORTC.5

'20 NC not connected

'First we define that we use a graphic LCD

' Only 240*64 supported yet

Config Graphlcd = 240 * 128 , Dataport = Porta , Controlport = Portc , Ce = 2 , Cd = 3 , Wr = 0 , Rd = 1 , Reset = 4 , Fs = 5 , Mode = 8

'The dataport is the portname that is connected to the data lines of the LCD

'The controlport is the portname which pins are used to control the lcd

'CE, CD etc. are the pin number of the CONTROLPORT.

' For example CE =2 because it is connected to PORTC.2

'mode 8 gives 240 / 8 = 30 columns , mode=6 gives 240 / 6 = 40 columns

'Dim variables (y not used)

Dim X As Byte , Y As Byte

'Clear the screen will both clear text and graph display

```
Cls

```vb
'Other options are :

' CLS TEXT to clear only the text display

' CLS GRAPH to clear only the graphical part

```
Cursor Off

```vb
Wait 1

'locate works like the normal LCD locate statement

' LOCATE LINE,COLUMN LINE can be 1-8 and column 0-30

```
Locate 1 , 1

'Show some text

Lcd "MCS Electronics"

'And some othe text on line 2

Locate 2 , 1 : Lcd "T6963c support"

Locate 3 , 1 : Lcd "1234567890123456789012345678901234567890"

Locate 16 , 1 : Lcd "write this to the lower line"

Wait 2

Cls Text

```vb
'use the new LINE statement to create a box

'LINE(X0,Y0) - (X1,Y1), on/off

```
Line(0 , 0) -(239 , 127) , 255 ' diagonal line

Line(0 , 127) -(239 , 0) , 255 ' diagonal line

Line(0 , 0) -(240 , 0) , 255 ' horizontal upper line

Line(0 , 127) -(239 , 127) , 255 'horizontal lower line

Line(0 , 0) -(0 , 127) , 255 ' vertical left line

Line(239 , 0) -(239 , 127) , 255 ' vertical right line

```vb
Wait 2

' draw a line using PSET X,Y, ON/OFF

' PSET on.off param is 0 to clear a pixel and any other value to turn it on

For X = 0 To 140

```
Pset X , 20 , 255 ' set the pixel

```vb
Next

For X = 0 To 140

```
Pset X , 127 , 255 ' set the pixel

```vb
Next

Wait 2

'circle time

'circle(X,Y), radius, color

'X,y is the middle of the circle,color must be 255 to show a pixel and 0 to clear a pixel

For X = 1 To 10

```
Circle(20 , 20) , X , 255 ' show circle

Wait 1

Circle(20 , 20) , X , 0 'remove circle

```vb
Wait 1

Next

Wait 2

For X = 1 To 10

```
Circle(20 , 20) , X , 255 ' show circle

```vb
Waitms 200

Next

Wait 2

'Now it is time to show a picture

'SHOWPIC X,Y,label

'The label points to a label that holds the image data

```
Test:

Showpic 0 , 0 , Plaatje

Showpic 0 , 64 , Plaatje ' show 2 since we have a big display

Wait 2

Cls Text ' clear the text

```vb
End

'This label holds the mage data

```
Plaatje:

```vb
'$BGF will put the bitmap into the program at this location

$bgf "mcs.bgf"

'You could insert other picture data here

```

---

## CLEAR

Action

Clear serial input or output buffer

Syntax

CLEAR bufname

Remarks

Bufname | Serial buffer name to clear.  SERIALIN, SERIALIN0 - COM1/UART0 input buffer SERIALIN1 - COM2/UART1 input buffer SERIALIN2 - COM3/UART2 input buffer SERIALIN3 - COM4/UART3 input buffer SERIALIN4 - COM5/UART4 input buffer SERIALIN5 - COM6/UART5 input buffer SERIALIN6 - COM7/UART6 input buffer SERIALIN7 - COM8/UART7 input buffer SERIALOUT,SERIALOUT0 - COM1/UART0 output buffer SERIALOUT1 - COM2/UART1 output buffer SERIALOUT2 - COM3/UART2 output buffer SERIALOUT3 - COM4/UART3 output buffer SERIALOUT4 - COM5/UART4 output buffer SERIALOUT5 - COM6/UART5 output buffer SERIALOUT6 - COM7/UART6 output buffer SERIALOUT7 - COM8/UART7 output buffer  
---|---  
  
When you use buffered serial input or buffered serial output, you might want to clear the buffer.

While you can make the head pointer equal to the tail pointer, an interrupt could be active which might result in an update of the buffer variables, resulting in an unexpected result.

The CLEAR statement will reset the head and tail pointers of the ring buffer, and it will set the buffer count variable to 0. The buffer count variable is new and introduced in 1.11.8.3. It counts how many bytes are in the buffer.

The internal buffercount variable is named _RS_BUFCOUNTxy , where X is R for Receive, and W for Write, and y is 0 for the first UART, and 1 for the second UART.

See also

[CONFIG SERIALIN](config_serialin.md), [CONFIG SERIALOUT](config_serialout.md)

ASM

Calls _BUF_CLEAR from MCS.LIB

Example

CLEAR SERIALIN

---

## Clear_B

Action

Clear buffers to preset values.

(This is similar to CLS)

Syntax

Clear_B C,S,T 

Remarks

C | Clear Color buffer. Setting this bit to 1 will clear the color buffer of the FT800 to the preset value.  Setting this bit to 0 will maintain the color buffer of the FT800 with an unchanged value.  The preset value is defined in command [ClearColorRGB](clearcolorrgb.md) for the RGB channel and [ClearColorA](clearcolora.md) for the alpha channel.  
---|---  
S | Clear Stencil buffer. Setting this bit to 1 will clear the stencil buffer of the FT800 to the preset value. Setting this bit to 0 will maintain the stencil buffer of the FT800 with an unchanged value. The preset value is defined in command [ClearStencil](clearstencil.md).  
T | Clear Tag buffer. Setting this bit to 1 will clear the tag buffer of the FT800 to the preset value. Setting this bit to 0 will maintain the tag buffer of the FT800 with an unchanged value. The preset value is defined in command [ClearTag](cleartag.md).  
  
The scissor test and the buffer write masks affect the operation of the clear. Scissor limits the cleared rectangle, and the buffer write masks limit the affected buffers.

The state of the alpha function, blend function, and stenciling do not affect the clear.

See also

[ClearColorA](clearcolora.md), [ClearStencil](clearstencil.md), [ClearTag](cleartag.md), [ClearColorRGB](clearcolorrgb.md)

Example

```vb
' Pseudocode

' To Clear the LCD to bright blue:

```
ClearColorRGB 0, 0, 255

Clear_B 1, 0, 0

![clip0099](clip0099.png)

```vb
' Pseudocode

' To clear part of the screen to gray, part to blue using scissor rectangles:

```
ClearColorRGB 100, 100, 100

Clear_B 1, 1, 1

ClearColorRGB 0, 0, 255

ScissorScize 30, 120

Clear_B 1, 1, 1

![clip0100](clip0100.png)

---

## CLEARATTR

Action

Clears the file Attribute.

Syntax

CLEARATTR [sFile] , bFileAttribute

Remarks

sFile | The name of the file (no wildcard) which attribute need to be cleared. You may also omit the name in which case the file will be used previous found by the DIR() function.  
---|---  
bFileAttribute | Numeric variable holding the attribute bits to clear.  
  
This functions clears the DOS file attributes. A file can have multiple attributes.

You should not use attributes 8(Volume) and 16(Sub Directory) on a normal file. 

Return value | DOS Attribute  
---|---  
1 | Read Only  
2 | Hidden  
4 | System File  
8 | Volume Label  
16 | Sub Directory  
32 | Archive  
64,128 | reserved  
  
A file can have multiple bits set like 3 (hidden + read only). So you can clear multiple bits by combining the bits.

When you specify the filename, make sure it does not have a wildcard. CLEARTTR does not support wildcards.

When you omit the filename, the last found file from [DIR](dir.md)() will be used for the operation.

In VB, CLEARATTR expects a new value for the attribute which replaces the old attribute byte.

In AVR-DOS you specify the bits to clear. So old attribute bits which are not altered are kept. 

In AVR-DOS you can also set the individual bits using the SETRATTR statement.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md), [WRITE](write.md) , [INPUT](input.md) , [FILEATTR](fileattr.md) , [SETATTR](setattr.md) , [GETATTR](getattr.md)

Example

See [SETATTR](setattr.md)

---

## ClearColorA

Action

Specify the clear value for the alpha channel.

Syntax

ClearColorA Alpha 

Remarks

Alpha | Alpha value used when the color buffer is cleared. The initial value is 0  
---|---  
  
Sets the alpha value applied to drawn elements - points, lines, and bitmaps. How the alpha value affects image pixels depends on [BlendFunc](blendfunc.md), the default behavior is a transparent blend.

See also

[ColorRGB](colorrgb.md), [BlendFunc](blendfunc.md)

Example

```vb
' Pseudocode

' Drawing three characters with transparency 255, 128, and 64

```
Begin_G BITMAPS

Vertex2II 50, 30, 31, &H47

Color_A 128

Vertex2II 58, 38, 31, &H47

Color_A 64 

Vertex2II 66, 46, 31, &H47

![clip0102](clip0102.png)

---

## ClearColorRGB

Action

Specify the clear values for Red, Green and Blue channels.

Syntax

ClearColorRGB Red, Green, Blue

Remarks

Red | Red value used when the color buffer is cleared. The initial value is 0  
---|---  
Green | Green value used when the color buffer is cleared. The initial value is 0  
Blue | Blue value used when the color buffer is cleared. The initial value is 0  
  
Sets the color values used by a following [Clear_B](clear_b.md)

See also

[ClearColorA](clearcolora.md), [Clear_B](clear_b.md) , [ClearColorRGBdw](clearcolorrgbdw.md)

Example

```vb
' Pseudocode

' To clear the screen to bright blue:

```
ClearColorRGB 0, 0, 255

Clear_B 1, 1, 1

![clip0101](clip0101.png)

' To clear part of the screen to gray, part to blue using scissor rectangles:

ClearColorRGB 100, 100, 100

Clear_B 1, 1, 1

ClearColorRGB 0, 0, 255

ScissorScize 30, 120

Clear_B 1, 1, 1

![clip0100](clip0100.png)

---

## ClearColorRGBdw

Action

Specify the clear values for Red, Green and Blue channels.

Syntax

ClearColorRGBdw RGB 

Remarks

RGB | Value in the range of 0 to &H00FFFFFF, Red is the most significant 8 bits and Blue is the least. So &Hff0000 is  bright Red.  
---|---  
  
Sets the color values used by a following [Clear_B](clear_b.md)

The following colors are defined by constants.

Color | Value  
---|---  
Black | &H000000  
White | &HFFFFFF  
Red | &HFF0000  
Lime | &H00FF00  
Blue | &H0000FF  
Yellow | &HFFFF00  
Cyan | &H00FFFF  
Magenta | &HFF00FF  
Silver | &HC0C0C0  
Grey | &H808080  
Maroon | &H800000  
Olive | &H808000  
Green | &H008000  
Purple | &H800080  
Teal | &H008080  
Navy | &H000080  
Brown | &H703800  
Orange | &H00A5FF  
  
See also

[ClearColorA](clearcolora.md), [Clear_B](clear_b.md) , [ClearColorRGB](clearcolorrgb.md)

Example

```vb
' Pseudocode

' To clear the screen to bright blue:

```
ClearColorRGBdw &H0000FF

Clear_B 1, 1, 1

---

## ClearScreen

Action

Clears the LCD with a Black Background. 

Syntax

ClearScreen

Remarks

NONE

---

## ClearStencil

Action

Specify clear value for the stencil buffer.

Syntax

ClearStencil s

Remarks

s | Value used when the stencil buffer is cleared. The initial value is 0  
---|---  
  
See also

[Clear_B](clear_b.md)

---

## ClearTag

Action

Specify clear value for the tag buffer.

Syntax

ClearTag t

Remarks

t | Value used when the tag buffer is cleared. The initial value is 0.  
---|---  
  
See also

[Tag](tag.md), [TagMask](tagmask.md), [Clear_B](clear_b.md)

---

## CLOCKDIVISION

Action

Will set the system clock division available in some MEGA chips.

Syntax

CLOCKDIVISON = var

Remarks

Var | Variable or numeric constant that sets the clock division. Valid values are from 2-129. A value of 0 will disable the division.   
---|---  
  
On the MEGA 103 and 603 the system clock frequency can be divided so you can save power for instance. A value of 0 will disable the clock divider. The divider can divide from 2 to 127. So the other valid values are from 2 - 127.

Some routines that rely on the system clock will not work proper anymore when you use the divider. WAITMS for example will take twice the time when you use a value of 2.

Most new processors support a limited number of division factors which can be selected using [CONFIG CLOCKDIV](config_clockdiv.md).

See also

[POWERSAVE](powersave.md) , [CONFIG CLOCKDIV](config_clockdiv.md)

Example

```vb
$regfile = "m103def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

```
Clockdivision = 2

---

## CLOSE

Action

Closes an opened device.

Syntax

OPEN "device" for MODE As #channel

CLOSE #channel

Remarks

Device | The default device is COM1 and you don't need to open a channel to use INPUT/OUTPUT on this device. With the implementation of the software UART, the compiler must know to which pin/device you will send/receive the data. So that is why the OPEN statement must be used. It tells the compiler about the pin you use for the serial input or output and the baud rate you want to use. COMB.0:9600,8,N,2 will use PORT B.0 at 9600 baud with 2 stop bits. The format for COM1 is : COM1: Some chips have 2 UARTS. You can use COM2: to open the second HW UART. Other chips might have 4 or 8 UARTS. The format for the software UART is: COMpin:speed,8,N,stop bits[,INVERTED] Where pin is the name of the PORT-pin. Speed must be specified and stop bits can be 1 or 2. An optional parameter ,INVERTED can be specified to use inverted RS-232. Open "COMD.1:9600,8,N,1,INVERTED" For Output As #1 , will use pin PORTD.1 for output with 9600 baud, 1 stop bit and with inverted RS-232.  
---|---  
MODE | You can use BINARY or RANDOM for COM1 and COM2, but for the software UART pins, you must specify INPUT or OUTPUT.  
Channel | The number of the channel to open. Must be a positive constant >0.  
  
The statements that support the device are PRINT , INPUT and INPUTHEX , INKEY, WAITKEY.

Using CLOSE on a serial device is optional. Only a file as used with AVR-DOS requires a CLOSE.

The best place for the CLOSE statement is at the end of your program.

The INPUT statement in combination with the software UART, will not echo characters back because there is no default associated pin for this.

![notice](notice.jpg) For the AVR-DOS file system, you may place the CLOSE at any place in your program. This because the file system supports real file handles.

For the UART, SPI or other devices, you do not need to close the device. Only AVR-DOS needs a CLOSE so the file will be flushed. 

See also

[OPEN](open.md) , [PRINT](print.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : open.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates software UART

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 10000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim B As Byte

'Optional you can fine tune the calculated bit delay

'Why would you want to do that?

'Because chips that have an internal oscillator may not

'run at the speed specified. This depends on the voltage, temp etc.

'You can either change $CRYSTAL or you can use

'BAUD #1,9610

'In this example file we use the DT006 from www.simmstick.com

'This allows easy testing with the existing serial port

'The MAX232 is fitted for this example.

'Because we use the hardware UART pins we MAY NOT use the hardware UART

'The hardware UART is used when you use PRINT, INPUT or other related statements

'We will use the software UART.

Waitms 100

'open channel for output

```
Open "comd.1:19200,8,n,1" For Output As #1

```vb
Print #1 , "serial output"

'Now open a pin for input

```
Open "comd.0:19200,8,n,1" For Input As #2

```vb
'since there is no relation between the input and output pin

'there is NO ECHO while keys are typed

Print #1 , "Number"

'get a number

Input #2 , B

'print the number

Print #1 , B

'now loop until ESC is pressed

'With INKEY() we can check if there is data available

'To use it with the software UART you must provide the channel

Do

'store in byte

```
B = Inkey(#2)

```vb
'when the value > 0 we got something

If B > 0 Then

Print #1 , Chr(b) 'print the character

End If

Loop Until B = 27

```
Close #2

Close #1

```vb
'OPTIONAL you may use the HARDWARE UART

'The software UART will not work on the hardware UART pins

'so you must choose other pins

'use normal hardware UART for printing

'Print B

'When you dont want to use a level inverter such as the MAX-232

'You can specify ,INVERTED :

'Open "comd.0:300,8,n,1,inverted" For Input As #2

'Now the logic is inverted and there is no need for a level converter

'But the distance of the wires must be shorter with this

End

```

---

## CLS

Action

Clear the LCD display and set the cursor to home.

Syntax

CLS

Syntax for graphical LCD

CLS

CLS TEXT

CLS GRAPH

CLS Y, X1 , X2 [, CHAR]

Remarks

Clearing the LCD display does not clear the CG-RAM in which the custom characters are stored.

For graphical LCD displays CLS will clear both the text and the graphical display.

The EADOG128 and KS108 support the option to clear a portion of a line. Depending on the used graphic chip, this option might be added to other graphical LCD lib's too. 

Graphical displays coordinates start with 1. To clear the entire first line you need to code : CLS 1,1,128

This will clear the first line, from the starting position X1(1) to the ending position(X2). You may specify an optional character to use. By default 0 is used. When you have inverse text, you need to use 255. 

See also

[$LCD](lcd_1.md) , [$LCDRS](lcdrs.md) , [LCD](lcd_2.md) , [SHIFTLCD](shiftlcd.md) , [SHIFTCURSOR](shiftcursor.md) , [SHIFTLCD](shiftlcd.md) , [INITLCD](initlcd.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : lcd.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: LCD, CLS, LOWERLINE, SHIFTLCD, SHIFTCURSOR, HOME

' CURSOR, DISPLAY

'micro : Mega8515

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m8515.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$sim

'REMOVE the above command for the real program !!

'$sim is used for faster simulation

'note : tested in PIN mode with 4-bit

'Config Lcdpin = Pin , Db4 = Portb.1 , Db5 = Portb.2 , Db6 = Portb.3 , Db7 = Portb.4 , E = Portb.5 , Rs = Portb.6

Config Lcdpin = Pin , Db4 = Porta.4 , Db5 = Porta.5 , Db6 = Porta.6 , Db7 = Porta.7 , E = Portc.7 , Rs = Portc.6

'These settings are for the STK200 in PIN mode

'Connect only DB4 to DB7 of the LCD to the LCD connector of the STK D4-D7

'Connect the E-line of the LCD to A15 (PORTC.7) and NOT to the E line of the LCD connector

'Connect the RS, V0, GND and =5V of the LCD to the STK LCD connector

```
Rem with the config lcdpin statement you can override the compiler settings

```vb
Dim A As Byte

Config Lcd = 16 * 2 'configure lcd screen

'other options are 16 * 4 and 20 * 4, 20 * 2 , 16 * 1a

'When you dont include this option 16 * 2 is assumed

'16 * 1a is intended for 16 character displays with split addresses over 2 lines

'$LCD = address will turn LCD into 8-bit databus mode

' use this with uP with external RAM and/or ROM

' because it aint need the port pins !

```
Cls 'clear the LCD display

Lcd "Hello world." 'display this at the top line

Wait 1

Lowerline 'select the lower line

Wait 1

Lcd "Shift this." 'display this at the lower line

```vb
Wait 1

For A = 1 To 10

```
Shiftlcd Right 'shift the text to the right

```vb
Wait 1 'wait a moment

Next

For A = 1 To 10

```
Shiftlcd Left 'shift the text to the left

```vb
Wait 1 'wait a moment

Next

```
Locate 2 , 1 'set cursor position

Lcd "*" 'display this

Wait 1 'wait a moment

Shiftcursor Right 'shift the cursor

Lcd "@" 'display this

Wait 1 'wait a moment

Home Upper 'select line 1 and return home

Lcd "Replaced." 'replace the text

Wait 1 'wait a moment

Cursor Off Noblink 'hide cursor

Wait 1 'wait a moment

Cursor On Blink 'show cursor

Wait 1 'wait a moment

Display Off 'turn display off

Wait 1 'wait a moment

Display On 'turn display on

'-----------------NEW support for 4-line LCD------

Thirdline

Lcd "Line 3"

Fourthline

Lcd "Line 4"

Home Third 'goto home on line three

Home Fourth

Home F 'first letteer also works

Locate 4 , 1 : Lcd "Line 4"

```vb
Wait 1

'Now lets build a special character

'the first number is the characternumber (0-7)

'The other numbers are the rowvalues

'Use the LCD tool to insert this line

```
Deflcdchar 1 , 225 , 227 , 226 , 226 , 226 , 242 , 234 , 228 ' replace ? with number (0-7)

Deflcdchar 0 , 240 , 224 , 224 , 255 , 254 , 252 , 248 , 240 ' replace ? with number (0-7)

Cls 'select data RAM

Rem it is important that a CLS is following the deflcdchar statements because it will set the controller back in datamode

Lcd Chr(0) ; Chr(1) 'print the special character

'----------------- Now use an internal routine ------------

_temp1 = 1 'value into ACC

!rCall _write_lcd 'put it on LCD

End

---

## CMD16

Action

This statement will send a word to the FT800 graphic processor.

Syntax

CMD16 prm

Remarks

CMD16 expects a numeric parameter. It will call the _cmd16 assembled code in FT800.LIB

See also

[CMD8](cmd8.md) , [CMD32](cmd32.md) , [WR8](wr8.md) , [WR16](wr16.md) , [WR32](wr32.md)

Example  
```vb
Sub Cmdprogress(bystack X As Integer , Bystack Y As Integer , Bystack W As Integer , Bystack H As Integer , Bystack Options As Word , Bystack Value As Word , Bystack Range As Word)  
  
' Draws a Progress Bar  
  
' Options Are  
' OPT_3D = 0  
' OPT_FLAT  
  
```
Cmd32 Cmd_progress  
cmdftstack 14  
Cmd16 &H0000  
  
```vb
' was a total of 18 bytes, to align with 4byte boundary it had to be offset of 20  
End Sub

```

---

## CMD32

Action

This statement will send a dword to the FT800 graphic processor.

Syntax

CMD32 prm

Remarks

CMD32 expects a numeric parameter. It will call the _cmd32 assembled code in FT800.LIB

See also

[CMD8](cmd8.md) , [CMD16](cmd16.md) , [WR8](wr8.md) , [WR16](wr16.md) , [WR32](wr32.md)

Example

```vb
Sub Cmdnumber(bystack X As Integer , Bystack Y As Integer , Bystack Fontx As Integer , Bystack Options As Word , Bystack Num As Long)  
'------------------------------------------------------------------------------------------------------------  
' Draws a Decimal Number  
' No Justification = 0  
' OPT_CENTERX  
' OPT_CENTERY  
' OPT_CENTER  
' OPT_RIGHTX  
' OPT_SIGNED  
  
```
Cmd32 Cmd_number  
cmdftstack 12  
End Sub

---

## CMD8

Action

This statement will send a byte to the FT800 graphic processor.

Syntax

CMD8 prm

Remarks

CMD8 expects a numeric parameter. It will call the _cmd8 assembler code in FT800.LIB

See also

[CMD16](cmd16.md) , [CMD32](cmd32.md) , [WR8](wr8.md) , [WR16](wr16.md) , [WR32](wr32.md)

Example

Sub Cmdinflatex(byval Ptr As Dword , Byref Varaddress As Word , Byval Count As Dword)  
  
Local Length As Dword  
  
Cmd32 Cmd_inflate  
Cmd32 Ptr  
  
For Length = 1 To Count  
Tb = Cpeek(varaddress)  
Cmd8 Tb  
Incr Varaddress  
Next  
  
Alignfifo Count  
  
End Sub

---

## CmdAppend

Action

Appends a block of memory to the current display list memory address where the offset is specified in REG_CMD_DL.

Syntax

CmdAppend Ptr, Num

Remarks

Ptr | Start of source commands in main memory  
---|---  
Num | Number of bytes to copy. This must be a multiple of 4  
  
After appending is done, the co-processor engine will increase the REG_CMD_DL by num to make sure the display list is in order.

Example

' Pseudocode

CmdAppend 0, 40 ' Copy 10 commands from main memory address 0

Display_E  ' finish the display list

---

## CmdBgColor

Action

Set the Background Color.

Syntax

CmdBgColor rgb

Remarks

rgb | New Background color, as a 24-bit RGB number. Red is the most significant 8 bits and Blue is the least. So &Hff0000 is bright Red. Background color is applicable for things that the user can move. example: behind gauges and sliders etc..  
---|---  
  
See also

[CmdFgColor](new_cf_card_drivers.md)

Example

' Pseudocode

xOffset = 40  
yOffset = 80  
' Draw horizontal Toggle bars  
CmdBgColor &H800000  
CmdFgColor &H410105  
CmdToggle xOffset, yOffset, 30, 27, 0, 65535, "-ve" + gap + "+ve"  
CmdFgColor &H0b0721  
CmdBgColor &H000080

' The top scrollbar uses the default foreground color, the others with a changed color

CmdScrollBar 20, 30, 120, 8, 0, 10, 40, 100

CmdFgColor &H402000

CmdScrollBar 20, 60, 120, 8, 0, 30, 40,100

CmdFgColor &H202020

CmdScrollBar 20, 90, 120, 8, 0, 50, 40, 100

![clip0109](clip0109.png)

---

## CmdButton

Action

Draw a button.

Syntax

CmdButton x, y, w, h ,font, options, text

Remarks

x | x-coordinate of button top-left, in pixels  
---|---  
y | y-coordinate of button top-left, in pixels  
w | width of button, in pixels  
h | height of button, in pixels  
font | Internal Fonts 16-31, User Defined Fonts 0-14  
options | By default the button is drawn with a 3D effect, OPT_FLAT removes the 3D effect.  
text | Text to display, valid printable ASCII code 32 to 127. For Custom/User Defined font, the ASCII code is from 1 to 127.  
  
Example

' Pseudocode

CmdButton 10, 10, 50, 25, 26, 0, "One"  
CmdButton 10, 40, 50, 25, 26, 0, "Two"  
CmdButton 10, 70, 50, 25, 26, 0, "Three"

' A 140x00 pixel button with large text

CmdButton 10, 10, 140, 100, 31, 0,"Press!"

![clip0105](clip0105.png)

' Several smaller buttons

CmdButton 10, 10, 50, 25, 26, 0, "One"

CmdButton 10, 40, 50, 25, 26, 0, "Two"

CmdButton 10, 70, 50, 25, 26, 0, "Three"

![clip0106](clip0106.png)

' Changing button color

CmdFgColor &Hb9b900

CmdButton 10, 10, 50, 25, 26, 0, "Banana"

CmdFgColor &Hb97300

CmdButton 10, 40, 50, 25, 26, 0, "Orange"

CmdFgColor &Hb90007

CmdButton 10, 70, 50, 25, 26, 0, "Cherry"

![clip0107](clip0107.png)

---

## CmdCalibrate

Action

Execute the touch screen calibration routine.

Syntax

CmdCalibrate

Remarks

The calibration procedure collects three touches from the touch screen, then computes and loads an appropriate matrix into REG_TOUCH_TRANSFORM_A-F. To use it, create a display list and then use [CmdCalibrate](cmdcalibrate.md). The co-processor engine overlays the touch

targets on the current Display List, gathers the calibration input and updates REG_TOUCH_TRANSFORM_A-F.

The completion of this function is detected when the value of REG_CMD_READ is equal to REG_CMD_WRITE.

---

## CmdCalibratex

Action

Execute the touch screen calibration routine.

This is all in one routine with displaying prompts on the screen and updating of the REG_TOUCH_TRANSFORM_A-F registers.

Syntax

CmdCalibratex

Remarks

The calibration procedure collects three touches from the touch screen, then computes and loads an appropriate matrix into REG_TOUCH_TRANSFORM_A-F. To use it, create a display list and then use [CmdCalibrate](cmdcalibratex.md). The co-processor engine overlays the touch

targets on the current Display List, gathers the calibration input and updates REG_TOUCH_TRANSFORM_A-F.

Note: You can Automatically let Bascom do the Screen calibration for you.

Or if you want to force an Screen calibration at anytime:

1.| Press on the LCD panel  
---|---  
  
2.| Reset your project  
---|---  
  
3.| When you release from the LCD the Screen calibration message will appear.  
---|---  
  
To enable this mode, set LcdCal = 1 from the FT800.inc file.

Const LcdCal = 1 ' Prompts for LCD Calibration (if not previously done)

See also

[CmdCalibrate](cmdcalibrate.md)

---

## CmdClock

Action

Draw a Analog Clock.

Syntax

CmdClock x, y, r, options, h, m, s, ms

Remarks

x | x-coordinate of clock center, in pixels  
---|---  
y | y-coordinate of clock center, in pixels  
r | Radius of the gauge, in pixels  
options | By default the clock dial is drawn with a 3D effect and the name of this option is OPT_3D.  Option OPT_FLAT removes the 3D effect.  With option OPT_NOBACK, the background is not drawn. With option OPT_NOTICKS, the twelve hour ticks are not drawn.  With option OPT_NOSECS, the seconds hand is not drawn.  With option OPT_NOHANDS, no hands are drawn.  With option OPT_NOHM, no hour and minutes hands are drawn.   
h | hours  
m | minutes  
s | seconds  
ms | milliseconds  
  
The details of physical dimension are:

•| The 12 tick marks are placed on a circle of radius r*(200/256).  
---|---  
  
•| Each tick is a point of radius r*(10/256)  
---|---  
  
•| The seconds hand has length r*(200/256) and width r*(3/256)  
---|---  
  
•| The minutes hand has length r*(150/256) and width r*(9/256)  
---|---  
  
•| The hours hand has length r*(100/256) and width r*(12/256)  
---|---  
  
Refer to sections 5.7 Widgets physical dimensions and 5.7 Widget color settings in the FT800 Series Programmer Guide.PDF from FTDI

for more information.

Example

' A clock with radius 50 pixels, showing a time of 8.15

CmdClock 80, 60, 50, 0, 8, 15, 0, 0

![clip0024](clip0024.png)

' Setting the background color 

CmdBgColor &H401010

CmdClock 80, 60, 50, 0, 8, 15, 0, 0

![clip0025](clip0025.png)

' Without the 3D look

CmdClock 80, 60, 50, OPT_FLAT, 8, 15, 0, 0

```vb
' The time fields can have large values. Here the hours are (7 x 3600s) and minutes 

' are (38 x 60s), and seconds is 59. Creating a clock face showing the time as 7.38.59

```
CmdClock 80, 60, 50, 0, 0, 0, (7 * 3600) + (38 * 60) + 59, 0

![clip0026](clip0026.png)

' No seconds hand

CmdClock 80, 60, 50, OPT_NOBACK, 8, 15, 0, 0

![clip0027](clip0027.png)

' No background

CmdClock 80, 60, 50, OPT_NOBACK, 8, 15, 0, 0

![clip0028](clip0028.png)

' No Ticks

CmdClock 80, 60, 50, OPT_NOTICKS, 8, 15, 0, 0

![clip0029](clip0029.png)

' No Hands

CmdClock 80, 60, 50, OPT_NOHANDS, 8, 15, 0, 0

![clip0030](clip0030.png)

---

## CmdColdStart

Action

This command sets co-processor engine to reset default states.

Syntax

CmdColdStart

Remarks

Example

' Pseudocode

CmdFgColor &H00C040

CmdGradColor &H000000

CmdButton 2, 32, 76, 56, 26, 0, "custom"

CmdColdStart

CmdButton 82, 32, 76, 56, 26, 0, "default"

![clip0005](clip0005.png)

---

## CmdDial

Action

Draw a rotary dial control.

Syntax

CmdDial x, y, r ,options, val

Remarks

x | x-coordinate of dial center, in pixels  
---|---  
y | y-coordinate of dial center, in pixels  
r | radius of dial, in pixels  
options | By default the dial is drawn with a 3D effect. Options OPT_FLAT removes the 3D effect.   
val | Specify the position of dial points by setting a value between 0 and 65535 inclusive.  0 means that the dial points straight down, &H4000 left, &H8000 up, and &Hc000 right.  
  
Example

```vb
' Pseudocode

' A dial set to 50%

```
CmdDial 80, 60, 55, 0, &H8000

![clip0006](clip0006.png)

' Without the 3D look

CmdDial 80, 60, 55, OPT_FLAT, &H8000

![clip0007](clip0007.png)

' Dials set to 0%, 33% and 66%

CmdDial 28, 60 , 24, 0, 0

CmdText 28, 100, 26, OPT_CENTER, "0%"

CmdDial 80, 60, 24, 0, &H5555

CmdText 80, 100, 26, OPT_CENTER, "33%"

CmdDial 132, 60, 24, 0, &HAAAA

CmdText 132, 100, 26, OPT_CENTER, "66%"

![clip0008](clip0008.png)

---

## CmdDlStart

Action

Start a New Display List.

When the co-processor engine executes this command, it waits until the display list is ready for writing, then sets Reg_Cmd_DL to zero.

Syntax

CmdDlStart

Remarks

In most of FTDI's FT800 C/C++ examples you will notice this command is used at the beginning of each loop or graphic routine.

Note: The Bascom FT800 Lib calls CmdDlStart from within [UpdateScreen](upperline.md) so it's not required in most circumstances.

---

## CmdFgColor

Action

Set the Foreground Color.

Syntax

CmdFgColor rgb

Remarks

rgb | New Foreground color, as a 24-bit RGB number. Red is the most significant 8 bits and Blue is the least. So &Hff0000 is bright Red. Foreground color is applicable for things that the user can move such as handles and buttons.  
---|---  
  
See also

[CmdBgColor](new_cf_card_drivers.md)

Example

' Pseudocode

xOffset = 40  
yOffset = 80  
' Draw horizontal Toggle bars  
CmdBgColor &H800000  
CmdFgColor &H410105  
CmdToggle xOffset, yOffset, 30, 27, 0, 65535, "-ve" + gap + "+ve"  
CmdFgColor &H0b0721  
CmdBgColor &H000080

' The top scrollbar uses the default foreground color, the others with a changed color

CmdScrollBar 20, 30, 120, 8, 0, 10, 40, 100

CmdFgColor &H703800

CmdScrollBar 20, 60, 120, 8, 0, 30, 40,100

CmdFgColor &H387000

CmdScrollBar 20, 90, 120, 8, 0, 50, 40, 100

![clip0108](clip0108.png)

---

## CMDFTSTACK

Action

This FT800 command will send data from the soft stack to the FT800 processor.

Syntax

CMDFTSTACK bts [,opt]

Remarks

bts | The number of bytes to pop from the stack.  
---|---  
opt | An optional parameter to change stack clean up. When no parameter or 0 is specified, the soft stack will be cleaned up. But when a string is passed you can not clean up the stack since the pointers would point to the wrong address. In such a case specify a numeric value like 2 so the compiler will not clean up the stack. You must clean up the stack before the code returns. You can do this with the ADIW asm command. Please make sure you adjust with the same amount of bytes as you passed.  
  
See also

[FT800](ft800.md) , [CMD32](cmd32.md)

Example

```vb
'------------------------------------------------------------------------------------------------------------  
Sub Cmdbutton(bystack X As Integer , Bystack Y As Integer , Bystack W As Integer , Bystack H As Integer , Bystack Fontx As Integer , Bystack Options As Word , Byval S As String)  
'------------------------------------------------------------------------------------------------------------  
' Draws Keyboard like buttons  
  
' Options Are  
' OPT_3D = 0  
' OPT_FLAT  
  
If Asc(S) = 0 Or Asc(S) > 127 then

```
!adiw yl,12 ; manual clean up stack

```vb
Exit Sub

End if   
  
```
Cmd32 Cmd_button  
cmdftstack 12,2 'pop and transmit 12 bytes, option 2 means, no stack clean up  
Cmdstr S 'because we access this string we could not clean up   
! adiw yl,12 ; manual clean up stack  
End Sub

---

## CmdGauge

Action

Draw a Gauge.

Syntax

CmdGauge x, y, r, options, major, minor, val, range

Remarks

x | X-coordinate of gauge center, in pixels  
---|---  
y | Y-coordinate of gauge center, in pixels  
r | Radius of the gauge, in pixels  
options | By default the gauge dial is drawn with a 3D effect and the value of options is  zero. OPT_FLAT removes the 3D effect. With option OPT_NOBACK, the  background is not drawn. With option OPT_NOTICKS, the tick marks are not  drawn. With option OPT_NOPOINTER, the pointer is not drawn.   
major | Number of major subdivisions on the dial, 1-10 minor  
minor | Number of minor subdivisions on the dial, 1-10  
val | Gauge indicated value, between 0 and range, inclusive range  
range | Maximum value  
  
The details of physical dimension are:

•| The tick marks are placed on a 270 degree arc, clockwise starting at southwest position  
---|---  
  
•| Minor ticks are lines of width r*(2/256), major r*(6/256)  
---|---  
  
•| Ticks are drawn at a distance of r*(190/256) to r*(200/256)  
---|---  
  
•| The pointer is drawn with lines of width r*(4/256), to a point r*(190/256) from the center  
---|---  
  
•| The other ends of the lines are each positioned 90 degrees perpendicular to the pointer direction, at a distance r*(3/256) from the center  
---|---  
  
Refer to sections 5.7 Widgets physical dimensions and 5.7 Widget color settings in the FT800 Series Programmer Guide.PDF from FTDI

for more information.

Example

```vb
' Pseudocode

' A gauge with radius 50 pixels, five divisions of four ticks each, indicating 30%

```
CmdGauge 80, 60, 50, 0, 5, 4, 30, 100

![clip0010](clip0010.png)

' Without the 3D look

CmdGauge 80, 60, 50, OPT_FLAT, 5, 4, 30, 100

![clip0011](clip0011.png)

' Ten major divisions with two minor divisions each

CmdGauge 80, 60, 50, 0, 10, 2, 30, 100

![clip0013](clip0013.png)

' Setting the minor divisions to 1 makes them disappear

CmdGauge 80, 60, 50, 0, 10, 1, 30, 100

![clip0014](clip0014.png)

' Setting the major divisions to 1 gives minor divisions only

CmdGauge 80, 60, 50, 0, 1, 10, 30, 100

![clip0015](clip0015.png)

' A smaller gauge with a brown background

CmdBgColor &H402000

CmdGauge 80, 60, 25, 0, 5, 4, 30, 100

![clip0016](clip0016.png)

' Scale 0-1000, indicating 1000

CmdGauge 80, 60, 50, 0, 5, 2, 1000, 1000

![clip0017](clip0017.png)

' Scaled 0-65535, indicating 49152

CmdGauge 80, 60, 50, 0, 4, 4, 49152, 65535

![clip0018](clip0018.png)

' No background

CmdGauge 80, 60, 50, OPT_NOBACK, 4, 4, 49152, 65535

![clip0019](clip0019.png)

---

## CmdGetMatrix

Action

Retrieves the current matrix coefficients.

Syntax

CmdGetMatrix a, b ,c, d, e, f

Remarks

a | Output parameter; written with matrix coefficient a. See [BitmapTransform](bitmaptransform.md) for formatting.  
---|---  
b | Output parameter; written with matrix coefficient b. See [BitmapTransform](bitmaptransform.md) for formatting.  
c | Output parameter; written with matrix coefficient c. See [BitmapTransform](bitmaptransform.md) for formatting.  
d | Output parameter; written with matrix coefficient d. See [BitmapTransform](bitmaptransform.md) for formatting.  
e | Output parameter; written with matrix coefficient e. See [BitmapTransform](bitmaptransform.md) for formatting.  
f | Output parameter; written with matrix coefficient f. See [BitmapTransform](bitmaptransform.md) for formatting.  
  
To retrieve the current matrix within the context of co-processor engine. Please note the matrix within the context of co-processor engine will not apply to the bitmap transformation until it is passed to graphics engine through [CmdGetMatrix](cmdgetmatrix.md).

Example

---

## CmdGetPtr

Action

Get the end memory address of inflated data.

Syntax

CmdGetPtr result

Remarks

result | The end address of decompressed data done by [CmdInflate](cmdinflate.md). The starting address of decompressed data as was specified by [CmdInflate](cmdinflate.md), while the end address of decompressed data can be retrieved by this command. It is one out parameter and can be passed in as any value with [CmdGetPtr](cmdgetptr.md) to RAM_CMD.   
---|---

---

## CmdGradColor

Action

Set the 3D button highlight color.

Syntax

CmdGradColor c

Remarks

c | New highlight gradient color, as a 24-bit RGB number. Red is the most significant 8 bits, blue is the least.  So &Hff0000 is bright red.  
---|---  
  
Gradient is supported only for Button and Keys widgets.

Example

```vb
' Pseudocode

' Changing the gradient color: white (the default), red, green and blue

```
CmdFgColor &H101010

CmdButton 2, 2, 76, 56, 31, 0, "W"

CmdGradColor &Hff0000

CmdButton 82, 2, 76, 56, 31, 0, "R"

CmdGradColor &H00ff00

CmdButton 2, 62, 76, 56, 31, 0, "G"

CmdGradColor &H0000ff

CmdButton 82, 62, 76, 56, 31, 0,"B"

![clip0110](clip0110.png)

' The gradient color is also used for keys

CmdFgColor &H101010

CmdKeys 10, 10, 140, 30, 26, 0, "abcde"

CmdGradColor &Hff0000

CmdKeys 10, 50, 140, 30, 26, 0, "fghij"

![clip0111](clip0111.png)

---

## CmdGradient

Action

Draw a smooth color gradient.

Syntax

CmdGradient x0, y0, rgb0, x1, y1, rgb1

Remarks

x0 | x-coordinate of point 0, in pixels  
---|---  
y0 | y-coordinate of point 0, in pixels  
rgb0 | Color of point 0, as a 24-bit RGB number. r is the most significant 8 bits, b is the least. So &hff0000 is bright red.  
x1 | x-coordinate of point 1, in pixels  
y1 | y-coordinate of point 1, in pixels  
rgb1 | Color of point 1.  
  
All the colour step values are calculated based on smooth curve interpolated from the rgb0 to rgb1 parameter. 

The smooth curve equation is independently calculated for all three colors and the equation used is R0 + t * (R1 - R0), where t is interpolated between 0 and 1. 

Gradient must be used with Scissor function to get the intended gradient display

Example

' Pseudocode

ClearScreen  
ColorRGB 255, 255, 255  
ScissorSize wScissor, hScissor  
' Horizontal gradient effect  
ScissorXY xOffset, yOffset ' Clip the Display  
CmdGradient xOffset, yOffset, &H808080, xOffset + wScissor, yOffset, &HFFFF00

Example

```vb
' Pseudocode

' A horizontal gradient from blue to red

```
CmdGradColor 0, 0, &H0000ff, 160, 0, &Hff0000

![clip0020](clip0020.png)

' A vertical gradient

CmdGradColor 0, 0, &H808080, 0, 120, &H80ff40

![clip0021](clip0021.png)

' The same colors in a diagonal gradient

CmdGradColor 0, 0, &H808080, 160, 120, &H80ff40

![clip0023](clip0023.png)

'Using a scissor rectangle to draw a gradient stripe as a background for a title

ScissorXY 20, 40

ScissorSize 120, 32

CmdGradient 20, 0, &H606060, 140, 0, &H404080

CmdText 23, 40, 29, 0, "Heading 1"

![clip0022](clip0022.png)

---

## CmdInflate

Action

Decompress data into memory.

Syntax

CmdInflate ptr

Remarks

ptr | Destination address. The data byte should immediate follow in the command buffer  
---|---  
  
If the number of bytes is not a multiple of 4, then 1, 2 or 3 bytes should be appended to ensure 4-byte alignment of the next command. These padding bytes can have any value Command layout.

Example

' See demos - FT800 Gauges.bas (Sub IntroFTDI), DigitTest.bas

---

## CmdInterrupt

Action

Trigger an Interrupt Int_CmdFlag

Syntax

CmdInterrupt ms

Remarks

ms | Delay before interrupt triggers, in milliseconds. The interrupt is guaranteed not to fire before this delay. If ms is zero, the Interrupt fires immediately.  
---|---  
  
When the co-processor engine executes this command, it triggers Interrupt Int_CmdFlag

---

## CmdKeys

Action

draw a row of keys.

Syntax

CmdKeys x, y, w ,h, font, options, char

Remarks

x | x-coordinate of keys top-left, in pixels  
---|---  
y | y-coordinate of keys top-left, in pixels  
w | The width of the keys  
h | The height of the keys  
font | Bitmap handle to specify the font used in key label. The valid range is from 0 to 31  
options | By default the keys are drawn with a 3D effect and the value of option is zero.  OPT_FLAT removes the 3D effect. If OPT_CENTER is given the keys are drawn at minimum size centered within the w x h rectangle. Otherwise the keys are expanded so that they completely fill the available space.  If an ASCII code is specified, that key is drawn 'pressed' - i.e. in background color with any 3D effect removed.  
char | Key labels, one character per key. The TAG value is set to the ASCII value of each key, so that key presses can be detected using the REG_TOUCH_TAG register.  
  
The gap between keys is 3 pixels.

For OPT_CENTERX case, the keys are (font width + 1.5) pixels wide ,otherwise keys are sized to fill available width.

Example

```vb
' Pseudocode

' A row of keys

```
CmdKeys 10, 10, 140, 30, 26, 0, "12345"

![clip0031](clip0031.png)

' Without the 3D look

CmdKeys 10, 10, 140, 30, 26, OPT_FLAT, "12345"

![clip0032](clip0032.png)

' Default vs. Centered

CmdKeys 10, 10, 140, 30, 26, 0, "12345"

CmdKeys 10, 60, 140, 30, 26, OPT_CENTER, "12345"

![clip0033](clip0033.png)

' Setting the options to show '2' key pressed ('2' is ASCII code &H32)

CmdKeys 10, 10, 140, 30, 26, &H32, "12345"

![clip0034](clip0034.png)

' A calculator-style keyboard using font 29

CmdKeys 22, 1, 116, 28, 29, 0, "789"

CmdKeys 22, 31, 116, 28, 29, 0, "456"

CmdKeys 22, 61, 116, 28, 29, 0, "123"

CmdKeys 22, 91, 116, 28, 29, 0, "0."

![clip0035](clip0035.png)

' A compact keyboard drawn in font 20

CmdKeys 2, 2, 156, 21, 20, OPT_CENTER, "qwertyuiop"

CmdKeys 2, 26, 156, 21, 20,OPT_CENTER, "asdfghijkl"

CmdKeys 2, 50, 156, 21, 20,OPT_CENTER, "zxcvbnm"

CmdButton 2,74, 156, 21, 20, 0, ""

![clip0036](clip0036.png)

' Showing the f (ASCII &H66) key pressed

CmdKeys 2, 2, 156, 21, 20, &H66 OR OPT_CENTER, "qwertyuiop"

CmdKeys 2, 26, 156, 21, 20, &H66 OR OPT_CENTER, "asdfghijkl"

CmdKeys 2, 50, 156, 21, 20, &H66 OR OPT_CENTER, "zxcvbnm"

CmdButton 2, 74, 156, 21, 20, 0, ""

![clip0037](clip0037.png)

---

## CmdLoadIdentity

Action

Set the current matrix to the identity matrix.

Syntax

CmdLoadIdentity

Remarks

This command instructs the co-processor engine of the FT800 to set the current matrix to the identity matrix, so that co-processor engine is able to form the new matrix as requested by [CmdScale](cmdscale.md), [CmdRotate](cmdrotate.md), [CmdTranslate](cmdtranslate.md) command. 

For more information on the identity matrix, please see section 2.5.5 Bitmap transformation matrix from the FT800 Series Programmer Guide.PDF (from FTDI).

---

## CmdLoadImage

Action

Load a JPEG image.

Syntax

CmdLoadImage ptr, options

Remarks

ptr | Destination address  
---|---  
options | By default, option OPT_RGB565 means the loaded bitmap is in RGB565 format.  Option OPT_MONO means the loaded bitmap to be monochrome, in L8 format. The command appends Display List commands to set the source, layout and size of the resulting image. Option OPT_NODL prevents this - nothing is written to the display list.  OPT_NODL can be OR'ed with OPT_MONO or OPT_RGB565.  
  
The data byte should immediately follow in the command buffer. If the number of bytes is not a multiple of 4, then 1, 2 or 3 bytes

should be appended to ensure 4-byte alignment of the next command. These padding bytes can have any value.

The application on the host processor has to parse the JPEG header to get the properties of the JPEG image and decide to decode. Behavior is unpredictable in cases of non baseline jpeg images or the output data generated is more than the RAM_G size.

Example

' See demos - FT800 Demo2.bas, FT800 LoadImage.bas

---

## CmdLogo

Action

Play device logo animation.

Syntax

CmdLogo

Remarks

The logo command causes the co-processor engine to play back a short animation of the FTDI logo. 

During logo playback the MCU should not access any FT800 resources. After 2.5 seconds have elapsed, the co-processor

engine writes zero to REG_CMD_READ and REG_CMD_WRITE, and starts waiting for commands. After this command is complete, 

the MCU shall write the next command to the starting address of RAM_CMD.

Example

' see it working - FT800 Gauges.bas, FT800 Keyboard.bas, FT800 Signals.bas and FT800 Sketch.bas

![clip0038](clip0038.png)

---

## CmdMemCpy

Action

Copy a block of memory.

Syntax

CmdMemCpy dst, src, num

Remarks

dst | address of the destination memory block  
---|---  
src | address of the source memory block  
num | number of bytes to copy  
  
The completion of this function is detected when the value of REG_CMD_READ is equal to REG_CMD_WRITE.

Example

```vb
' Pseudocode

' To copy 1K byte of memory from 0 to &H8000

```
CmdMemCpy &H8000, 0, 1024

---

## CmdMemCrc

Action

Compute a CRC-32 for memory.

Syntax

CmdMemCrc ptr, num, result

Remarks

ptr | Starting address of the memory block  
---|---  
num | Number of bytes in the source memory block  
result | Output parameter; written with the CRC-32 after command execution. The completion of this function is detected when the value of REG_CMD_READ is equal to REG_CMD_WRITE.  
  
Example

```vb
' Pseudocode

' To compute the CRC-32 of the first 1K byte of FT800 memory, first record the value 

' of REG_CMD_WRITE, execute the command, wait for completion, then read the 32-bit value at result.

```
x = Rd16(REG_CMD_WRITE)

CmdMemCrc 0, 1024, 0

Print Rd32(RAM_CMD + x + 12)

---

## CmdMemSet

Action

Fill memory with a byte value.

Syntax

CmdMemSet ptr, value, num

Remarks

ptr | Starting address of the memory block  
---|---  
value | Value to be written to memory  
num | Number of bytes in the memory block  
  
The completion of this function is detected when the value of REG_CMD_READ is equal to REG_CMD_WRITE.

Example

```vb
' Pseudocode

' To write 0xff the first 1K of main memory

```
CmdMemSet 0, 255, 1024

---

## CmdMemWrite

Action

Write bytes into memory.

Syntax

CmdMemWrite ptr, num, 

Remarks

ptr | The memory address to be written  
---|---  
result | Number of bytes to be written  
  
The data byte should immediately follow in the command buffer. If the number of bytes is not a multiple of 4, then

1, 2 or 3 bytes should be appended to ensure 4-byte alignment of the next command, these padding bytes can have any value.

The completion of this function can be detected when the value of REG_CMD_READ is equal to REG_CMD_WRITE.

Caution: if using this command, it may corrupt the memory of the FT800 if used improperly.

Example

```vb
' Pseudocode

' To change the backlight brightness to 64 (half intensity) for a particular screen shot

```
...

CmdSwap ' finish the display list

CmdDlStart ' wait until after the swap

CmdMemWrite REG_PWM_DUTY, 4 ' write to the PWM_DUTY register

---

## CmdMemZero

Action

Write zero to a block of memory.

Syntax

CmdMemZero ptr, num

Remarks

ptr | Starting address of the memory block  
---|---  
num | Number of bytes in the memory block  
  
The completion of this function is detected when the value of REG_CMD_READ is equal to REG_CMD_WRITE.

Example

```vb
' Pseudocode

' To erase the first 1K of main memory

```
CmdMemZero 0, 1024

---

## CmdNumber

Action

Draw a decimal number.

Syntax

CmdNumber x, y, font, options, n

Remarks

x | x-coordinate of text base, in pixels  
---|---  
y | y-coordinate of text base, in pixels  
font | font to use for text, 0-31. See ROM and RAM Fonts  
options | By default (x,y) is the top-left pixel of the text. OPT_CENTERX centers the text horizontally OPT_CENTERY centers it vertically.  OPT_CENTER centers the text in both directions.  OPT_RIGHTX right-justifies the text, so that the x is the rightmost pixel. By default the number is displayed with no leading zeroes, but if a width 1-9 is specified in the options, then the number is padded if necessary with leading zeroes so that it has the given width.  If OPT_SIGNED is given, the number is treated as signed, and prefixed by a minus sign if negative.  
n | The number to display, either unsigned or signed 32-bit. NOTE : while -2147483648 is valid for a long, the FT800 will show -18446744071562067968 (128 bit signed number) which seems a bug in the FT800.  
  
Example

```vb
' Pseudocode

' A number

```
CmdNumber 20, 60, 31, 0, 42

![clip0039](clip0039.png)

' Centered

CmdNumber 80, 60, 31, OPT_CENTER, 42

![clip0040](clip0040.png)

' Signed output of positive and negative numbers

CmdNumber 20, 20, 31, OPT_SIGNED, 42

CmdNumber 20, 60, 31, OPT_SIGNED, -42

![clip0041](clip0041.png)

' Forcing width to 3 digits, right-justified

CmdNumber 150, 20, 31, OPT_RIGHTX OR 3, 42

CmdNumber 150, 60, 31, OPT_SIGNED OR OPT_RIGHTX OR 3, -1

![clip0042](clip0042.png)

---

## CmdProgress

Action

Draw a progress bar.

Syntax

CmdProgress x, y, w, h, options, val, range

Remarks

x | x-coordinate of progress bar top-left, in pixels  
---|---  
y | y-coordinate of progress bar top-left, in pixels  
w | width of progress bar, in pixels  
h | height of progress bar, in pixels  
options | By default the progress bar is drawn with a 3D effect and the value of options  is zero. Options OPT_FLAT removes the 3D effect and its value is 256.  
val | Displayed value of progress bar, between 0 and range inclusive  
range | Maximum value  
  
The details of physical dimensions are:

•| x,y,w,h give outer dimensions of progress bar. Radius of bar (r) is min (w,h)/2  
---|---  
  
•| Radius of inner progress line is r * (7/8)  
---|---  
  
Example

```vb
' Pseudocode

' A progress bar showing 50% completion

```
CmdProgress 20, 50, 120, 12, 0, 50,100

![clip0043](clip0043.png)

' Without the 3D look

CmdProgress 20, 50, 120, 12, OPT_FLAT, 50, 100

![clip0044](clip0044.png)

' A 4 pixel high bar, range 0-65535, with a brown background

CmdBgColor &H402000

CmdProgress 20, 50, 120, 4, 0, 9000, 65535

![clip0045](clip0045.png)

---

## CmdRegRead

Action

Read a register value.

Syntax

CmdRegRead ptr, result

Remarks

ptr | Address of register to read  
---|---  
result | The register value to be read at ptr address  
  
Example

```vb
' Pseudocode

' To capture the exact time when a command completes:

```
x = Rd16(REG_CMD_WRITE

CmdRegread REG_CLOCK, 0

...

---

## CmdRotate

Action

Apply a rotation to the current matrix.

Syntax

CmdRotate anle 

Remarks

angle | Clockwise rotation angle, in units of 1/65536 of a circle  
---|---  
  
Remarks

[CMDROTATEA](cmdrotatea.md)

Example

```vb
' Pseudocode

' To rotate the bitmap clockwise by 10 degrees with respect to the top left of the bitmap

```
Begin_G BITMAPS

CmdLoadIdentity

CmdRotate 10 * 65536 / 360

CmdSetMatrix

Vertex2II 68, 28, 0, 0

![clip0046](clip0046.png)

' To rotate the bitmap counter clockwise by 33 degrees top left of the bitmap

Begin_G BITMAPS

CmdLoadIdentity

CmdRotate -33 * 65536 / 360

CmdSetMatrix

Vertex2II 68, 28, 0, 0

' Rotating a 64 x 64 bitmap around its center

Begin_G BITMAPS

CmdLoadIdentity

CmdTranslate 65536 * 32, 65536 * 32

CmdRotate 90 * 65536 / 360

CmdTranslate 65536 * -32, 65536 * -32

CmdSetMatrix

Vertex2II 68, 28, 0, 0

![clip0047](clip0047.png)

---

## CmdRotateA

Action

Apply a rotation in degrees to the current matrix

Syntax

CmdRotateA angle

Remarks

angle | Clockwise rotation angle, in degrees (0-360)  
---|---  
  
See Also

[CMDROTATE](cmdrotate.md)

Example

```vb
' Pseudocode

' To rotate the bitmap clockwise by 10 degrees with respect to the top left of the bitmap

```
Begin_G BITMAPS

CmdLoadIdentity

CmdRotate 10 

CmdSetMatrix

Vertex2II 68, 28, 0, 0

![clip0046](clip0046.png)

' To rotate the bitmap counter clockwise by 33 degrees top left of the bitmap

Begin_G BITMAPS

CmdLoadIdentity

CmdRotate -33 

CmdSetMatrix

Vertex2II 68, 28, 0, 0

' Rotating a 64 x 64 bitmap around its center

Begin_G BITMAPS

CmdLoadIdentity

CmdTranslate 65536 * 32, 65536 * 32

CmdRotate 90 

CmdTranslate 65536 * -32, 65536 * -32

CmdSetMatrix

Vertex2II 68, 28, 0, 0

![clip0047](clip0047.png)

---

## CmdScale

Action

Apply a scale to the current matrix.

Syntax

CmdScale sx, sy 

Remarks

sx | x scale factor, in signed 16. 16 bit fixed-point form  
---|---  
sy | y scale factor, in signed 16. 16 bit fixed-point form  
  
Example

```vb
' Pseudocode

' To zoom a bitmap 2X

```
Begin_G BITMAPS

CmdLoadIdentity

CmdScale 2 * 65536, 2 * 65536

CmdSetMatrix

Vertex2II 68, 28, 0, 0

![clip0048](clip0048.png)

' To zoom a bitmap 2X around its center

Begin_G BITMAPS

CmdLoadIdentity

CmdTranslate 65536 * 32, 65536 * 32

CmdScale 2 * 65536, 2 * 65536

CmdTranslate 65536 * -32, 65536 * -32

CmdSetMatrix

Vertex2II 68, 28, 0, 0

![clip0049](clip0049.png)

---

## CmdScreenSaver

Action

Start an animated screensaver.

Syntax

CmdScreenSaver

Remarks

After the screensaver command, the co-processor engine continuously updates REG_MACRO_0 with VERTEX2F with varying (x,y) coordinates. With an appropriate display list, this causes a bitmap to move around the screen without any MCU work.

Command CMD_STOP stops the update process.

Note that only one of [CmdSketch](cmdsketch.md), [CmdScreenSaver](cmdscreensaver.md) or [CmdSpinner](cmdspinner.md) can be active at one time.

REG_MACRO_0 is updated with respect to frequency of frames displayed (depending on the display registers configuration). 

Typically for 480x272 display the frame rate is around 60 frame per second.

Example

' see it working in FT800 Demo4.bas (Sub Screensaver)

---

## CmdScrollBar

Action

Draw a scroll bar.

Syntax

CmdScrollBar x, y, w, h, options, val, range, size, range

Remarks

x | x-coordinate of scroll bar top-left, in pixels  
---|---  
y | y-coordinate of scroll bar top-left, in pixels  
w | Width of scroll bar, in pixels. If width is greater than height, the scroll bar is drawn horizontally  
h | Height of scroll bar, in pixels. If height is greater than width, the scroll bar is drawn vertically  
options | By default the scroll bar is drawn with a 3D effect and the value of options is zero.  Options OPT_FLAT removes the 3D effect and its value is 256  
val | Displayed value of scroll bar, between 0 and range inclusive range  
range | Maximum value  
  
Example

```vb
' Pseudocode

' A scroll bar indicating 10-50%

```
CmdScrollBar 20, 50, 120, 8, 0, 10, 40, 100

![clip0050](clip0050.png)

' Without the 3D look

CmdScrollBar 20, 50, 120, 8, OPT_FLAT, 10, 40, 100

![clip0051](clip0051.png)

' A brown-themed vertical scroll bar

CmdBgColor &H402000

CmdFgColor &H703800

CmdScrollBar 140, 10, 8, 100, 0, 10, 40, 100

![clip0052](clip0052.png)

---

## CmdSetFont

Action

Set up a custom font.

Syntax

CmdSetFont font, ptr 

Remarks

font | The bitmap handle from 0 to 14. Bitmap handle 15 can be used conditionally  
---|---  
ptr | The metric block address in RAM. 4 bytes aligned is required.  
  
CmdSetFont is used to register one custom defined bitmap font into the FT800 coprocessor engine. After registration, the FT800

co-processor engine is able to use the bitmap font with its co-processor command.

Details on how to set up custom font, please refer to ROM and RAM Fonts from FTDI's FT800 Series Programmer Guide.PDF

Example

' See demos - DigitTest.bas and FT800 Demo3.bas

---

## CmdSetMatrix

Action

Write the current matrix to the Display List.

Syntax

CmdSetMatrix

Remarks

The co-processor engine assigns the value of the current matrix to the bitmap transform matrix of the graphics engine by generating Display List commands, i.e. BitmapTransformA-F. After this command, the following bitmap rendering operation will be affected by the new transform matrix.

---

## CmdSketch

Action

Start a continuous sketch update.

Syntax FT800

CmdSketch x, y, w, h, ptr, format

Syntax FT801

CmdSketch x, y, w, h, ptr, format , freq

Remarks

x | x-coordinate of sketch area top-left, in pixels  
---|---  
y | y-coordinate of sketch area top-left, in pixels  
w | Width of sketch area, in pixels  
h | Height of sketch area, in pixels  
ptr | Base address of sketch bitmap  
format | Format of sketch bitmap, either L1 or L8  
freq | The oversampling frequency. The typical value is 1500 to make sure the lines are connected smoothly. The value zero means no oversampling operation.  
  
FT800

Please note that update frequency of bitmap data in graphics memory depends on sampling frequency of ADC built-in circuit of FT800, which is up to 1000 Hz.

FT801

CmdSketch - Capacitive touch specific sketch This command has the same functionality as CmdSketch except it has done the optimization for a Capacitive Touch Panel.

Because Capacitive Touch Panels have lower sampling frequencies (around 100 Hz) to report the coordinates, the sketch functionality updates less frequently compared to resistive touch. CmdSketch introduces a linear interpolation algorithm to provide a smoother effect when drawing the output line.

After the sketch command, the co-processor engine continuously samples the touch inputs and paints pixels into a bitmap, according to the touch (x, y). This means that the user touch inputs are drawn into the bitmap without any need for MCU work. 

Command [CmdStop](cmdstop.md) stops the sketch process.

Note that only one of [CmdSketch](cmdsketch.md), [CmdScreenSaver](cmdscreensaver.md) or [CmdSpinner](cmdspinner.md) can be active at one time.

Example

' see demo - FT800 Sketch.bas also FT800 Demo4.bas (SUB Sketch)

---

## CmdSlider

Action

Draw a slider.

Syntax

CmdSlider x, y, w, h, options, val, range, size, range

Remarks

x | x-coordinate of scroll bar top-left, in pixels  
---|---  
y | y-coordinate of scroll bar top-left, in pixels  
w | Width of slider, in pixels. If width is greater than height, the scroll bar is drawn horizontally  
h | Height of slider, in pixels. If height is greater than width, the scroll bar is drawn vertically  
options | By default the slider is drawn with a 3D effect. OPT_FLAT removes the 3D effect  
val | Displayed value of slider, between 0 and range inclusive  
range | Maximum value  
  
Example

```vb
' Pseudocode

' A slider set to 50%

```
CmdSlider 20, 50, 120, 8, 0, 50, 100

![clip0053](clip0053.png)

' Without the 3D look

CmdSlider 20, 50, 120, 8, OPT_FLAT, 50, 100

![clip0054](clip0054.png)

' A brown-themed vertical slider with range 0-65535

CmdBgColor &H402000

CmdFgColor &H703800

CmdSlider 76, 10, 8, 100, 0, 20000, 65535

![clip0055](clip0055.png)

---

## CmdSnapShot

Action

Take a snapshot of the current screen.

Syntax

CmdSnapShot  ptr 

Remarks

ptr | Snapshot destination address, in RAM_G  
---|---  
  
This command causes the co-processor engine to take a snapshot of the current screen, and write the result into RAM_G as a ARGB4 bitmap.The size of the bitmap is the size of the screen, given by the REG_HSIZE and REG_VSIZE registers.

During the snapshot process, the display should be disabled by setting REG_PCLK to 0 to avoid display glitch.

Because co-processor engine needs to write the result into the destination address, the destination address must be never used or referenced by graphics engine.

Note: If you want to actual take Screen Captures - see FT800 Capture.Bas

Example

' See demo - FT800 Demo4.bas (Sub Snapshot)

---

## CmdStop

Action

Stop any of spinner, screensaver or sketch.

Syntax

CmdStop

Remarks

```vb
For [CmdSpinner](cmdspinner.md) and [CmdScreenSaver](cmdscreensaver.md), REG_MACRO_0 and REG_MACRO_1 will be stopped updating. 

For [CmdSketch](cmdsketch.md) the bitmap data in RAM_G will be stopped updating.

```
Example

```vb
' See FT800 Demo1.bas - Sub Widget_Spinner

' FT800 Demo4.bas - SUB Sketch, Sub Screensaver 

```

---

## CmdSwap

Action

Swap the current Display List

Syntax

CmdSwap

Remarks

When the co-processor engine executes this command, it requests a display list swap

immediately after current display list is scanned out. Internally, the co-processor engine

implements this command by writing to Reg_DlSwap

Note: The Bascom FT800 Lib calls CmdSwap from within [UpdateScreen](upperline.md) so it's not required in most circumstances.

---

## CmdText

Action

Draw Text.

Syntax

CmdText x, y, font, options, string

Remarks

x | x-coordinate of text base, in pixels  
---|---  
y | y-coordinate of text base, in pixels  
font | Internal Fonts 16-31, User Defined Fonts 0-14  
options | By default (x,y) is the top-left pixel of the text (options = 0).  OPT_CENTERX centers the text horizontally OPT_CENTERY centers it vertically OPT_CENTER centers the text in both directions OPT_RIGHTX right-justifies the text, so that the x is the rightmost pixel.  
string | text to display  
  
Example

ClearScreen  
ColorRGB &H80, &H80, &H00  
CmdText FT_DispWidth/2, FT_DispHeight/2, 31, OPT_CENTER, "Bascom is here"  
  
UpdateScreen

' Plain text at (0,0) in the largest font

CmdText 0, 0, 31, 0, "Text!"

![clip0063](clip0063.png)

' Using a smaller font

CmdText 0, 0, 26, 0, "Text!"

![clip0064](clip0064.png)

' Centered horizontally

CmdText 80, 60, 31, OPT_CENTERX, "Text!"

![clip0065](clip0065.png)

' Right-justified

CmdText 80, 60, 31, OPT_RIGHTX, "Text!"

![clip0066](clip0066.png)

' Centered vertically

CmdText 80, 60, 31, OPT_CENTERY, "Text!"

![clip0067](clip0067.png)

' Centered both horizontally and vertically

CmdText 80, 60, 31, OPT_CENTER, "Text!"

![clip0068](clip0068.png)

---

## CmdToggle

Action

Draw a toggle switch.

Syntax

CmdToggle x, y, w, font, options, state, char

Remarks

x | x-coordinate of top-left of toggle, in pixels  
---|---  
y | y-coordinate of top-left of toggle, in pixels  
w | width of toggle, in pixels  
font | font to use for text, 0-31  
options | By default the toggle is drawn with a 3D effect and the value of options is zero.  Options OPT_FLAT removes the 3D effect.  
state | state of the toggle: 0 is off, 65535 is on  
char | String label for toggle. To seperate the labels use 'gap' ie: "off" + gap + "on"  
  
The details of physical dimension are

•| Outer bar radius I is font height*(20/16)  
---|---  
  
•| Knob radius is r-1.5  
---|---  
  
Example

```vb
' Pseudocode

' Using a medium font, in the two states

```
CmdToggle 60, 20, 33, 27, 0, 0,"no" \+ gap + "yes"

CmdToggle 60, 60, 33, 27, 0, 65535, "no" \+ gap + "yes"

![clip0069](clip0069.png)

' Without the 3D look

CmdToggle 60, 20, 33, 27, OPT_FLAT, 0, "no" \+ gap + "yes"

CmdToggle 60, 60, 33, 27, OPT_FLAT, 65535, "no" \+ gap + "yes"

![clip0070](clip0070.png)

' With different background and foreground colors

CmdBgColor &H402000

CmdFgColor &H703800

CmdToggle 60, 20, 33, 27, 0, 0, "no" \+ gap + "yes"

CmdToggle 60, 60, 33, 27, 0, 65535, "no" \+ gap + "yes"

![clip0071](clip0071.png)

---

## CmdTrack

Action

Track touches for a graphics object.

Syntax

CmdTrack x, y, w, h, tag

Remarks

x | For linear tracker functionality, x-coordinate of track area top-left, in pixels. For rotary tracker functionality, x-coordinate of track area center, in pixels.  
---|---  
y | For linear tracker functionality, y-coordinate of track area top-left, in pixels. For rotary tracker functionality, y-coordinate of track area center, in pixels.  
w | Width of track area, in pixels.  
h | Height of track area, in pixels. A w and h of (1,1) means that the tracker is rotary, and reports an, angle value in REG_TRACKER. A w and h of (0,0) disables the track functionality of co-processor engine.  
tag | tag of the graphics object to be tracked, 1-255  
  
This command will enable co-processor engine to track the touch on the particular graphics object with one valid tag value assigned. Then, co-processor engine will update the REG_TRACKER periodically with the frame rate of LCD display panel. 

Co-processor engine tracks the graphics object in rotary tracker mode and linear tracker mode: 

•| Rotary tracker mode â Track the angle between the touching point and the center of graphics object specified by tag value.  
---|---  
  
The value is in units of 1/65536 of a circle. 0 means that the angle is straight down, &H4000 left, &H8000 up, and &HC000 right

from the center.

•| Linear tracker mode â If parameter w is greater than h, track the relative distance of touching point to the width of graphics  
---|---  
  
object specified by tag value. If parameter w is not greater than h, Track the relative distance of touching point to the height of graphics object specified by tag value. The value is in units of 1/65536 of the width or height of graphics object.

The distance of touching point refers to the distance from the top left pixel of graphics object to the coordinate of touching point. 

Example

Note: see demo files for more examples

```vb
' Pseudocode

' Horizontal track of rectangle dimension 40x12 pixels and the present touch is at 50%

```
ClearColorRGB 5, 45, 110

ColorRGB 255, 168, 64

Clear_B 1 ,1 ,1

Begin_G RECTS

Vertex2F 60 * 16, 50 * 16

Vertex2F 100 * 16, 62 * 16

ColorRGB 255, 0, 0

Vertex2F 60 * 16,50 * 16

Vertex2F 80 * 16,62 * 16

ColorMask 0 ,0 ,0 ,0

Tag 1

Vertex2F 60 * 16,50 * 16

Vertex2F 100 * 16,62 * 16

CmdTrack 60 * 16, 50 * 16, 40, 12, 1

![clip0072](clip0072.png)

' Circular track centered at (80,60) display location

ClearColorRGB 5, 45, 110

ColorRGB 255, 168, 64

Clear_B 1 ,1 ,1

Begin_G RECTS

Vertex2F 70 * 16,40 * 16

Vertex2F 82 * 16,80 * 16

ColorRGB 255, 0, 0

Vertex2F 70 * 16,40 * 16

Vertex2F 82 * 16,60 * 16

ColorMask 0 ,0 ,0 ,0

Tag 1

Vertex2F 70 * 16,40 * 16

Vertex2F 82 * 16,80 * 16

CmdTrack 70 * 16, 40 * 16, 12, 40, 1

![clip0073](clip0073.png)

' To draw a dial with tag 33 centered at (80, 60), adjustable by touch

angle = &H8000

CmdTrack 80, 60, 1, 1, 33

Do

Tag 33

CmdDial 80, 60, 55, 0, angle

.....

tracker = Rd32(REG_TRACKER)

If tracker AND 255 = 33 Then

angle = tracker * 1000

.....

```vb
End If

Loop

```
![clip0074](clip0074.png)

' To make an adjustable slider with tag 34

val = &H8000

CmdTrack 20, 50, 120, 8, 34

Do

...

Tag 34

CmdSlider 20, 50, 120, 8, val, 65535

...

tracker = Rd32(REG_TRACKER)

If tracker AND 255 = 33 Then

val = tracker * 1000

End If

...

Loop

![clip0075](clip0075.png)

---

## CmdTranslate

Action

Apply a translation to the current matrix.

Syntax

CmdTranslate tx, ty 

Remarks

tx | x translate factor, in signed 16.16 bit fixed-point form  
---|---  
ty | y translate factor, in signed 16.16 bit fixed-point form  
  
Example

```vb
' Pseudocode

' To translate the bitmap 20 pixels to the right

```
Begin_G BITMAPS

CmdLoadIdentity

CmdTranslate 20 * 65536, 0

CmdSetMatrix

Vertex2II 68, 28, 0, 0

![clip0076](clip0076.png)

' To translate the bitmap 20 pixels to the left

Begin_G BITMAPS

CmdLoadIdentity

CmdTranslate -20 * 65536, 0

CmdSetMatrix

Vertex2II 68, 28, 0, 0

![clip0077](clip0077.png)

---

## CmdTranslateP

Action

Apply a translation to the current matrix.

Syntax

CmdTranslateP tx, ty 

Remarks

tx | x translate factor  
---|---  
ty | y translate factor  
  
Note: This is the same command as [CmdTranslate](cmdtranslate.md) except you can enter direct Pixel values instead of

having to multiply by it 65536 to convert to a Pixel.

---

## Color_A

Action

Set the current color alpha.

Syntax

Color_A alpha 

Remarks

alpha | Alpha for the current color. 0 to 255, the initial value is 255   
---|---  
  
Sets the alpha value applied to drawn elements - points, lines, and bitmaps.

How the alpha value affects image pixels depends on [BlendFunc](blendfunc.md) the default behavior is a transparent blend.

See also

[ColorRGB](colorrgb.md), [BlendFunc](blendfunc.md)

Example

```vb
' Pseudocode

' Drawing three characters with transparency 255, 128, and 64

```
Begin_G BITMAPS

Vertex2II 50, 30, 31, &H47

Color_A 128 

Vertex2II 58, 38, 31, &H47

Color_A 64 

Vertex2II 66, 46, 31, &H47

![clip0078](clip0078.png)

---

## ColorMask

Action

Enable or disable writing of color components.

Syntax

ColorMask r, g ,b ,a 

Remarks

r | Enable or disable the red channel update of the FT800 color buffer. The initial value is 1 and means enable  
---|---  
g | Enable or disable the green channel update of the FT800 color buffer. The initial value is 1 and means enable  
b | Enable or disable the blue channel update of the FT800 color buffer. The initial value is 1 and means enable  
a | Enable or disable the alpha channel update of the FT800 color buffer. The initial value is 1 and means enable  
  
The color mask controls whether the color values of a pixel are updated. Sometimes it is used to selectively update only the 

red, green, blue or alpha channels of the image. More often, it is used to completely disable color updates while updating the 

tag and stencil buffers.

See also

[TagMask](tagmask.md)

Example

```vb
' Pseudocode

'Draw a '8' digit in the middle of the screen. Then paint an invisible 40-pixel circular 

'touch area into the tag buffer

```
Begin_G BITMAPS

Vertex2II 68, 40, 31, &H38

PointSize 40 * 16

ColorMask 0, 0, 0, 0

Begin_G FTPOINTS

Tag &H38

Vertex2II 80, 60, 0, 0

![clip0079](clip0079.png)

---

## ColorRGB

Action

Set the current color red, green and blue.

Syntax

ColorRGB red, green ,blue 

Remarks

red | Red value for the current color. 0 to 255 , initial value is 255  
---|---  
green | green value for the current color. 0 to 255 , initial value is 255  
blue | blue value for the current color. 0 to 255 , initial value is 255  
  
Sets red, green and blue values of the FT800 color buffer which will be applied to the following draw operation.

See also

[Color_A](color_a.md) , [ColorRGBdw](colorrgbdw.md)

Example

```vb
' Pseudocode

' Drawing three characters with different colors

```
Begin_G BITMAPS

Vertex2II 50, 38, 31, &H47

ColorRGB 255, 100, 50 

Vertex2II 80, 38, 31, &H47

ColorRGB 50, 100, 255 

Vertex2II 110, 38, 31,&H47

![clip0080](clip0080.png)

---

## ColorRGBdw

Action

Set the current color red, green and blue.

Syntax

ColorRGBdw rgb 

Remarks

rgb | Value in the range of 0 to &H00FFFFFF, Red is the most significant 8 bits and Blue is the least. So &Hff0000 is  bright Red.  
---|---  
  
Sets red, green and blue values of the FT800 color buffer which will be applied to the following draw operation.

Note: this is the same as [ColorRGB](colorrgb.md) except you can now parse the whole rgb values in a dword

See also

[Color_A](color_a.md) , [ColorRGB](colorrgb.md)

---

## Commands

Summary of Command Groups

Setting Graphics State  
---  
[AlphaFunc](alphafunc.md) | Set the alpha test function  
[BitmapHandle](bitmaphandle.md) | Set the bitmap handle  
[BitmapLayout](bitmaplayout.md) | Set the source bitmap memory format and layout for the current handle  
[BitmapSize](bitmapsize.md) | Set the screen drawing of bitmaps for the current handle  
[BitmapSource](bitmapsource.md) | Set the source address for bitmap graphics  
[BitmapTransformA-F](bitmaptransform.md) | Set the components of the bitmap transform matrix  
[BlendFunc](blendfunc.md) | Set pixel arithmetic  
[Cell](cell.md) | Set the bitmap cell number for the VERTEX2F command  
[Clear_B](clear_b.md) | Clear buffers to preset values  
[ClearColorA](clearcolora.md) | Set clear value for the alpha channel  
[ClearColorRGB](clearcolorrgb.md) | Set clear values for red, green and blue channels  
[ClearStencil](clearstencil.md) | Set clear value for the stencil buffer  
[ClearTag](cleartag.md) | Set clear value for the tag buffer  
[Color_A](color_a.md) | Set the current color alpha  
[ColorMask](colormask.md) | Enable or disable writing of color components  
[ColorRGB](colorrgb.md) , [ColorRBGdw](colorrgbdw.md) | Set the current color red, green and blue  
[LineWidth](linewidth.md) | Set the line width  
[PointSize](pointsize.md) | Set point size  
[RestoreContext](restorecontext.md) | Restore the current graphics context from the context stack  
[SaveContext](savecontext.md) | Push the current graphics context on the context stack  
[ScissorSize](scissorsize.md) | Set the size of the scissor clip rectangle  
[ScissorXY](scissorxy.md) | Set the top left corner of the scissor clip rectangle  
[StencilFunc](stencilfunc.md) | Set function and reference value for stencil testing  
[StencilMask](stencilmask.md) | Control the writing of individual bits in the stencil planes  
[StencilOp](stencilop.md) | Set stencil test actions  
[Tag](tag.md) | Set the current tag value  
[TagMask](tagmask.md) | Control the writing of the tag buffer  

Commands that begin and finish the display list  
[Begin_G](begin_g.md) | Start drawing a graphics primitive  
[End_G](end_g.md) | Finish drawing a graphics primitive  
[CmdDlStart](cmddlstart.md) | Start a New Display List  

Commands to draw graphic objects  
[CmdText](cmdtext.md) | Draw Text  
[CmdButton](cmdbutton.md) | Draw a Button  
[CmdClock](cmdclock.md) | Draw an analog clock  
[CmdBgColor](cmdbgcolor2.md) | Set the background color  
[CmdFgColor](cmdfgcolor.md) | Set the foreground color  
[CmdGradColor](cmdgradcolor.md) | Set the 3D effects for CmdButton and CmdKeys highlight color  
[CmdGauge](cmdgauge.md) | Draw a gauge  
[CmdGradient](cmdgradient.md) | Draw a smooth color gradient  
[CmdKeys](cmdkeys.md) | Draw a row of keys  
[CmdProgress](cmdprogress.md) | Draw a progress bar  
[CmdScrollbar](cmdscrollbar.md) | Draw a scroll bar  
[CmdSlider](cmdslider.md) | Draw a slider  
[CmdDial](cmddial.md) | Draw a rotary dial control  
[CmdToggle](cmdtoggle.md) | Draw a toggle switch  
[CmdNumber](cmdnumber.md) | Draw a decimal number  

Drawing Actions  
[Vertex2f](vertex2f.md) | Supply a vertex with fractional coordinates  
[Vertex2ii](vertex2ii.md) | Supply a vertex with positive integer coordinates  
[CmdSetFont](cmdsetfont.md) | Set up a custom font  
[CmdTrack](cmdtrack.md) | Track touches for a graphic object  

Commands to operate on memory  
[CmdMemCRC](cmdmemcrc.md) | Compute a CRC-32 for memory  
[CmdMemZero](cmdmemzero.md) | Write zero to a block of memory  
[CmdMemSet](cmdmemset.md) | Fill memory with a byte value  
[CmdMemWrite](cmdmemwrite.md) | Write bytes into memory  
[CmdMemCpy](cmdmemcpy.md) | Copy a block of memory  
[CmdAppend](cmdappend.md) | Append memory to display list  
[CmdGetPtr](cmdgetptr.md) | Get the End memory address of inflated data  

Commands for loafing image data into FT80x memory  
[CmdInflate](cmdinflate.md) | Decompress data into memory  
[CmdLoadImage](cmdloadimage.md) | Load a JPEG image  

Commands for setting the bitmap transform matrix  
[CmdLoadIdentity](cmdloadidentity.md) | Set the current matrix to identity  
[CmdTranslate](cmdtranslate.md) , [CmdTranslateP](cmdtranslatep.md) | Apply a translation to the current matrix  
[CmdScale](cmdscale.md) | Apply a scale to the current matrix  
[CmdRotate](cmdrotate.md) , [CmdRotateA](cmdrotatea.md) | Apply a rotation to the current matrix  
[CmdSetMatrix](cmdsetmatrix.md) | Write the current matrix as a bitmap transform  
[CmdGetMatrix](cmdgetmatrix.md) | Retrieves the current matrix coefficients  
  
|   
  
Execution control  
[Jump](jump.md) | Execute commands at another location in the display list  
[Macro_R](macro_r.md) | Execute a single command from a macro register  
[Call_C](call_c.md) | Execute a sequence of commands at another location in the display list  
[Return_C](return_c.md) | Return from a previous CALL command  
[Display_E](display_e.md) | End the display list  
[CmdSwap](cmdswap.md) | Swap de current display list  

Other Commands  
[CmdColdStart](cmdcoldstart.md) | Set co-processor engine state to default values  
[CmdInterrupt](cmdinterrupt.md) | Trigger interrupt INT_CMDFLAG  
[CmdRegRead](cmdregread.md) | Read a register value  
[CmdCalibrate](cmdcalibrate.md) | Execute the touch screen calibration routine  
[CmdSpinner](cmdspinner.md) | Start an animated spinner  
[CmdStop](cmdstop.md) | Stop any spinner, screensaver or sketch  
[CmdScreenSaver](cmdscreensaver.md) | Start an animated screen saver  
[CmdSketch](cmdsketch.md) | Start a continuous sketch update  
[CmdSnapshot](cmdsnapshot.md) | Take a snapshot of the current screen  
[CmdLogo](cmdlogo.md) | Play device logo animation  
  
Co-Processor Engine commands

![clip0104](clip0104.png)

BASCOM high level commands

  
|   
  
---|---  
[ClearScreen](clearscreen.md) | Clears the LCD with a black background  
[UpdateScreen](updatescreen.md) | Executes the commands in FIFO and refreshes LCD  
[WaitCmdFifoEmpty](waitcmdfifoempty.md) | Waits for execution of commands in FIFO buffer  
[CMDFTSTACK](cmdftstack.md) | Send data from the soft stack  
[CMD8](cmd8.md) | Send a byte to the FT800 graphic processor.  
[CMD16](cmd16.md) | Send a word to the FT800 graphic processor.  
[CMD32](cmd32.md) | Send a dword to the FT800 graphic processor.  
[WR8](wr8.md) | Write an address and a byte parameter to the FT800.  
[WR16](wr16.md) | Write an address and a word parameter to the FT800.  
[WR32](wr32.md) | Write an address and a dword parameter to the FT800.  
  
Errors

The FTERROR byte variable contains 4 flags you can examine.

FtError.0 = WaitCmdFifoEmpty Sub when Overflowed

FtError.1 = WaitCmdFifoEmpty Sub when TimeOut

FtError.2 = FreeSpaceFt Sub when OverFlowed

FtError.3 = FreeSpaceFt Sub when TimeOut

---

## Compact FlashCard Driver

The compact flash card driver library is written by Josef Franz VÃ¶gel. He can be contacted via the BASCOM user list.

Josef has put a lot of effort in writing and especially testing the routines.

Josef nor MCS Electronics can be held responsible for any damage or data loss of your CF-cards.

Compact flash cards are very small cards that are compatible with IDE drives. They work at 3.3V or 5V and have a huge storage capacity.

The Flash Card Driver provides the functions to access a Compact Flash Card.

At the moment there are six functions:

[DriveCheck](drivecheck.md), [DriveReset](drivereset.md) , [DriveInit](driveinit.md) , [DriveGetIdentity](drivegetidentity.md) , [DriveWriteSector](drivewritesector.md) , [DriveReadSector](drivereadsector.md)

The Driver can be used to access the Card directly and to read and write each sector of the card or the driver can be used in combination with a file-system with basic drive access functions.

Because the file system is separated from the driver you can write your own driver.

This way you could use the file system with a serial EEPROM for example.

```vb
For a file system at least the functions for reading (DriveReadSector / _DriveReadSector) and writing (DriveWriteSector / _DriveWriteSector) must be provided. The preceding under slash _ is the label of the according asm-routine. The other functions can, if possible implemented as a NOP â Function, which only returns a No-Error (0) or a Not Supported (224) Code, depending, what makes more sense.

For writing your own Driver to the AVR-DOS File system, check the ASM-part of the functions-description.

```
Error Codes:

Code | Compiler â Alias | Remark  
---|---|---  
0 | CpErrDriveNoError | No Error  
224 | cpErrDriveFunctionNotSupported | This driver does not supports this function  
225 | cpErrDriveNotPresent | No Drive is attached  
226 | cpErrDriveTimeOut | During Reading or writing a time out occurred  
227 | cpErrDriveWriteError | Error during writing  
228 | cpErrDriveReadError | Error during reading  
  
At the [MCS Web AN](<http://www.mcselec.com/index.php?option=com_content&task=view&id=87&Itemid=57>) section you can find the application note 123.

More info about Compact Flash you can find at :

<http://www.sandisk.com/download/Product%20Manuals/cf_r7.pdf>

A typical connection to the micro is shown below.

![cfcard](cfcard.gif)

---

## COMPARE

Action

This function performs a byte compare on two variables.

Syntax

result = COMPARE( var1, var2, bytes)

Remarks

result | A word variable that is assigned with the result of the function. When the 2 variables are equal, the value will be 0. When the 2 variables differ, the index is returned of the position that differs.   
---|---  
var1 , var2 | Any kind of variable like a long or string. Constants are not supported.  
Bytes | The number of bytes to test. The maximum value must fit into a word. (65535).  
  
See also

NONE

Example

```vb
'-------------------------------------------------------------------------  
'name : compare.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demonstrates byte COMPARE function, written by MWS  
'micro : Mega88  
'suited for demo : yes  
'commercial addon needed : no  
'-------------------------------------------------------------------------  
' purpose: byte-wise compare  
' arg Val1: first value to compare, type = don't care  
' arg Val2: second value to compare, type = don't care  
' arg BtComp: count of bytes to compare, can be a constant or a variable  
' range is 1 to 65535 bytes  
' result: zero if all bytes within range of BtComp are matching  
' 1 up to BtComp if there's a miss,  
' zero is used for signaling a comlete match, so Config Base has no effect  
' 1 is always the first byte of the variable, whatever type of variable it is  
'-------------------------------------------------------------------------  
  
$regfile = "m328pdef.dat"  
$crystal = 16000000  
$hwstack = 40  
$swstack = 32  
$framesize = 32  
  
```
Const Testver = 2 ' edit for different tests 0,1 or 2  
  
```vb
Dim Mmpos As Word ' dimension word var to hold the result, i.e. mismatch position  
Dim btt As Word ' bytes to test  
  

#if Testver = 0  
Dim Val_a(8) As Byte ' byte array vs. byte array  
Dim Val_b(8) As Byte ' arrays are initialyzed 0  
```
Btt = 8  
Val_a(4) = 1 ' test it  

```vb
#elseif Testver = 1  
Dim Val_a As Double ' Double vs. byte array  
Dim Val_b(8) As Byte  
```
Btt = 8  
Val_b(2) = 1 ' test it  

```vb
#elseif Testver = 2 ' compare strings  
Dim Val_a As String * 16  
Dim Val_b As String * 16  
```
Btt = 12  
Val_a = "Hello Bascom"  
Val_b = "Hello Bascon" ' find the mismatch  

#endif  
  
Mmpos = Compare(val_a , Val_b , Btt)  
  
```vb
If Mmpos > 0 Then  
Print "We have a miss at pos: " ; Mmpos  
Else  
Print "Match!"  
End If  
End

```

---

## CONST

Action

Declares a symbolic constant.

Syntax

CONST symbol = numconst

CONST symbol = stringconst

CONST symbol = expression

Remarks

Symbol | The name of the symbol.  
---|---  
Numconst | The numeric value to assign to the symbol.  
Stringconst | The string to assign to the symbol  
Expression | An expression that returns a value to assign the constant  
  
Assigned constants consume no program memory because they only serve as a reference to the compiler.

The compiler will replace all occurrences of the symbol with the assigned value.

You can use a constant to give a value a more meaningful name.

For example : 

variable = 1

const optHeaterOn = 1

variable = optHeaterOn

The source code is better to read when you assign a constant. Even better when the values change later, for example when HeaterOn becomes 2, you only need to replace 1 line of code.

See also

[ALIAS](alias.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : const.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo for constants

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'dimension some variables

Dim Z As String * 10

Dim B As Byte

'assign some constants

'constants dont use program memory

```
Const S = "test"

Const A = 5 'declare a as a constant

Const B1 = &B1001

'or use an expression to assign a constant

Const X =(b1 * 3) + 2

Const Ssingle = Sin(1)

```vb
Print X

Print Ssingle

```
B = A

'the same as b = 5

Z = S

```vb
'the same as Z = "test"

Print A

Print B1

Print S

'you can use constants with conditional compilation

#if A = 5 ' note there is no then

Print "constant a is 5"

#if S = "test"

Print "nested example"

#else ' else is optional

#endif

#else

#endif

End

```

---

## CONTINUE

Action

The CONTINUE statement will skip code inside a loop till the end of the loop.

Syntax

CONTINUE

Remarks

CONTINUE must be used inside a DO-LOOP, WHILE-WEND or FOR-NEXT loop.

The code jump is always inside the current loop.

Some times you want to skip some code without leaving a loop. You can solve this with a GOTO and a label but use of GOTO creates hard to understand code. For this reason some languages have the CONTINUE statement. 

```vb
DO-LOOP  
DO

```
some code here

some code here

CONTINUE_WILL_JUMP_TO_THIS_POINT

```vb
LOOP

WHILE-WEND

WHILE <CONDIITON>

```
some code here

some code here

CONTINUE_WILL_JUMP_TO_THIS_POINT

```vb
WEND

FOR-NEXT

FOR VAR=START TO END

```
some code here

some code here

CONTINUE_WILL_JUMP_TO_THIS_POINT

NEXT

See also

[EXIT](exit.md) , [REDO](redo.md)

Example

```vb
'-------------------------------------------------------------------------------------------------------------  
' REDO and CONTINUE example  
'  
'-------------------------------------------------------------------------------------------------------------  
$regfile = "m128def.dat"  
$hwstack = 32  
$swstack = 16  
$FrameSize = 24  
  
  
dim b as byte  
```
const test = 0  
  

```vb
#if test = 0  
for b = 1 to 10  
'when REDO is used, the code will continue here  
print b  
if b = 3 then  
```
continue ' when b becomes 3, the code will continue at the NEXT statement  
```vb
end if  
if b = 9 then exit for  
if b = 8 then  
```
redo ' when b becomes 8, the code will continue after the FOR statement, it will not increase the variable B !  
```vb
'so in this example the loop will be forever  
end if  
print b  
'code continues here when CONTINUE is used  
next  
  

#elseif test = 1  
```
b = 0  
do  
incr b  
if b = 2 then  
continue  
elseif b = 3 then  
redo  
```vb
end if  
loop until b > 5  
  

#elseif test = 2  
```
b = 0  
while b < 5  
incr b  
if b = 2 then  
continue  
elseif b = 3 then  
redo  
```vb
end if  
wend  

#endif  
end

```

---

## COS

Action

Returns the cosine of a floating point variable

Syntax

var = COS( float )

Remarks

Var | A numeric variable that is assigned with cosine of variable float.  
---|---  
float | The floating point variable to get the cosine of.  
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [ATN](atn.md) , [SIN](sin.md) , [TAN](tan.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As Single , X As Single

```
S = 0.5 : X = Tan(s) : Print X ' prints 0.546302195

S = 0.5 : X = Sin(s) : Print X ' prints 0.479419108

S = 0.5 : X = Cos(s) : Print X ' prints 0.877588389

End

---

## COSH

Action

Returns the cosine hyperbole of a floating point variable

Syntax

var = COSH( float )

Remarks

Var | A numeric variable that is assigned with cosine hyperbole of variable float.  
---|---  
float | The single or double variable to get the cosine hyperbole of.  
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [ATN](atn.md) , [COS](cos.md) , [SIN](sin.md) , [TANH](tanh.md) , [SINH](sinh.md)

Example

[Show sample](fp_trig.md)

---

## COUNTER0 and COUNTER1

Action

Set or retrieve the internal 16 bit hardware register.

Syntax

COUNTER0 = var var = COUNTER0 | TIMER0 can also be used  
---|---  
COUNTER1 = var var = COUNTER1 | TIMER1 can also be used  
CAPTURE1 = var var = CAPTURE1 | TIMER1 capture register  
COMPARE1A = var var = COMPARE1A | TIMER1 COMPARE A register  
COMARE1B = var var = COMPARE1B | TIMER1 COMPARE B register  
PWM1A = var var = PWM1A | TIMER1 COMPAREA register. (Is used for PWM)  
PWM1B = var var = PRM1B | TIMER1 COMPARE B register. (Is used for PWM)  
  
Remarks

Var | A byte, Integer/Word variable or constant that is assigned to the register or is read from the register.  
---|---  
  
Because the above 16 bit register pairs must be accessed somewhat differently than you may expect, they are implemented as variables.

The exception is TIMER0/COUNTER0, this is a normal 8 bit register and is supplied for compatibility with the syntax.

When the CPU reads the low byte of the register, the data of the low byte is sent to the CPU and the data of the high byte is placed in a temp register. When the CPU reads the data in the high byte, the CPU receives the data in the temp register.

When the CPU writes to the high byte of the register pair, the written data is placed in a temp register. Next when the CPU writes the low byte, this byte of data is combined with the byte data in the temp register and all 16 bits are written to the register pairs. So the MSB must be accessed first.

All of the above is handled automatically by BASCOM when accessing the above registers.

Note that the available registers may vary from chip to chip.

The BASCOM documentation used the 90S8515 to describe the different hardware registers.

---

## CPEEK

Action

Returns a byte stored in code memory.

Syntax

var = CPEEK( address )

Remarks

Var | Numeric variable that is assigned with the content of the program memory at address. The cpeek() function returns one BYTE.  
---|---  
Address | Numeric variable or constant with the byte address location.  
  
So what is code memory? Code memory is the same as the flash memory where your program code is stored.

That is not the same memory as the EEPROM memory!

The code memory is exactly the same as the BIN file that the compiler creates.

So why is Cpeek() useful ? You could read the memory and perform a checksum to see if the code is valid.

Or you could check if a boot loader is present in the code.

There is no CPOKE statement because you can not write into program/code memory. Only a boot loader(a piece of code in a special area of the code memory) can write to the normal code memory.

Cpeek(0) will return the first byte of the flash code memory. Cpeek(1) will return the second byte of the flash code memory.

Cpeek() is limited to the first 64 KB of the code memory. For processors that have larger flash code memory like the Mega128 (128KB) you can use [CpeekH](cpeekh.md)().

While the AVR uses word addresses since all instructions are 2 bytes long, the Cpeek() function uses a byte address. You need to take that in consideration with for example a boot loader address. The Atmel data sheet will only mention word addresses. For example boot loader address $1000 in the data sheet is $2000 and $2001 byte address for Cpeek().

See also

[PEEK](peek.md) , [CPEEKH](cpeekh.md) , [POKE](poke.md) , [INP](inp.md) , [OUT](out.md), [SETREG](setreg.md), [GETREG](getreg.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : peek.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates PEEk, POKE, CPEEK, INP and OUT

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim I As Integer , B1 As Byte

'dump internal memory

For I = 0 To 31 'only 32 registers in AVR

```
B1 = Peek(i) 'get byte from internal memory

```vb
Print Hex(b1) ; " ";

'Poke I , 1 'write a value into memory

Next

Print 'new line

'be careful when writing into internal memory !!

'now dump a part ofthe code-memory(program)

For I = 0 To 255

```
B1 = Cpeek(i) 'get byte from internal memory

```vb
Print Hex(b1) ; " ";

Next

'note that you can not write into codememory!!

```
Out &H8000 , 1 'write 1 into XRAM at address 8000

B1 = Inp(&H8000) 'return value from XRAM

```vb
Print B1

End

```

---

## CPEEKH

Action

Returns a byte stored in code memory of micro processors with more then 64KB such as M103, M128.

Syntax

var = CPEEKH( address [,page] )

Remarks

Var | Numeric variable that is assigned with the content of the program memory at address. One byte is returned by the function.  
---|---  
address | Numeric variable or constant with the byte address location.  
page | A numeric variable or constant with the page address. Each page is 64 KB. Thus for the first 64 KB you would specify 0. For the second 64 KB you would specify 1.   
  
The similar Cpeek() function only works on the first 64 KB page. It was intended for processors with memory up to 64 KB.

When processors were made by Atmel with larger memory like the Mega128 (128 KB) the cpeekH() function was added.

The CpeekH() function uses the ELPM instruction instead of the LPM instruction that Cpeek() uses.

Since the memory is broken up in page of 64 KB, the cpeekH() function also access the memory in pages.

You can also omit the page number in which case the compiler will calculate the proper page address.

CpeekH(address,0) will work on the first page (first 64 KB)

CpeekH(address,1) will work on the second page (second 64 KB)

![notice](notice.jpg)When omitting the page, the compiler will calculate and load the page register automatically.

While the AVR uses word addresses since all instructions are 2 bytes long, the Cpeek() function uses a byte address. You need to take that in consideration with for example a boot loader address. The Atmel data sheet will only mention word addresses. For example boot loader address $1000 in the data sheet is $2000 and $2001 byte address for Cpeek().

See also

[PEEK](peek.md) , [POKE](poke.md) , [INP](inp.md) , [OUT](out.md) , [CPEEK](cpeek.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : peek.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates PEEk, POKE, CPEEK, INP and OUT

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim I As Integer , B1 As Byte

'dump internal memory

For I = 0 To 31 'only 32 registers in AVR

```
B1 = Peek(i) 'get byte from internal memory

```vb
Print Hex(b1) ; " ";

'Poke I , 1 'write a value into memory

Next

Print 'new line

'be careful when writing into internal memory !!

'now dump a part ofthe code-memory(program)

For I = 0 To 255

```
B1 = Cpeek(i) 'get byte from internal memory

```vb
Print Hex(b1) ; " ";

Next

'note that you can not write into codememory!!

```
Out &H8000 , 1 'write 1 into XRAM at address 8000

B1 = Inp(&H8000) 'return value from XRAM

```vb
Print B1

End

```

---

## CRC16

Action

Returns the CRC16 value of a variable or array.

Syntax

Var = CRC16( source , L)

Remarks

Var | The variable that is assigned with the CRC16 of variable source. Should be a word or integer variable.  
---|---  
Source | The source variable or first element of the array to get the CRC16 value from. By default only normal RAM variables are supported. You can also use EEPROM memory when you add a constant to your project :   
Const CRC16_EEPROM=1   
L | The number of bytes to check. This can be a numeric constant , byte or word variable. The maximum size to check is 65535.  
  
CRC16 is used in communication protocols to check if there are no transmission errors.

The 1wire for example returns a CRC byte as the last byte from itâs ID.

Use CRC8 for the 1wire routines.

There are a lot of different CRC16 routines. There is no real standard since the polynomial will vary from manufacture to manufacture.

The equivalent code in VB is shown below. There are multiple ways to implement it in VB. This is one of them.

VB CRC16 Sample

Private Sub Command1_Click()

```vb
Dim ar(10) As Byte

Dim b As Byte

Dim J As Integer

```
ar(1) = 1

ar(2) = 2

ar(3) = 3

b = Docrc8(ar(), 3) ' call funciton

```vb
Print b

'calculate value which is 216

```
J = CRC16(ar(), 3) ' call function

```vb
Print J

End Sub

Function Docrc8(ar() As Byte, bts As Byte) As Byte

Dim J As Byte

Dim k As Byte

Dim crc8 As Byte

```
crc8 = 0

For m = 1 To bts

x = ar(m)

For k = 0 To 7

J = 1 And (x Xor crc8)

crc8 = Fix(crc8 / 2) And &HFF

x = Fix(x / 2) And &HFF

If J <> 0 Then

crc8 = crc8 Xor &H8C

```vb
End If

Next k

Next

```
Docrc8 = crc8

```vb
End Function

'*****************************************************************

```
Public Function CRC16(buf() As Byte, lbuf As Integer) As Integer

```vb
Dim CRC1 As Long

Dim b As Boolean

```
CRC1 = 0 ' init CRC

For i = 1 To lbuf ' for each byte

CRC_MSB = CRC1 \ 256

crc_LSB = CRC1 And 255

CRC_MSB = CRC_MSB Xor buf(i)

CRC1 = (CRC_MSB * 256) + crc_LSB

For J = 0 To 7 Step 1 ' for each bit

CRC1 = shl(CRC1, b)

```vb
If b Then CRC1 = CRC1 Xor &H1021

Next J

Next i

```
CRC16 = CRC1

```vb
End Function

'Shift Left function

Function shl(n As Long, ByRef b As Boolean) As Long

Dim L As Long

```
L = n

L = L * 2

If (L > &HFFFF&) Then

b = True

Else

b = False

End If

shl = L And &HFFFF&

End Function

See also

[CHECKSUM](checksum.md) , [CRC8](crc8.md), [CRC16UNI](crc16uni.md) , [CRC32](crc32.md) , [TCPCHECKSUM](tcpchecksum.md) , [CRCMB](crcmb.md) , [CRC8UNI](crc8uni.md)

ASM

The following routine is called from mcs.lib : _CRC16

The routine must be called with X pointing to the data. The soft stack âY must contain the number of bytes to scan.

On return, R16 and R17 contain the CRC16 value.

The used registers are : R16-R19, R25.

;##### X = Crc16(ar(1) , 7)

Ldi R24,$07 ; number of bytes

St ây, R24

Ldi R26,$64 ; address of ar(1) 

Ldi R27,$00 ; load constant in register

Rcall _Crc16 ; call routine

Ldi R26,$60 ; address of X

St X+,R16 ; store crc16 LSB

St X , R17 ; store CRC16 MSB

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim Ar(10) As Byte

Dim J As Byte

Dim W As Word

Dim L As Long

```
Ar(1) = 1

Ar(2) = 2

Ar(3) = 3

J = Crc8(ar(1) , 3) 'calculate value which is 216

W = Crc16(ar(1) , 3) '24881

L = Crc32(ar(1) , 3) '494976085

End

---

## CRC16UNI

Action

Returns the CRC16 value of a variable or array.

Syntax

Var = CRC16UNI( source ,length , initial, polynomial,refin,refout)

Remarks

var | The variable that is assigned with the CRC16 of variable source. Should be a word or integer variable.  
---|---  
source | The source variable or first element of the array to get the CRC16 value from.  
length | The number of bytes to check. The maximum value is 65535. (&HFFFF)  
initial | The initial value of the CRC. This is usual 0 or &HFFFF.  
polynomial | The polynomial value to use.   
refin | Reflect the data input bits. Use 0 to disable this option. Use a non-zero value to enable this option.  
refout | Reflect the data output. Use 0 to disable this option. Use a non-zero value to enable this option.  
  
CRC16 is used in communication protocols to check if there are no transmission errors.

The 1wire for example returns a CRC byte as the last byte from itâs ID.

Use CRC8 for the 1wire routines.

There are a lot of different CRC16 routines. There is no real standard since the polynomial will vary from manufacture to manufacture. 

At <http://www.ross.net/crc/download/crc_v3.txt> you can find a great document about CRC calculation from Ross N. Williams. At the end you will find an example that is good for dealing with most CRC variations. The BASCOM CRC16UNI function is a conversion of this example. 

There is a difference however : The CRC16UNI function does not XOR the output bytes. This because most CRC functions XOR with 0. 

The example will show some of the most used combinations.

In version 2083 the function can handle more than 255 bytes. In previous versions the amount was limited to a maximum of 255.

See also

[CHECKSUM](checksum.md) , [CRC8](crc8.md), [CRC16](crc16.md) , [CRC32](crc32.md) , [TCPCHECKSUM](tcpchecksum.md) , [CRCMB](crcmb.md) , [CRC8UNI](crc8uni.md)

Example

```vb
'------------------------------------------------------------------------------

'name : crc8-16-32.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates CRC

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim Ar(10) As Byte

Dim J As Byte

Dim W As Word

Dim L As Long

Dim S As String * 16

```
S = "123456789"

Ar(1) = 1

Ar(2) = 2

Ar(3) = 3

J = Crc8(ar(1) , 3) 'calculate value which is 216

W = Crc16(ar(1) , 3) '24881

L = Crc32(ar(1) , 3) '494976085

```vb
' data , length, intial value , Poly, reflect input, reflect output

Print Hex(crc16uni(s , 9 , 0 , &H1021 , 0 , 0)) 'CRC-CCITT (0x0000) 31C3

Print Hex(crc16uni(s , 9 , &HFFFF , &H1021 , 0 , 0)) 'CRC-CCITT (0xFFFF) 29B1

Print Hex(crc16uni(s , 9 , &H1D0F , &H1021 , 0 , 0)) 'CRC-CCITT (0x1D0F) E5CC

Print Hex(crc16uni(s , 9 , 0 , &H8005 , 1 , 1)) 'crc16 BB3D

Print Hex(crc16uni(s , 9 , &HFFFF , &H8005 , 1 , 1)) 'crc16-modbus 4B37

End

```

---

## CRC32

Action

Returns the CRC32 value of a variable.

Syntax

Var = CRC32( source , L)

Remarks

Var | The LONG variable that is assigned with the CRC32 of variable source.  
---|---  
Source | The source variable or first element of the array to get the CRC 32 value from.  
L | The number of bytes to check. This can be a word variable.   
  
CRC32 is used in communication protocols to check if there are no transmission errors.

See also

[CHECKSUM](checksum.md) , [CRC8](crc8.md), [CRC16](crc16.md) , [CRC16UNI](crc16uni.md) , [TCPCHECKSUM](tcpchecksum.md) , [CRCMB](crcmb.md) , [CRC8UNI](crc8uni.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim Ar(10) As Byte

Dim J As Byte

Dim W As Word

Dim L As Long

```
Ar(1) = 1

Ar(2) = 2

Ar(3) = 3

J = Crc8(ar(1) , 3) 'calculate value which is 216

W = Crc16(ar(1) , 3) '24881

L = Crc32(ar(1) , 3) '1438416925

End

---

## CRC8

Action

Returns the CRC8 value of a variable or array.

Syntax

Var = CRC8( source , L)

Remarks

Var | The variable that is assigned with the CRC8 of variable source.  
---|---  
Source | The source variable or first element of the array to get the CRC8 of.  
L | The number of bytes to check.  
  
CRC8 is used in communication protocols to check if there are no transmission errors.

The 1wire for example returns a CRC byte as the last byte from itâs ID.

The code below shows a VB function of CRC8

```vb
Function Docrc8(s As String) As Byte

Dim j As Byte

Dim k As Byte

Dim crc8 As Byte

```
crc8 = 0

For m = 1 To Len(s)

x = Asc(Mid(s, m, 1))

For k = 0 To 7

j = 1 And (x Xor crc8)

crc8 = Fix(crc8 / 2) And &HFF

x = Fix(x / 2) And &HFF

If j <> 0 Then

crc8 = crc8 Xor &H8C

```vb
End If

Next k

Next

```
Docrc8 = crc8

End Function

![notice](notice.jpg)When you want to use a different polynome, you can override the default by defining a constant named CRC8_POLY

Const CRC8_POLY = &HAA 'use a different value

![notice](notice.jpg)Please notice that the CRC8 function is the CRC8-MAXIM function. It is primarily intended for the 1WIRE routines. There exist a lot of different CRC8 variants. They differ in the start value, the polynom , if the result is XOR-ed and if the data is reflected or not. Reflection means that data is flipped. (See [FLIP](flip2.md))

CRC8 supports big strings in 2083.

See also

[CHECKSUM](checksum.md) , [CRC16](crc16.md), [CRC16UNI](crc16uni.md) , [CRC32](crc32.md) , [TCPCHECKSUM](tcpchecksum.md) , [CRCMB](crcmb.md)

ASM

The following routine is called from mcs.lib : _CRC8

The routine must be called with Z pointing to the data and R24 must contain the number of bytes to check.

On return, R16 contains the CRC8 value.

The used registers are : R16-R19, R25.

;##### X = Crc8(ar(1) , 7)

Ldi R24,$07 ; number of bytes

Ldi R30,$64 ; address of ar(1) 

Ldi R31,$00 ; load constant in register

Rcall _Crc8 ; call routine

Ldi R26,$60 ; address of X

St X,R16 ; store crc8

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim Ar(10) As Byte

Dim J As Byte

```
Ar(1) = 1

Ar(2) = 2

Ar(3) = 3

J = Crc8(ar(1) , 3) 'calculate value which is 216

```vb
Print J

End

```

---

## CRC8UNI

Action

Returns the CRC value of a variable or array.

Syntax

Var = CRC8UNI( source , L)

Remarks

Var | The variable that is assigned with the CRC8 of variable source.  
---|---  
Source | The source variable or first element of the array to get the CRC8 of.  
L | The number of bytes to check.  
  
CRC is used in communication protocols to check if there are no transmission errors.

The [CRC8](crc8.md) function in BASCOM is mainly intended to be used with 1WIRE.

The CRC8UNI uses the CCITT with polynome value 7.

![notice](notice.jpg)When you want to use a different polynome, you can override the default by defining a constant named CRC8_POLY

Const CRC8_POLY = &HAA 'use a different value

See also

[CHECKSUM](checksum.md) , [CRC16](crc16.md), [CRC16UNI](crc16uni.md) , [CRC32](crc32.md) , [TCPCHECKSUM](tcpchecksum.md) , [CRCMB](crcmb.md) , [CRC8](crc8.md)

Example

```vb
'------------------------------------------------------------------------------  
'name : crc8-16-32.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demonstrates CRC  
'micro : Mega48  
'suited for demo : yes  
'commercial addon needed : no  
'------------------------------------------------------------------------------  
  
$regfile = "m48def.dat" ' specify the used micro  
$crystal = 8000000 ' used crystal frequency  
$baud = 19200 ' use baud rate  
$hwstack = 32 ' default use 32 for the hardware stack  
$swstack = 10 ' default use 10 for the SW stack  
$framesize = 40 ' default use 40 for the frame space  
  
  
Dim Ar(10) As Byte  
Dim J As Byte  
Dim W As Word  
Dim L As Long  
Dim S As String * 16  
  
  
```
S = "123456789"  
  
Ar(1) = 1  
Ar(2) = 2  
Ar(3) = 3  
  
  
J = Crc8(ar(1) , 3) 'calculate value which is 216  
j = Crc8Uni(ar(1) , 3) 'calculate unsing CCITT which is 72  
W = Crc16(ar(1) , 3) '24881  
L = Crc32(ar(1) , 3) '1438416925  
  
```vb
' data , length, intial value , Poly, reflect input, reflect output  
  
Print Hex(Crc16Uni(S , 9 , 0 , &H1021 , 0 , 0)) 'CRC-CCITT (0x0000) 31C3  
Print Hex(Crc16Uni(S , 9 , &HFFFF , &H1021 , 0 , 0)) 'CRC-CCITT (0xFFFF) 29B1  
Print Hex(Crc16Uni(S , 9 , &H1D0F , &H1021 , 0 , 0)) 'CRC-CCITT (0x1D0F) E5CC  
Print Hex(Crc16Uni(S , 9 , 0 , &H8005 , 1 , 1)) 'crc16 BB3D  
Print Hex(Crc16Uni(S , 9 , &HFFFF , &H8005 , 1 , 1)) 'crc16-modbus 4B37  
  
End

```

---

## CRCMB

Action

Returns the Modbus CRC value of a variable or array.

Syntax

Var = CRCMB( source , L)

Remarks

Var | The variable that is assigned with the modbus checksum of variable source. This should be a word variable.  
---|---  
Source | The source variable or first element of the array to get the checksum of.  
L | The number of bytes to check.  
  
CRC8 is used in communication protocols to check if there are no transmission errors.

The Modbus checksum uses a different polynome.

Modbus.lbx or modbus.lib need to be included in your project using the $LIB directive

See also

[CHECKSUM](checksum.md) , [CRC16](crc16.md), [CRC16UNI](crc16uni.md) , [CRC32](crc32.md) , [TCPCHECKSUM](tcpchecksum.md) , [CRC8](crc8.md) , [CRC8UNI](crc8uni.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim Ar(10) As Byte

Dim W As Word

```
Ar(1) = 1

Ar(2) = 2

Ar(3) = 3

W = CrcMB(ar(1) , 3) 'calculate value

```vb
Print W

End

```

---

## CRYSTAL

Action

Special byte variable that can be used with software UART routine to change the baud rate during runtime.

Syntax

CRYSTAL = var (old option do not use !!)

___CRYSTAL1 = var

BAUD #1, 2400

Remarks

With the software UART you can generate good baud rates. But chips such as the ATtiny22 have an internal 1 MHz clock. The clock frequency can change during runtime by influence of temperature or voltage.

The crystal variable can be changed during runtime to change the baud rate.

The above has been changed in version 1.11

Now you still can change the baud rate with the crystal variable.

But you don't need to dimension it. And the name has been changed:

___CRYSTALx where x is the channel number.

When you opened the channel with #1, the variable will be named ___CRYSTAL1

But a better way is provided now to change the baud rate of the software uart at run time. You can use the BAUD option now:

Baud #1 , 2400 'change baud rate to 2400 for channel 1

When you use the baud # option, you must specify the baud rate before you print or use input on the channel. This will dimension the ___CRYSTALx variable and load it with the right value.

When you don't use the BAUD # option the value will be loaded from code and it will not use 2 bytes of your SRAM.

The ___CRYSTALx variable is hidden in the report file because it is a system variable. But you may assign a value to it after BAUD #x, zzzz has dimensioned it.

The old CRYSTAL variable does not exist anymore.

Some values for 1 MHz internal clock :

66 for 2400 baud

31 for 4800 baud

14 for 9600 baud

See also

[OPEN](open.md) , [CLOSE](open.md)

Example

Dim B as byte

Open "comd.1:9600,8,n,1,inverted" For Output As #1

```vb
Print #1 , B

Print #1 ,"serial output"

```
baud #1, 4800 'use 4800 baud now

Print #1,"serial output"

___CRYSTAL1 = 255

Close#1

End

---

## CURSOR

Action

Set the LCD Cursor State.

Syntax

CURSOR ON / OFF , BLINK / NOBLINK

Remarks

You can use both the ON or OFF and BLINK or NOBLINK parameters.

At power up the cursor state is ON and NOBLINK.

To get the proper value in all cases it is best to specify both parameters. 

In 1995 when the LCD display support was created the processors had little pins. And the WR pin was not used and connected to ground.

But because of this there was no way to read data from the display. And since both parameters were optional, the state of the cursor was maintained internally by the compiler. In some cases this can give problems, especially when sub procedures are called in various order.

That is why it is best to enter both parameters when you use the CURSOR statement. 

See also

[DISPLAY](display.md) , [LCD](lcd_2.md) , [SHIFTLCD](shiftlcd.md) , [SHIFTCURSOR](shiftcursor.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : lcd.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: LCD, CLS, LOWERLINE, SHIFTLCD, SHIFTCURSOR, HOME

' CURSOR, DISPLAY

'micro : Mega8515

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m8515.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$sim

'REMOVE the above command for the real program !!

'$sim is used for faster simulation

'note : tested in PIN mode with 4-bit

'Config Lcdpin = Pin , Db4 = Portb.1 , Db5 = Portb.2 , Db6 = Portb.3 , Db7 = Portb.4 , E = Portb.5 , Rs = Portb.6

Config Lcdpin = Pin , Db4 = Porta.4 , Db5 = Porta.5 , Db6 = Porta.6 , Db7 = Porta.7 , E = Portc.7 , Rs = Portc.6

'These settings are for the STK200 in PIN mode

'Connect only DB4 to DB7 of the LCD to the LCD connector of the STK D4-D7

'Connect the E-line of the LCD to A15 (PORTC.7) and NOT to the E line of the LCD connector

'Connect the RS, V0, GND and =5V of the LCD to the STK LCD connector

```
Rem with the config lcdpin statement you can override the compiler settings

```vb
Dim A As Byte

Config Lcd = 16 * 2 'configure lcd screen

'other options are 16 * 4 and 20 * 4, 20 * 2 , 16 * 1a

'When you dont include this option 16 * 2 is assumed

'16 * 1a is intended for 16 character displays with split addresses over 2 lines

'$LCD = address will turn LCD into 8-bit databus mode

' use this with uP with external RAM and/or ROM

' because it aint need the port pins !

```
Cls 'clear the LCD display

Lcd "Hello world." 'display this at the top line

Wait 1

Lowerline 'select the lower line

Wait 1

Lcd "Shift this." 'display this at the lower line

```vb
Wait 1

For A = 1 To 10

```
Shiftlcd Right 'shift the text to the right

```vb
Wait 1 'wait a moment

Next

For A = 1 To 10

```
Shiftlcd Left 'shift the text to the left

```vb
Wait 1 'wait a moment

Next

```
Locate 2 , 1 'set cursor position

Lcd "*" 'display this

Wait 1 'wait a moment

Shiftcursor Right 'shift the cursor

Lcd "@" 'display this

Wait 1 'wait a moment

Home Upper 'select line 1 and return home

Lcd "Replaced." 'replace the text

Wait 1 'wait a moment

Cursor Off Noblink 'hide cursor

Wait 1 'wait a moment

Cursor On Blink 'show cursor

Wait 1 'wait a moment

Display Off 'turn display off

Wait 1 'wait a moment

Display On 'turn display on

'-----------------NEW support for 4-line LCD------

Thirdline

Lcd "Line 3"

Fourthline

Lcd "Line 4"

Home Third 'goto home on line three

Home Fourth

Home F 'first letteer also works

Locate 4 , 1 : Lcd "Line 4"

```vb
Wait 1

'Now lets build a special character

'the first number is the characternumber (0-7)

'The other numbers are the rowvalues

'Use the LCD tool to insert this line

```
Deflcdchar 1 , 225 , 227 , 226 , 226 , 226 , 242 , 234 , 228 ' replace ? with number (0-7)

Deflcdchar 0 , 240 , 224 , 224 , 255 , 254 , 252 , 248 , 240 ' replace ? with number (0-7)

Cls 'select data RAM

Rem it is important that a CLS is following the deflcdchar statements because it will set the controller back in datamode

Lcd Chr(0) ; Chr(1) 'print the special character

'----------------- Now use an internal routine ------------

_temp1 = 1 'value into ACC

!rCall _write_lcd 'put it on LCD

End

---

## Custom Designs

MCS does produce hardware to support special options. Like the [EM4095 Reference Design](em4095_rfid_reader.md) or the TCP TWI motherboard and adapter boards. We try to avoid SMD parts. In some cases this is not possible however.

For a prototype or small series, through hole components are simple to use. We do this with the hobbyist in mind. So our reference designs use little SMD parts too.

You can contact us also for :

\- custom bascom software

\- customer ASM drivers

\- windows software development

\- electronic or software projects

\- code review

\- SMD/TH electronic design

---

## DATA

Action

Specifies constant values to be read by subsequent READ statements.

Syntax

DATA var [, varn]

Remarks

Var | Numeric or string constant.  
---|---  
  
The DATA related statements use the internal registers pair R8 and R9 to store the data pointer.

To store a " sign on the data line, you can use :

DATA $34

The $-sign tells the compiler that the ASCII value will follow.

You can use this also to store special characters that can't be written by the editor such as chr(7)

Another way to include special ASCII characters in your string constant is to use {XXX}. You need to include exactly 3 digits representing the ASCII character. For example 65 is the ASCII number for the character A.

DATA "TEST{065}"

Will be read as TESTA.

While :

DATA "TEST{65}" will be read as :

TEST{65}. This because only 2 digits were included instead of 3.

{xxx} works only for string constants. It will also work in a normal string assignment :

s = "{065}" . This will assign A to the string s.

Because the DATA statements allow you to generate an EEP file to store in EEPROM, the [$DATA](data_1.md) and [$EEPROM](eeprom.md) directives have been added. Read the description of these directives to learn more about the DATA statement.

The DATA statements must not be accessed by the flow of your program because the DATA statements are converted to the byte representation of the DATA.

When your program flow enters the DATA lines, unpredictable results will occur.

So as in QB, the DATA statement is best be placed at the end of your program or in a place that program flow will no enter.

```vb
For example this is fine:

Print "Hello"

Goto jump

```
DATA "test"

Jump:

'because we jump over the data lines there is no problem.

The following example will case some problems:

```vb
Dim S As String * 10

Print "Hello"

```
Restore lbl

Read S

DATA "test"

Print S

When the END statement is used it must be placed BEFORE the DATA lines.

When you have multiple labels with data you need to be aware that each time a label is used, previous data will be aligned to a word. This because the AVR has a word address. This means that :

abc:

DATA 1

klm:

DATA 2

Will consume not 2 bytes but 2 words.

But :

abc:

DATA 1,2

klm:

DATA 3,4

Will also consume 4 bytes. When RESTORE is used, the label address is used which is a word. So take care to put labels only at places which need to be RESTORED/READ.

Difference with QB

Integer and Word constants must end with the %-sign.

Long and Dword constants must end with the &-sign.

Single constants must end with the !-sign.

Double constants must end with the #-sign.

See also

[READ](read.md) , [RESTORE](restore.md) , [$DATA](data_1.md) , [$EEPROM](eeprom.md) , [LOOKUP](lookup.md), [LOOKUPSTR](lookupstr.md) , [LOOKDOWN](lookdown.md) , [$USER](user.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : readdata.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : READ,RESTORE

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Integer , B1 As Byte , Count As Byte

Dim S As String * 15

Dim L As Long

```
Restore Dta1 'point to stored data

For Count = 1 To 3 'for number of data items

Read B1 : Print Count ; " " ; B1

Next

Restore Dta2 'point to stored data

For Count = 1 To 2 'for number of data items

Read A : Print Count ; " " ; A

Next

Restore Dta3

Read S : Print S

Read S : Print S

Restore Dta4

Read L : Print L 'long type

```vb
'demonstration of readlabel

Dim W As Iram Word At 8 Overlay ' location is used by restore pointer

'note that W does not use any RAM it is an overlayed pointer to the data pointer

```
W = Loadlabel(dta1) ' loadlabel expects the labelname

Read B1

```vb
Print B1

End

```
Dta1:

Data &B10 , &HFF , 10

Dta2:

Data 1000% , -1%

Dta3:

Data "Hello" , "World"

```vb
'Note that integer values (>255 or <0) must end with the %-sign

'also note that the data type must match the variable type that is

'used for the READ statement

```
Dta4:

Data 123456789&

```vb
'Note that LONG values must end with the &-sign

'Also note that the data type must match the variable type that is used

'for the READ statement

```

---

## DATE

Action

Returns a date-value (String or 3 Bytes for Day, Month and Year) depending of the data type of the Target

Syntax

bDayMonthYear = Date(lSysSec)

bDayMonthYear = Date(lSysDay)

bDayMonthYear = Date(strDate)

strDate = Date(lSysSec)

strDate = Date(lSysDay)

strDate = Date(bDayMonthYear)

Remarks

StrDate | A Date-String in the format specified in the CONFIG DATE statement  
---|---  
LsysSec | A LONG â variable which holds the System Second (SysSec = TimeStamp)  
LsysDay | A WORD â variable, which holds then System Day (SysDay)  
BDayMonthYear | A BYTE â variable, which holds Days, followed by Month (Byte) and Year (Byte). You can use a byte array, or 3 bytes dimensioned after each other.  
  
Converting to String:

![important](important.jpg)The target string must have a length of at least 8 Bytes, otherwise SRAM after the target-string will be overwritten.

Converting to Soft clock date format (3 Bytes for Day, Month and Year):

Three Bytes for Day, Month and Year must follow each other in SRAM. The variable-name of the first Byte, the one for Day must be passed to the function.

See also

[Date and Time Routines](datetime.md) , [DAYOFYEAR](dayofyear.md), [SYSDAY](sysday.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : datetime_test1,bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : show how to use the Date-Time routines from the DateTime.Lib

'micro : Mega103

'suited for demo : no

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m103def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

```
Const Clockmode = 1

```vb
'use i2c for the clock

#if Clockmode = 1

Config Clock = Soft ' we use build in clock

Disable Interrupts

#else

Config Clock = User ' we use I2C for the clock

'configure the scl and sda pins

Config Sda = Portd.6

Config Scl = Portd.5

'address of ds1307

```
Const Ds1307w = &HD0 ' Addresses of Ds1307 clock

Const Ds1307r = &HD1

```vb
#endif

'configure the date format

Config Date = Ymd , Separator = - ' ANSI-Format

'This sample does not have the clock started so interrupts are not enabled

' Enable Interrupts

'dim the used variables

Dim Lvar1 As Long

Dim Mday As Byte

Dim Bweekday As Byte , Strweekday As String * 10

Dim Strdate As String * 8

Dim Strtime As String * 8

Dim Bsec As Byte , Bmin As Byte , Bhour As Byte

Dim Bday As Byte , Bmonth As Byte , Byear As Byte

Dim Lsecofday As Long

Dim Wsysday As Word

Dim Lsyssec As Long

Dim Wdayofyear As Word

' =================== DayOfWeek =============================================

' Example 1 with internal RTC-Clock

```
_day = 4 : _month = 11 : _year = 2 ' Load RTC-Clock for example - testing

Bweekday = Dayofweek()

Strweekday = Lookupstr(bweekday , Weekdays)

```vb
Print "Weekday-Number of " ; Date$ ; " is " ; Bweekday ; " = " ; Strweekday

' Example 2 with defined Clock - Bytes (Day / Month / Year)

```
Bday = 26 : Bmonth = 11 : Byear = 2

Bweekday = Dayofweek(bday)

Strweekday = Lookupstr(bweekday , Weekdays)

Strdate = Date(bday)

```vb
Print "Weekday-Number of Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " is " ; Bweekday ; " (" ; Date(bday) ; ") = " ; Strweekday

' Example 3 with System Day

```
Wsysday = 2000 ' that is 2005-06-23

Bweekday = Dayofweek(wsysday)

Strweekday = Lookupstr(bweekday , Weekdays)

```vb
Print "Weekday-Number of System Day " ; Wsysday ; " (" ; Date(wsysday) ; ") is " ; Bweekday ; " = " ; Strweekday

' Example 4 with System Second

```
Lsyssec = 123456789 ' that is 2003-11-29 at 21:33:09

Bweekday = Dayofweek(lsyssec)

Strweekday = Lookupstr(bweekday , Weekdays)

```vb
Print "Weekday-Number of System Second " ; Lsyssec ; " (" ; Date(lsyssec) ; ") is " ; Bweekday ; " = " ; Strweekday

' Example 5 with Date-String

```
Strdate = "04-11-02" ' we have configured Date in ANSI

Bweekday = Dayofweek(strdate)

Strweekday = Lookupstr(bweekday , Weekdays)

```vb
Print "Weekday-Number of " ; Strdate ; " is " ; Bweekday ; " = " ; Strweekday

' ================= Second of Day =============================================

' Example 1 with internal RTC-Clock

```
_sec = 12 : _min = 30 : _hour = 18 ' Load RTC-Clock for example - testing

Lsecofday = Secofday()

```vb
Print "Second of Day of " ; Time$ ; " is " ; Lsecofday

' Example 2 with defined Clock - Bytes (Second / Minute / Hour)

```
Bsec = 20 : Bmin = 1 : Bhour = 7

Lsecofday = Secofday(bsec)

```vb
Print "Second of Day of Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " (" ; Time(bsec) ; ") is " ; Lsecofday

' Example 3 with System Second

```
Lsyssec = 1234456789

Lsecofday = Secofday(lsyssec)

```vb
Print "Second of Day of System Second " ; Lsyssec ; "(" ; Time(lsyssec) ; ") is " ; Lsecofday

' Example 4 with Time - String

```
Strtime = "04:58:37"

Lsecofday = Secofday(strtime)

```vb
Print "Second of Day of " ; Strtime ; " is " ; Lsecofday

' ================== System Second ============================================

' Example 1 with internal RTC-Clock

' Load RTC-Clock for example - testing

```
_sec = 17 : _min = 35 : _hour = 8 : _day = 16 : _month = 4 : _year = 3

Lsyssec = Syssec()

```vb
Print "System Second of " ; Time$ ; " at " ; Date$ ; " is " ; Lsyssec

' Example 2 with with defined Clock - Bytes (Second, Minute, Hour, Day / Month / Year)

```
Bsec = 20 : Bmin = 1 : Bhour = 7 : Bday = 22 : Bmonth = 12 : Byear = 1

Lsyssec = Syssec(bsec)

Strtime = Time(bsec)

Strdate = Date(bday)

```vb
Print "System Second of " ; Strtime ; " at " ; Strdate ; " is " ; Lsyssec

' Example 3 with System Day

```
Wsysday = 2000

Lsyssec = Syssec(wsysday)

```vb
Print "System Second of System Day " ; Wsysday ; " (" ; Date(wsysday) ; " 00:00:00) is " ; Lsyssec

' Example 4 with Time and Date String

```
Strtime = "10:23:50"

Strdate = "02-11-29" ' ANSI-Date

Lsyssec = Syssec(strtime , Strdate)

```vb
Print "System Second of " ; Strtime ; " at " ; Strdate ; " is " ; Lsyssec ' 91880630

' ==================== Day Of Year =========================================

' Example 1 with internal RTC-Clock

```
_day = 20 : _month = 11 : _year = 2 ' Load RTC-Clock for example - testing

Wdayofyear = Dayofyear()

```vb
Print "Day Of Year of " ; Date$ ; " is " ; Wdayofyear

' Example 2 with defined Clock - Bytes (Day / Month / Year)

```
Bday = 24 : Bmonth = 5 : Byear = 8

Wdayofyear = Dayofyear(bday)

```vb
Print "Day Of Year of Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " (" ; Date(bday) ; ") is " ; Wdayofyear

' Example 3 with Date - String

```
Strdate = "04-10-29" ' we have configured ANSI Format

Wdayofyear = Dayofyear(strdate)

```vb
Print "Day Of Year of " ; Strdate ; " is " ; Wdayofyear

' Example 4 with System Second

```
Lsyssec = 123456789

Wdayofyear = Dayofyear(lsyssec)

```vb
Print "Day Of Year of System Second " ; Lsyssec ; " (" ; Date(lsyssec) ; ") is " ; Wdayofyear

' Example 5 with System Day

```
Wsysday = 3000

Wdayofyear = Dayofyear(wsysday)

```vb
Print "Day Of Year of System Day " ; Wsysday ; " (" ; Date(wsysday) ; ") is " ; Wdayofyear

' =================== System Day ======================================

' Example 1 with internal RTC-Clock

```
_day = 20 : _month = 11 : _year = 2 ' Load RTC-Clock for example - testing

Wsysday = Sysday()

```vb
Print "System Day of " ; Date$ ; " is " ; Wsysday

' Example 2 with defined Clock - Bytes (Day / Month / Year)

```
Bday = 24 : Bmonth = 5 : Byear = 8

Wsysday = Sysday(bday)

```vb
Print "System Day of Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " (" ; Date(bday) ; ") is " ; Wsysday

' Example 3 with Date - String

```
Strdate = "04-10-29"

Wsysday = Sysday(strdate)

```vb
Print "System Day of " ; Strdate ; " is " ; Wsysday

' Example 4 with System Second

```
Lsyssec = 123456789

Wsysday = Sysday(lsyssec)

```vb
Print "System Day of System Second " ; Lsyssec ; " (" ; Date(lsyssec) ; ") is " ; Wsysday

' =================== Time ================================================

' Example 1: Converting defined Clock - Bytes (Second / Minute / Hour) to Time - String

```
Bsec = 20 : Bmin = 1 : Bhour = 7

Strtime = Time(bsec)

```vb
Print "Time values: Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " converted to string " ; Strtime

' Example 2: Converting System Second to Time - String

```
Lsyssec = 123456789

Strtime = Time(lsyssec)

```vb
Print "Time of Systemsecond " ; Lsyssec ; " is " ; Strtime

' Example 3: Converting Second of Day to Time - String

```
Lsecofday = 12345

Strtime = Time(lsecofday)

```vb
Print "Time of Second of Day " ; Lsecofday ; " is " ; Strtime

' Example 4: Converting System Second to defined Clock - Bytes (Second / Minute / Hour)

```
Lsyssec = 123456789

Bsec = Time(lsyssec)

```vb
Print "System Second " ; Lsyssec ; " converted to Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " (" ; Time(lsyssec) ; ")"

' Example 5: Converting Second of Day to defined Clock - Bytes (Second / Minute / Hour)

```
Lsecofday = 12345

Bsec = Time(lsecofday)

```vb
Print "Second of Day " ; Lsecofday ; " converted to Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " (" ; Time(lsecofday) ; ")"

' Example 6: Converting Time-string to defined Clock - Bytes (Second / Minute / Hour)

```
Strtime = "07:33:12"

Bsec = Time(strtime)

```vb
Print "Time " ; Strtime ; " converted to Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour

' ============================= Date ==========================================

' Example 1: Converting defined Clock - Bytes (Day / Month / Year) to Date - String

```
Bday = 29 : Bmonth = 4 : Byear = 12

Strdate = Date(bday)

```vb
Print "Dat values: Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " converted to string " ; Strdate

' Example 2: Converting from System Day to Date - String

```
Wsysday = 1234

Strdate = Date(wsysday)

```vb
Print "System Day " ; Wsysday ; " is " ; Strdate

' Example 3: Converting from System Second to Date String

```
Lsyssec = 123456789

Strdate = Date(lsyssec)

```vb
Print "System Second " ; Lsyssec ; " is " ; Strdate

' Example 4: Converting SystemDay to defined Clock - Bytes (Day / Month / Year)

```
Wsysday = 2000

Bday = Date(wsysday)

```vb
Print "System Day " ; Wsysday ; " converted to Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " (" ; Date(wsysday) ; ")"

' Example 5: Converting Date - String to defined Clock - Bytes (Day / Month / Year)

```
Strdate = "04-08-31"

Bday = Date(strdate)

```vb
Print "Date " ; Strdate ; " converted to Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear

' Example 6: Converting System Second to defined Clock - Bytes (Day / Month / Year)

```
Lsyssec = 123456789

Bday = Date(lsyssec)

```vb
Print "System Second " ; Lsyssec ; " converted to Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " (" ; Date(lsyssec) ; ")"

' ================ Second of Day elapsed

```
Lsecofday = Secofday()

_hour = _hour + 1

Lvar1 = Secelapsed(lsecofday)

Print Lvar1

Lsyssec = Syssec()

_day = _day + 1

Lvar1 = Syssecelapsed(lsyssec)

Print Lvar1

Looptest:

' Initialising for testing

_day = 1

_month = 1

_year = 1

_sec = 12

_min = 13

_hour = 14

```vb
Do

If _year > 50 Then

Exit Do

End If

```
_sec = _sec + 7

If _sec > 59 Then

Incr _min

_sec = _sec - 60

End If

_min = _min + 2

If _min > 59 Then

Incr _hour

_min = _min - 60

End If

_hour = _hour + 1

If _hour > 23 Then

Incr _day

_hour = _hour - 24

End If

_day = _day + 1

```vb
If _day > 28 Then

Select Case _month

Case 1

```
Mday = 31

Case 2

Mday = _year And &H03

If Mday = 0 Then

Mday = 29

Else

Mday = 28

```vb
End If

Case 3

```
Mday = 31

Case 4

Mday = 30

Case 5

Mday = 31

Case 6

Mday = 30

Case 7

Mday = 31

Case 8

Mday = 31

Case 9

Mday = 30

Case 10

Mday = 31

Case 11

Mday = 30

Case 12

Mday = 31

```vb
End Select

If _day > Mday Then

```
_day = _day - Mday

Incr _month

If _month > 12 Then

_month = 1

Incr _year

```vb
End If

End If

End If

If _year > 99 Then

Exit Do

End If

```
Lsecofday = Secofday()

Lsyssec = Syssec()

Bweekday = Dayofweek()

Wdayofyear = Dayofyear()

Wsysday = Sysday()

```vb
Print Time$ ; " " ; Date$ ; " " ; Lsecofday ; " " ; Lsyssec ; " " ; Bweekday ; " " ; Wdayofyear ; " " ; Wsysday

Loop

End

'only when we use I2C for the clock we need to set the clock date time

#if Clockmode = 0

'called from datetime.lib

Dim Weekday As Byte

```
Getdatetime:

I2cstart ' Generate start code

I2cwbyte Ds1307w ' send address

I2cwbyte 0 ' start address in 1307

I2cstart ' Generate start code

I2cwbyte Ds1307r ' send address

I2crbyte _sec , Ack

I2crbyte _min , Ack ' MINUTES

I2crbyte _hour , Ack ' Hours

I2crbyte Weekday , Ack ' Day of Week

I2crbyte _day , Ack ' Day of Month

I2crbyte _month , Ack ' Month of Year

I2crbyte _year , Nack ' Year

I2cstop

_sec = Makedec(_sec) : _min = Makedec(_min) : _hour = Makedec(_hour)

_day = Makedec(_day) : _month = Makedec(_month) : _year = Makedec(_year)

Return

Setdate:

_day = Makebcd(_day) : _month = Makebcd(_month) : _year = Makebcd(_year)

I2cstart ' Generate start code

I2cwbyte Ds1307w ' send address

I2cwbyte 4 ' starting address in 1307

I2cwbyte _day ' Send Data to SECONDS

I2cwbyte _month ' MINUTES

I2cwbyte _year ' Hours

I2cstop

Return

Settime:

_sec = Makebcd(_sec) : _min = Makebcd(_min) : _hour = Makebcd(_hour)

I2cstart ' Generate start code

I2cwbyte Ds1307w ' send address

I2cwbyte 0 ' starting address in 1307

I2cwbyte _sec ' Send Data to SECONDS

I2cwbyte _min ' MINUTES

I2cwbyte _hour ' Hours

I2cstop

```vb
Return

#endif

```
Weekdays:

Data "Monday" , "Tuesday" , "Wednesday" , "Thursday" , "Friday" , "Saturday" , "Sunday"

---

## Date and Time



---

## DATE$

Action

Internal variable that holds the date.

Syntax

DATE$ = "mm/dd/yy"

var = DATE$

Remarks

The DATE$ variable is used in combination with the [CONFIG CLOCK](config_clock.md) directive.

The [CONFIG CLOCK](config_clock.md) statement will create an interrupt that occurs every second. In this interrupt routine the _Sec, _Min and _Hour variables are updated. The _dat, _month and _year variables are also updated. The date format is in the same format as in VB.

When you assign DATE$ to a string variable these variables are assigned to the DATE$ variable.

When you assign the DATE$ variable with a constant or other variable, the _day, _month and _year variables will be changed to the new date.

The only difference with VB is that all data must be provided when assigning the date. This is done for minimal code. You can change this behavior of course.

![important](important.jpg) Do not confuse DATE$ with the DATE function !

ASM

The following ASM routines are called.

When assigning DATE$ : _set_date (calls _str2byte)

When reading DATE$ : _make_dt (calls _byte2str)

See also

[TIME$](time_.md) , [CONFIG CLOCK](config_clock.md) , [DATE](date.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : megaclock.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : shows the new TIME$ and DATE$ reserved variables

'micro : Mega103

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m103def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'With the 8535 and timer2 or the Mega103 and TIMER0 you can

'easily implement a clock by attaching a 32768 Hz xtal to the timer

'And of course some BASCOM code

'This example is written for the STK300 with M103

Enable Interrupts

'[configure LCD]

$lcd = &HC000 'address for E and RS

$lcdrs = &H8000 'address for only E

Config Lcd = 20 * 4 'nice display from bg micro

Config Lcdbus = 4 'we run it in bus mode and I hooked up only db4-db7

Config Lcdmode = Bus 'tell about the bus mode

'[now init the clock]

Config Date = Mdy , Separator = / ' ANSI-Format

Config Clock = Soft 'this is how simple it is

'The above statement will bind in an ISR so you can not use the TIMER anymore!

'For the M103 in this case it means that TIMER0 can not be used by the user anymore

'assign the date to the reserved date$

'The format is MM/DD/YY

```
Date$ = "11/11/00"

```vb
'assign the time, format in hh:mm:ss military format(24 hours)

'You may not use 1:2:3 !! adding support for this would mean overhead

'But of course you can alter the library routines used

```
Time$ = "02:20:00"

```vb
'---------------------------------------------------

'clear the LCD display

```
Cls

Do

Home 'cursor home

Lcd Date$ ; " " ; Time$ 'show the date and time

```vb
Loop

'The clock routine does use the following internal variables:

'_day , _month, _year , _sec, _hour, _min

'These are all bytes. You can assign or use them directly

```
_day = 1

```vb
'For the _year variable only the year is stored, not the century

End

```

---

## DATETIME

The DateTime library is written by Josef Franz VÃ¶gel. It extends the clock routines with date and time calculation.

The following functions are available:

[DayOfWeek](dayofweek.md) | Returns the day of the week  
---|---  
[DayOfYear](dayofyear.md) | Returns the day of the year  
[SecOfDay](secofday.md) | Returns the second of the day  
[SecElapsed](secelapsed.md) | Returns the elapsed Seconds to a former assigned time-stamp  
[SysDay](sysday.md) | Returns a number, which represents the System Day  
[SysSec](syssec.md) | Returns a Number, which represents the System Second  
[SysSecElapsed](syssecelapsed.md) | Returns the elapsed Seconds to a earlier assigned system-time-stamp  
[Time](time.md) | Returns a time-value (String or 3 Byte for Second, Minute and Hour) depending of the Type of the Target  
[Date](date.md) | Returns a date-value (String or 3 Bytes for Day, Month and Year) depending of the Type of the Target  
  
![notice](notice.jpg) Date and time not to be confused with Date$ and Time$ !

The date starts at 1.1.2000 and valid from 2000 to 2099

If you wish to convert to NTP which starts at 1.1.1970, which is 30 years earlier, you need to subtract a value of 946684800

BASCOM DATE_TIME = NTP - 946684800

![notice](notice.jpg)Most of the Date and Time functions accept variables which must be in sequential memory order. Like bSec, bMin, bHour

When using DIM like this : Dim bSec As Byte, bMin As Byte, bHour As byte , the variables will be in sequential order, but this might change in the future.

Better would be to be explicit : Dim bSec as byte , bMin as byte at bSec + 1 , bHour as byte at bMin + 1

This will ensure that the bytes will be mapped in the right order. 

![notice](notice.jpg)It is important that you use the [CONFIG CLOCK](config_clock.md) option since this will include the date time library. 

See also

[config clock](config_clock.md), [config date](config_date.md)

---

## DAYOFWEEK

Action

Returns the Day of the Week of a Date.

Syntax

Target = DayOfWeek()

Target = DayOfWeek(bDayMonthYear)

Target = DayOfWeek(strDate)

Target = DayOfWeek(wSysDay)

Target = DayOfWeek(lSysSec)

Remarks

Target | A Byte â variable, that is assigned with the day of the week  
---|---  
BDayMonthYear | A Byte â variable, which holds the Day-value followed by Month(Byte) and Year (Byte)  
StrDate | A String, which holds a Date-String in the format specified in the CONFIG DATE statement  
WSysDay | A Word â variable, which holds the System Day (SysDay)  
LSysSec | A Long â variable, which holds the System Second (SysSec)  
  
The Function can be used with five different kind of Input:

1.| Without any parameter. The internal Date-values of SOFTCLOCK (_day, _month, _year) are used.  
---|---  
  
2.| With a user defined date array. It must be arranged in same way (Day, Month, Year) as the internal SOFTCLOCK date. The first Byte (Day) is the input by this kind of usage. So the Day of the Week can be calculated of every date.  
---|---  
  
3.| With a Date-String. The date-string must be in the Format specified in the Config Date Statement  
---|---  
  
4.| With a System Day â Number.  
---|---  
  
5.| With a System Second - Number  
---|---  
  
The Return-Value is in the range of 0 to 6, Monday starts with 0.

The Function is valid in the 21th century (from 2000-01-01 to 2099-12-31).

See Also

[Date and Time routines](datetime.md) , [CONFIG DATE](config_date.md) , [CONFIG CLOCK](config_clock.md), [SYSDAY](sysday.md), [SYSSEC](syssec.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : datetime_test1,bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : show how to use the Date-Time routines from the DateTime.Lib

'micro : Mega103

'suited for demo : no

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m103def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

```
Const Clockmode = 1

```vb
'use i2c for the clock

#if Clockmode = 1

Config Clock = Soft ' we use build in clock

Disable Interrupts

#else

Config Clock = User ' we use I2C for the clock

'configure the scl and sda pins

Config Sda = Portd.6

Config Scl = Portd.5

'address of ds1307

```
Const Ds1307w = &HD0 ' Addresses of Ds1307 clock

Const Ds1307r = &HD1

```vb
#endif

'configure the date format

Config Date = Ymd , Separator = - ' ANSI-Format

'This sample does not have the clock started so interrupts are not enabled

' Enable Interrupts

'dim the used variables

Dim Lvar1 As Long

Dim Mday As Byte

Dim Bweekday As Byte , Strweekday As String * 10

Dim Strdate As String * 8

Dim Strtime As String * 8

Dim Bsec As Byte , Bmin As Byte , Bhour As Byte

Dim Bday As Byte , Bmonth As Byte , Byear As Byte

Dim Lsecofday As Long

Dim Wsysday As Word

Dim Lsyssec As Long

Dim Wdayofyear As Word

' =================== DayOfWeek =============================================

' Example 1 with internal RTC-Clock

```
_day = 4 : _month = 11 : _year = 2 ' Load RTC-Clock for example - testing

Bweekday = Dayofweek()

Strweekday = Lookupstr(bweekday , Weekdays)

```vb
Print "Weekday-Number of " ; Date$ ; " is " ; Bweekday ; " = " ; Strweekday

' Example 2 with defined Clock - Bytes (Day / Month / Year)

```
Bday = 26 : Bmonth = 11 : Byear = 2

Bweekday = Dayofweek(bday)

Strweekday = Lookupstr(bweekday , Weekdays)

Strdate = Date(bday)

```vb
Print "Weekday-Number of Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " is " ; Bweekday ; " (" ; Date(bday) ; ") = " ; Strweekday

' Example 3 with System Day

```
Wsysday = 2000 ' that is 2005-06-23

Bweekday = Dayofweek(wsysday)

Strweekday = Lookupstr(bweekday , Weekdays)

```vb
Print "Weekday-Number of System Day " ; Wsysday ; " (" ; Date(wsysday) ; ") is " ; Bweekday ; " = " ; Strweekday

' Example 4 with System Second

```
Lsyssec = 123456789 ' that is 2003-11-29 at 21:33:09

Bweekday = Dayofweek(lsyssec)

Strweekday = Lookupstr(bweekday , Weekdays)

```vb
Print "Weekday-Number of System Second " ; Lsyssec ; " (" ; Date(lsyssec) ; ") is " ; Bweekday ; " = " ; Strweekday

' Example 5 with Date-String

```
Strdate = "04-11-02" ' we have configured Date in ANSI

Bweekday = Dayofweek(strdate)

Strweekday = Lookupstr(bweekday , Weekdays)

```vb
Print "Weekday-Number of " ; Strdate ; " is " ; Bweekday ; " = " ; Strweekday

' ================= Second of Day =============================================

' Example 1 with internal RTC-Clock

```
_sec = 12 : _min = 30 : _hour = 18 ' Load RTC-Clock for example - testing

Lsecofday = Secofday()

```vb
Print "Second of Day of " ; Time$ ; " is " ; Lsecofday

' Example 2 with defined Clock - Bytes (Second / Minute / Hour)

```
Bsec = 20 : Bmin = 1 : Bhour = 7

Lsecofday = Secofday(bsec)

```vb
Print "Second of Day of Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " (" ; Time(bsec) ; ") is " ; Lsecofday

' Example 3 with System Second

```
Lsyssec = 1234456789

Lsecofday = Secofday(lsyssec)

```vb
Print "Second of Day of System Second " ; Lsyssec ; "(" ; Time(lsyssec) ; ") is " ; Lsecofday

' Example 4 with Time - String

```
Strtime = "04:58:37"

Lsecofday = Secofday(strtime)

```vb
Print "Second of Day of " ; Strtime ; " is " ; Lsecofday

' ================== System Second ============================================

' Example 1 with internal RTC-Clock

' Load RTC-Clock for example - testing

```
_sec = 17 : _min = 35 : _hour = 8 : _day = 16 : _month = 4 : _year = 3

Lsyssec = Syssec()

```vb
Print "System Second of " ; Time$ ; " at " ; Date$ ; " is " ; Lsyssec

' Example 2 with with defined Clock - Bytes (Second, Minute, Hour, Day / Month / Year)

```
Bsec = 20 : Bmin = 1 : Bhour = 7 : Bday = 22 : Bmonth = 12 : Byear = 1

Lsyssec = Syssec(bsec)

Strtime = Time(bsec)

Strdate = Date(bday)

```vb
Print "System Second of " ; Strtime ; " at " ; Strdate ; " is " ; Lsyssec

' Example 3 with System Day

```
Wsysday = 2000

Lsyssec = Syssec(wsysday)

```vb
Print "System Second of System Day " ; Wsysday ; " (" ; Date(wsysday) ; " 00:00:00) is " ; Lsyssec

' Example 4 with Time and Date String

```
Strtime = "10:23:50"

Strdate = "02-11-29" ' ANSI-Date

Lsyssec = Syssec(strtime , Strdate)

```vb
Print "System Second of " ; Strtime ; " at " ; Strdate ; " is " ; Lsyssec ' 91880630

' ==================== Day Of Year =========================================

' Example 1 with internal RTC-Clock

```
_day = 20 : _month = 11 : _year = 2 ' Load RTC-Clock for example - testing

Wdayofyear = Dayofyear()

```vb
Print "Day Of Year of " ; Date$ ; " is " ; Wdayofyear

' Example 2 with defined Clock - Bytes (Day / Month / Year)

```
Bday = 24 : Bmonth = 5 : Byear = 8

Wdayofyear = Dayofyear(bday)

```vb
Print "Day Of Year of Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " (" ; Date(bday) ; ") is " ; Wdayofyear

' Example 3 with Date - String

```
Strdate = "04-10-29" ' we have configured ANSI Format

Wdayofyear = Dayofyear(strdate)

```vb
Print "Day Of Year of " ; Strdate ; " is " ; Wdayofyear

' Example 4 with System Second

```
Lsyssec = 123456789

Wdayofyear = Dayofyear(lsyssec)

```vb
Print "Day Of Year of System Second " ; Lsyssec ; " (" ; Date(lsyssec) ; ") is " ; Wdayofyear

' Example 5 with System Day

```
Wsysday = 3000

Wdayofyear = Dayofyear(wsysday)

```vb
Print "Day Of Year of System Day " ; Wsysday ; " (" ; Date(wsysday) ; ") is " ; Wdayofyear

' =================== System Day ======================================

' Example 1 with internal RTC-Clock

```
_day = 20 : _month = 11 : _year = 2 ' Load RTC-Clock for example - testing

Wsysday = Sysday()

```vb
Print "System Day of " ; Date$ ; " is " ; Wsysday

' Example 2 with defined Clock - Bytes (Day / Month / Year)

```
Bday = 24 : Bmonth = 5 : Byear = 8

Wsysday = Sysday(bday)

```vb
Print "System Day of Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " (" ; Date(bday) ; ") is " ; Wsysday

' Example 3 with Date - String

```
Strdate = "04-10-29"

Wsysday = Sysday(strdate)

```vb
Print "System Day of " ; Strdate ; " is " ; Wsysday

' Example 4 with System Second

```
Lsyssec = 123456789

Wsysday = Sysday(lsyssec)

```vb
Print "System Day of System Second " ; Lsyssec ; " (" ; Date(lsyssec) ; ") is " ; Wsysday

' =================== Time ================================================

' Example 1: Converting defined Clock - Bytes (Second / Minute / Hour) to Time - String

```
Bsec = 20 : Bmin = 1 : Bhour = 7

Strtime = Time(bsec)

```vb
Print "Time values: Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " converted to string " ; Strtime

' Example 2: Converting System Second to Time - String

```
Lsyssec = 123456789

Strtime = Time(lsyssec)

```vb
Print "Time of Systemsecond " ; Lsyssec ; " is " ; Strtime

' Example 3: Converting Second of Day to Time - String

```
Lsecofday = 12345

Strtime = Time(lsecofday)

```vb
Print "Time of Second of Day " ; Lsecofday ; " is " ; Strtime

' Example 4: Converting System Second to defined Clock - Bytes (Second / Minute / Hour)

```
Lsyssec = 123456789

Bsec = Time(lsyssec)

```vb
Print "System Second " ; Lsyssec ; " converted to Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " (" ; Time(lsyssec) ; ")"

' Example 5: Converting Second of Day to defined Clock - Bytes (Second / Minute / Hour)

```
Lsecofday = 12345

Bsec = Time(lsecofday)

```vb
Print "Second of Day " ; Lsecofday ; " converted to Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " (" ; Time(lsecofday) ; ")"

' Example 6: Converting Time-string to defined Clock - Bytes (Second / Minute / Hour)

```
Strtime = "07:33:12"

Bsec = Time(strtime)

```vb
Print "Time " ; Strtime ; " converted to Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour

' ============================= Date ==========================================

' Example 1: Converting defined Clock - Bytes (Day / Month / Year) to Date - String

```
Bday = 29 : Bmonth = 4 : Byear = 12

Strdate = Date(bday)

```vb
Print "Dat values: Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " converted to string " ; Strdate

' Example 2: Converting from System Day to Date - String

```
Wsysday = 1234

Strdate = Date(wsysday)

```vb
Print "System Day " ; Wsysday ; " is " ; Strdate

' Example 3: Converting from System Second to Date String

```
Lsyssec = 123456789

Strdate = Date(lsyssec)

```vb
Print "System Second " ; Lsyssec ; " is " ; Strdate

' Example 4: Converting SystemDay to defined Clock - Bytes (Day / Month / Year)

```
Wsysday = 2000

Bday = Date(wsysday)

```vb
Print "System Day " ; Wsysday ; " converted to Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " (" ; Date(wsysday) ; ")"

' Example 5: Converting Date - String to defined Clock - Bytes (Day / Month / Year)

```
Strdate = "04-08-31"

Bday = Date(strdate)

```vb
Print "Date " ; Strdate ; " converted to Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear

' Example 6: Converting System Second to defined Clock - Bytes (Day / Month / Year)

```
Lsyssec = 123456789

Bday = Date(lsyssec)

```vb
Print "System Second " ; Lsyssec ; " converted to Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " (" ; Date(lsyssec) ; ")"

' ================ Second of Day elapsed

```
Lsecofday = Secofday()

_hour = _hour + 1

Lvar1 = Secelapsed(lsecofday)

Print Lvar1

Lsyssec = Syssec()

_day = _day + 1

Lvar1 = Syssecelapsed(lsyssec)

Print Lvar1

Looptest:

' Initialising for testing

_day = 1

_month = 1

_year = 1

_sec = 12

_min = 13

_hour = 14

```vb
Do

If _year > 50 Then

Exit Do

End If

```
_sec = _sec + 7

If _sec > 59 Then

Incr _min

_sec = _sec - 60

End If

_min = _min + 2

If _min > 59 Then

Incr _hour

_min = _min - 60

End If

_hour = _hour + 1

If _hour > 23 Then

Incr _day

_hour = _hour - 24

End If

_day = _day + 1

```vb
If _day > 28 Then

Select Case _month

Case 1

```
Mday = 31

Case 2

Mday = _year And &H03

If Mday = 0 Then

Mday = 29

Else

Mday = 28

```vb
End If

Case 3

```
Mday = 31

Case 4

Mday = 30

Case 5

Mday = 31

Case 6

Mday = 30

Case 7

Mday = 31

Case 8

Mday = 31

Case 9

Mday = 30

Case 10

Mday = 31

Case 11

Mday = 30

Case 12

Mday = 31

```vb
End Select

If _day > Mday Then

```
_day = _day - Mday

Incr _month

If _month > 12 Then

_month = 1

Incr _year

```vb
End If

End If

End If

If _year > 99 Then

Exit Do

End If

```
Lsecofday = Secofday()

Lsyssec = Syssec()

Bweekday = Dayofweek()

Wdayofyear = Dayofyear()

Wsysday = Sysday()

```vb
Print Time$ ; " " ; Date$ ; " " ; Lsecofday ; " " ; Lsyssec ; " " ; Bweekday ; " " ; Wdayofyear ; " " ; Wsysday

Loop

End

'only when we use I2C for the clock we need to set the clock date time

#if Clockmode = 0

'called from datetime.lib

Dim Weekday As Byte

```
Getdatetime:

I2cstart ' Generate start code

I2cwbyte Ds1307w ' send address

I2cwbyte 0 ' start address in 1307

I2cstart ' Generate start code

I2cwbyte Ds1307r ' send address

I2crbyte _sec , Ack

I2crbyte _min , Ack ' MINUTES

I2crbyte _hour , Ack ' Hours

I2crbyte Weekday , Ack ' Day of Week

I2crbyte _day , Ack ' Day of Month

I2crbyte _month , Ack ' Month of Year

I2crbyte _year , Nack ' Year

I2cstop

_sec = Makedec(_sec) : _min = Makedec(_min) : _hour = Makedec(_hour)

_day = Makedec(_day) : _month = Makedec(_month) : _year = Makedec(_year)

Return

Setdate:

_day = Makebcd(_day) : _month = Makebcd(_month) : _year = Makebcd(_year)

I2cstart ' Generate start code

I2cwbyte Ds1307w ' send address

I2cwbyte 4 ' starting address in 1307

I2cwbyte _day ' Send Data to SECONDS

I2cwbyte _month ' MINUTES

I2cwbyte _year ' Hours

I2cstop

Return

Settime:

_sec = Makebcd(_sec) : _min = Makebcd(_min) : _hour = Makebcd(_hour)

I2cstart ' Generate start code

I2cwbyte Ds1307w ' send address

I2cwbyte 0 ' starting address in 1307

I2cwbyte _sec ' Send Data to SECONDS

I2cwbyte _min ' MINUTES

I2cwbyte _hour ' Hours

I2cstop

```vb
Return

#endif

```
Weekdays:

Data "Monday" , "Tuesday" , "Wednesday" , "Thursday" , "Friday" , "Saturday" , "Sunday"

---

## DAYOFYEAR

Action

Returns the Day of the Year of a Date

Syntax

Target = DayOfYear()

Target = DayOfYear(bDayMonthYear)

Target = DayOfYear(strDate)

Target = DayOfYear(wSysDay)

Target = DayOfYear(lSysSec)

Remarks

Target | A Integer, that is assigned with the Day of the Year  
---|---  
BDayMonthYear | A Byte, which holds the Day-value followed by Month(Byte) and Year (Byte)  
StrDate | A String, which holds a Date-String in the format specified in the CONFIG DATE statement  
WSysDay | A Variable (Word) which holds a System Day (SysDay)  
LsysSec | A Variable (Long) which holds a System Second (SysSec)  
  
The Function can be used with five different kind of Input:

1.| Without any parameter. The internal Date-values of SOFTCLOCK (_day, _month, _year) are used.  
---|---  
  
2.| With a user defined date array. It must be arranged in same way (Day, Month, Year) as the internal SOFTCLOCK date. The first Byte (Day) is the input by this kind of usage. So the Day of the Year can be calculated of every date.  
---|---  
  
3.| With a Date-String. The date-string must be in the Format specified in the Config Date Statement.  
---|---  
  
4.| With a System Day Number (WORD)  
---|---  
  
5.| With a System Second Number (LONG)  
---|---  
  
The Return-Value is in the Range of 0 to 364 (365 in a leap year). January the first starts with 0.

The function is valid in the 21th century (from 2000-01-01 to 2099-12-31).

See also

[Date and Time Routines](datetime.md) , [SysSec](syssec.md) , [SysDay](sysday.md)

Example

See [DayOfWeek](dayofweek.md)

---

## DBG

Action

Prints debug info to the hardware UART

Syntax

DBG

Remarks

See [$DBG](_dbg.md) for more information

---

## DCF77TIMEZONE

Action

This function will return the offset to Greenwich Time.

Syntax

res = DCF77TimeZone()

Remarks

Res | The target variable that is assigned with the result. The result will be: \- 0: when there is no valid DCF77 data yet \- 1: when in "Middle Europe Normal Time" \- 2: when in "Middle Europe daylight saving Time"  
---|---  
  
In Middle Europe, daylight saving is used to make better use of the day light in the summer.

The last Sunday in March at 02:00 AM the Daylight Saving will start. All clocks are set from 2:00 to 3:00.

Your weekend, is one hour shorter then.

But the last Sunday of October is better : at 03:00 AM, the Daylight Saving will end and all clocks are set from 03:00 to 02:00.

When you have a lot of clocks in your house, you can understand why DCF77 synchronized clocks are so popular.

See also

[CONFIG DCF77](configdcf77.md)

Example

Print = DCF77TimeZone()

---

## DEBOUNCE

Action  
  
Debounce a port pin connected to a switch.

Syntax

DEBOUNCE Px.y , state , label [ , SUB]

Remarks

Px.y | A port pin like PINB.0 , to examine.  
---|---  
State | 0 for jumping when PINx.y is low , 1 for jumping when PINx.y is high  
Label | The label to GOTO when the specified state is detected  
SUB | The label to GOSUB when the specified state is detected  
  
When you specify the optional parameter SUB, a GOSUB to label is performed instead of a GOTO.

The DEBOUNCE statement tests the condition of the specified pin and if true there will be a delay for 25 mS and the condition will be checked again. (eliminating bounce of a switch)

When the condition is still true and there was no branch before, it branches to specified the label.

When the condition is not true, or the logic level on the pin is not of the specified level, the code on the next line will be executed.

When DEBOUNCE is executed again, the state of the switch must have gone back in the original position before it can perform another branch. So if you are waiting for a pin to go low, and the pin goes low, the pin must change to high, before a new low level will result in another branch.

Each DEBOUNCE statement, which uses a different port, uses 1 BIT of the internal memory to hold its state. And as the bits are stored in SRAM, it means that even while you use only 1 pin/bit, a byte is used for storage of the bit.

DEBOUNCE will not wait for the input value to met the specified condition. You need to use BITWAIT if you want to wait until a bit will have a certain value.

So DEBOUNCE will not halt your program while a BITWAIT can halt your program if the bit will never have the specified value. You can combine BITWAIT and DEBOUNCE statements by preceding a DEBOUNCE with a BITWAIT statement.

See also

[CONFIG DEBOUNCE](config_debounce.md) , [BITWAIT](bitwait.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : deboun.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates DEBOUNCE

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Debounce = 30 'when the config statement is not used a default of 25mS will be used but we override to use 30 mS

'Debounce Pind.0 , 1 , Pr 'try this for branching when high(1)

```
Debounce Pind.0 , 0 , Pr , Sub

Debounce Pind.0 , 0 , Pr , Sub

```vb
' ^----- label to branch to

' ^---------- Branch when PIND.0 goes low(0)

' ^---------------- Examine PIND.0

'When Pind.0 goes low jump to subroutine Pr

'Pind.0 must go high again before it jumps again

'to the label Pr when Pind.0 is low

```
Debounce Pind.0 , 1 , Pr 'no branch

Debounce Pind.0 , 1 , Pr 'will result in a return without gosub

End

Pr:

```vb
Print "PIND.0 was/is low"

Return

```

---

## DEBUG

Action

Instruct compiler to start or stop debugging, or print variable to serial port

Syntax

DEBUG ON | OFF | var

Remarks

ON | Enable debugging  
---|---  
OFF | Disable debugging  
var | A variable which values must be printed to the serial port  
  
During development of your program a common issue is that you need to know the value of a variable.

You can use PRINT to print the value but then it will be in the application as well.

You can use conditional compilation such as :

CONST TEST=1

```vb
#IF TEST

print var

#ENDIF

```
But that will result in a lot of typing work. The DEBUG option is a combination of conditional compilation and PRINT. Whenever you activate DEBUG with the ON parameter, all 'DEBUG var' statements will be compiled.

When you turn DEBUG OFF, all 'DEBUG var' statements will not be compiled.

You can not nest the ON and OFF. The last statements wins.

Typical you will have only one DEBUG ON statement. And you set it to OFF when your program is working.

An example showing nesting is NOT supported:

DEBUG ON

DEBUG ON ' it is still ON

DEBUG OFF' it is OFF now

An example showing multiple DEBUG:

DEBUG ON

DEBUG var ' this is printed

DEBUG var2 ' this is also printed

DEBUG OFF

DEBUG var3 'this is NOT printed

DEBUG var4 ' this is not printed

DEBUG ON ' turn DEBUG ON

If A = 2 Then

DEBUG A ' this is printed when A is 2

End If

![notice](notice.jpg)When DEBUG ON is used, the UART is initialized. This means that TX and RX pins are set to UART mode where they can not be altered by the user with simple SET/RESET statements. 

See also

DBG

ASM

NONE

Example

DEBUG ON

Dim A As Byte

DEBUG A

End

---

## DECLARE FUNCTION

Action

Declares a user function.

Syntax

DECLARE FUNCTION TEST[( [BYREF/BYVAL] prm as type)] As type

Remarks

test | Name of the function.  
---|---  
prm | Name of the optional parameters.  
Type | Type of the parameter(s) and of the result. Byte,Word, Dword, Integer, Long, Single, Double or String. Bits are not supported. When passing a string it is recommended to also pass the maximum length of the string : SomeString As String * 30 would indicate that the string will have a maximum length of 30 characters. Please notice that you need to specify the string length in both the DECLARE and the actual implementation. Unless you use CONFIG SUBMODE=NEW in which case you only write the implementation.  
  
When BYREF or BYVAL is not specified, the parameter will be passed by reference.

Use BYREF to pass a variable by reference with its address. This means that you work on the string you pass. Any change you make in the sub/function you will make on the original string.

Use BYVAL to pass a copy of the variable. This means that a copy is created and the address of this copy is passed to the sub/function. If you change the string, the original sting remains the same.

Use BYLABEL to pass the address of a label. 

See the [CALL](call.md) and [DECLARE SUB](declare_sub.md) statements for more details. 

See also [Memory usage](memory_usage.md)

![notice](notice.jpg)SUB and FUNCTION are the same with 1 difference : a function returns a result which can be assigned to a variable. 

ARRAYS

Arrays can be passed by reference only. You need to add empty parenthesis() after the variable to indicate that you pass an array. 

Inside the sub/function you also need to use () when accessing the variable.

Let's have a look at an example which calls a SUB. Functions and Subs are similar with the difference that a functions returns a result.

```vb
Declare Sub TestArray(ar() as byte, b as byte)

Dim a(10) as byte , q as byte

```
TestArray a(1) , q

As you can see, we add () after the variable to indicate that it is an array we pass.

When we call the sub program, we pass the first address or the base address of the array. That is a(1) in this case. See also [CONFIG BASE.](config_base.md)

Inside the sub module, we also refer to the variable using ().

```vb
Sub TestArray(ar() as byte, b as byte)

print ar(1)

print ar(b)

End Sub

```
In older BASCOM versions, it was not required to use (). You only needed to pass the base address. But that is potential unsafe : if you reference a variable as an array while it is actually a single variable, then you can write to the wrong address. When using (), the compiler knows when an array is expected and can inform you about a possible error. 

If you have old code you can use CONFIG ERROR=IGNORE,380=IGNORE to ignore errors as a result of the updated syntax.

![notice](notice.jpg) You must declare each function before writing the function or calling the function. And the declaration must match the function.

Bits are global and can not be passed to functions or subs.

When you want to pass a string, you pass it with it's data type : string. So the size is not important. For example :

Declare function Test(s as string, byval z as string) as byte

You may and should specify the optional maximum length. In fact it is highly recommended that you do so.

![notice](notice.jpg)When you set the function result, you need to take care that no other code is executed after this. 

So a good way to set the result would be this :

Function Myfunc(b as byte) as Byte

local bDummy as byte

'some code here

Myfunc=3 ' assign result

```vb
' no other code is executed

End Function 

```
Also good would be:

Function Myfunc(b as byte) as Byte

local bDummy as byte

'some code here

Myfunc=1 ' assign default result

Print "this is a test " ; b

Myfunc=4 ' now again the result is the last code

```vb
' no other code is executed

End Function 

If you execute other code after you assigned the function result, registers will be trashed. This is no problem if you assigned the function result to a variable. But when you use a function without assigning it to a variable, some temporarily registers are used which might be trashed.

```
Thus this special attention is only needed when you use the function like :

If Myfunc()=3 then 'myfunc is not assigned to a variable but the result is needed for the test

When you use :

myvar=Myfunc() 

Then you will not trash the registers. So in such a case there is no problem to run code after the function assignment.

To keep it safe, assign the result just before you exit the function.

![notice](notice.jpg)IMPORTANT

In order to prevent memory overwrites there are some things you need to be aware of. 

All data types have a fixed length. A byte takes 1 byte, a word takes 2 bytes, etc. 

Strings have a variable length. When you dimension the string you specify the maximum amount of memory that will be used by the string.

DIM S as string * 10 means that 10 bytes + 1 trailer byte, will be reserved in RAM for string named S.

When you assign this string with a constant the compiler will check if the assigned string is dimensioned large enough to hold the string constant. You will get an error if it does not fit.

But when you assign a string with a function or other string, or perform a string concatenation (+ string) there is no such check. This means that you can overwrite the memory that is placed behind the string.

Consider the following examples. 

Example 1, this will give an error since the constant will not fit.

```vb
$RegFile = "m88def.dat"  
$Crystal = 8000000  
$hwstack = 50  
$swstack = 40  
$framesize = 100  
  
dim s as string *10  
```
s="0123456789A"   
End

Example 2, this will be ok since the string is large enough.

```vb
$RegFile = "m88def.dat"  
$Crystal = 8000000  
$hwstack = 50  
$swstack = 40  
$framesize = 100  
  
dim s as string *10  
```
s="0123456789"  
End

![notice](notice.jpg)

Example 3, this will give no error but will overwrite memory since data is added to the string which is not large enough

```vb
$RegFile = "m88def.dat"  
$Crystal = 8000000  
$hwstack = 50  
$swstack = 40  
$framesize = 100  
  
dim s as string *10  
```
s="0123456789"  
s=s+"abc"  
End

![notice](notice.jpg)

Example 4, this is the same as sample 3 but will demonstrate that variable B will be overwritten

```vb
$RegFile = "m88def.dat"  
$Crystal = 8000000  
$hwstack = 50  
$swstack = 40  
$framesize = 100  
  
dim s as string *10 ,b as byte  
```
b=123  
s="0123456789"  
s=s+"abc"  
```vb
print b  
  
End

```
Example 5, this is when you reserve 100 bytes for the frame/temp space, but you pass data which would take more than that. You get an error in that case.

```vb
$regfile = "m128def.dat"  
$crystal = 8000000  
$hwstack = 50  
$swstack = 40  
$framesize = 100 'notice that it is 100  
  
Declare Sub test(ByVal S As String * 160)  
' ^^^^ will not fit  
```
Call test("012")  
  
Sub test(ByVal S As String * 160)  
Local vs As String * 3  
vs = "AAA"  
End Sub

In example 6 we pass a constant but we specified a maximum length, and we will get error 119 : constant too big to fit

```vb
$regfile = "m128def.dat"  
$crystal = 8000000  
$hwstack = 50  
$swstack = 40  
$framesize = 100   
  
Declare Sub test(ByVal S As String * 10)  
  
```
Call test("0123456789a") 'notice that the size is 11 so we get an error  
  
Sub test(ByVal S As String * 10)  
Local vs As String * 3  
vs = "AAA"  
End Sub

In example 7 we use $FRAMECHECK to see if the data will fit. We call the same sub (recursive) and we never exit which mean the memory is never released. So after a few calls we run out of space and ERR becomes 1

```vb
$regfile = "m128def.dat"  
$crystal = 8000000  
$hwstack = 50  
$swstack = 40  
$framesize = 100  
$FrameCheck  
  
Declare Sub test(ByVal S As String * 10)  
  
```
Call test("0123456789")  
  
Sub test(ByVal S As String * 10)  
Local vs As String * 3  
```vb
print err 'will be 1 when there is not enough frame space  
'you will see that ERR will be 0 but becomes 1 when there is not enough space  
```
vs = "AAA"  
test "abc" 'call ourselves which is not smart but will demo the check  
End Sub

![notice](notice.jpg)

In example 8 we see how unsafe it can be when you do not specify the length of the string

```vb
$regfile = "m128def.dat"  
$crystal = 8000000  
$hwstack = 50  
$swstack = 40  
$framesize = 100  
$FrameCheck  
  
Declare Sub test(ByVal S As String)  
  
```
Call test("0123")  
  
Sub test(ByVal S As String)  
Local vs As String * 3  
```vb
print err 'will be 1 when there is not enough frame space  
'you will see that ERR will be 0 but becomes 1 when there is not enough space  
```
vs = "AAA"  
S = "012345" '<\--- This overwrites local vs  
```vb
print err'there was enough space so we get 0, still there is an overwrite  
End Sub

```
See also

[CALL](call.md), [SUB](sub.md) , [CONFIG SUBMODE](config_submode.md) , [EXIT](exit.md) , [$FRAMECHECK](hwcheck.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : function.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstration of user function

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'A user function must be declare before it can be used.

'A function must return a type

Declare Function Myfunction(byval I As Integer , S As String) As Integer

'The byval paramter will pass the parameter by value so the original value

'will not be changed by the function

Dim K As Integer

Dim Z As String * 10

Dim T As Integer

'assign the values

```
K = 5

Z = "123"

T = Myfunction(k , Z)

```vb
Print T

End

Function Myfunction(byval I As Integer , S As String) As Integer

'you can use local variables in subs and functions

```
Local P As Integer

P = I

```vb
'because I is passed by value, altering will not change the original

'variable named k

```
I = 10

P = Val(s) + I

```vb
'finally assign result

'Note that the same data type must be used !

'So when declared as an Integer function, the result can only be

'assigned with an Integer in this case.

```
Myfunction = P

End Function

---

## DECLARE SUB

Action

Declares a subroutine.

Syntax

DECLARE SUB TEST[( [BYREF|BYVAL|BYLABEL|BYREG|BYSTACK] var as type)]

Remarks

test | Name of the procedure.  
---|---  
Var | Name of the parameter(s).  
Type | Type of the parameter(s) :  Byte, Word, Dword, Integer, Long, Single, Double or String.  When passing a string it is recommended to also pass the maximum length of the string : SomeString As String * 30 would indicate that the string will have a maximum length of 30 characters. Please notice that you need to specify the string length in both the DECLARE and the actual implementation. Unless you use CONFIG SUBMODE=NEW in which case you only write the implementation.  
  
ARRAYS

Arrays can be passed by reference only. You need to add empty parenthesis() after the variable to indicate that you pass an array. 

Inside the sub/function you also need to use () when accessing the variable.

Let's have a look at an example.

```vb
Declare Sub TestArray(ar() as byte, b as byte)

Dim a(10) as byte , q as byte

```
TestArray a() , q

As you can see, we add () after the variable to indicate that it is an array we pass.

When we call the sub program, we pass the first address or the base address of the array. That is a(1) in this case.

Inside the sub module, we also refer to the variable using ().

```vb
Sub TestArray(ar() as byte, b as byte)

print ar(1)

print ar(b)

End Sub

```
In older BASCOM versions, it was not required to use (). You only needed to pass the base address. But that is potential unsafe : if you reference a variable as an array while it is actually a single variable, then you can write to the wrong address. When using (), the compiler knows when an array is expected and can inform you about a possible error. 

If you have old code you can use CONFIG ERROR=IGNORE,380=IGNORE to ignore errors as a result of the updated syntax.

Parameter Passing

When BYREF | BYVAL | BYREG | BYLABEL or BYSTACK is not provided, the parameter will be passed by reference (BYREF).

BYREF

Use BYREF to pass a variable by reference with its address. When using the referenced address, you work on the original variable. So a change of the variable inside the sub routine, will change the passed variable outside the routine as well.

BYVAL

Use BYVAL to pass a copy of the variable. Passing a copy of the variable allows to alter the copy in the sub routine while leaving the original variable unaltered. BYVAL will not change the original passed variable but it requires more code since a copy of the parameter must be created.

BYREG

Use BYREG to pass a copy of the variable using a register. The value will be passed to the register(s) you specify. When multiple bytes need to be passed, multiple registers will be used. Registers are named from R0-R31. When you pass a WORD to register R16, you will also use R17 since a word requires 2 bytes.

You can not pass strings. Only numeric variables and constants.

Using BYREG requires some knowledge of the routines you call. The current implementation does not protect already loaded registers. This means that when you pass multiple registers you could destroy some already loaded registers just because a parameter will destroy the register.

Example : declare Sub MySub(byreg R16 as Word, byreg R18 as long, byreg R22 as dword)

mysub 1000, var(J+100), var(j)

In this example, R16 and R17 are loaded, after this the array index of variable var() need to be calculated which uses the ML16 routine which uses R16-R21

Numeric constants and expression do not alter registers but functions might. A future version will track and protect registers.

Why would you want to use BYREG ? Using BYREG is equivalent to using ASM. It is intended to be used with ASM code inside subs. The FT800 include files use BYREG and BYSTACK. 

Example from FT800:

Sub Stencilfunc(byreg r18 As Byte , Byreg r17 As Byte , Byreg R16 As Byte)

Cmd32 _stencilfunc(r18 , R17 , r16)

End Sub 

BYSTACK

Use BYSTACK to pass a copy of the variable by the soft stack (Y-pointer). BYSTACK will not create a copy of the variable but instead will pass the data directly to the soft stack. 

The first parameter is passed first , LSB first. You will find BYSTACK used in the FT800 include files. BYSTACK has the advantage compared to BYREG that no registers are altered. But it has the disadvantage that it requires an optional step to pass the data to the stack. 

The SUB/FUNCTION need to clean up the stack. Typically you would use LD reg, y+ to pop data from the stack. 

The FT800 uses [CMDFTSTACK](cmdftstack.md) to pop data from the stack and send it to the FT800. 

BYLABEL

Use BYLABEL to pass the address of a label. BYLABEL will pass the word address. It will not work for processors with multiple 64 KB pages.

Using BYLABEL on the EEPROM is possible but the EEPROM image must proceed the call with the label name.

See also [READEEPROM](readeeprom.md), [LOADLABEL](loadlabel.md) and [Memory usage ](memory_usage.md)

```vb
If you pass a string you may specify the length of the string. This length will be the maximum length the string may grow. This is important when you pass a string BYVAL. 

For example, when you pass a string like "ABC" to a subroutine or function using BYVAL, the compiler will create a copy with a length of 3. This is sufficient to pass it to the sub routine.

```
But if the sub routine adds data to the string, it will not fit since the string is too short. In such a case you can specify the length. s as string * 10, will create a string with a size of 10.

See the [CALL](call.md) statement for more details.

![notice](notice.jpg) You must declare each function before writing the function or calling the function. And the declaration must match the function. Optional you can use [CONFIG SUBMODE](config_submode.md)=NEW so DECLARE is not required.

Bits are global and can not be passed to functions or subs.

![notice](notice.jpg) See [DECLARE FUNCTION](debug.md) paragraph named IMPORTANT

See also

[CALL](call.md), [SUB](sub.md) , [FUNCTION](declare_function.md) , [CONFIG SUBMODE](config_submode.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : declare.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrate using declare

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

' Note that the usage of SUBS works different in BASCOM-8051

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

' First the SUB programs must be declared

'Try a SUB without parameters

Declare Sub Test2()

'SUB with variable that can not be changed(A) and

'a variable that can be changed(B1), by the sub program

'When BYVAL is specified, the value is passed to the subprogram

'When BYREF is specified or nothing is specified, the address is passed to

'the subprogram

Declare Sub Test(byval A As Byte , B1 As Byte)

Declare Sub Testarray(byval A As Byte , B1 As Byte)

'All variable types that can be passed

'Notice that BIT variables can not be passed.

'BIT variables are GLOBAL to the application

Declare Sub Testvar(b As Byte , I As Integer , W As Word , L As Long , S As String)

'passing string arrays needs a different syntax because the length of the strings must be passed by the compiler

'the empty () indicated that an array will be passed

Declare Sub Teststr(b As Byte , Dl() As String)

Dim Bb As Byte , I As Integer , W As Word , L As Long , S As String * 10 'dim used variables

Dim Ar(10) As Byte

Dim Sar(10) As String * 8 'strng array

For Bb = 1 To 10

```
Sar(bb) = Str(bb) 'fill the array

Next

Bb = 1

'now call the sub and notice that we always must pass the first address with index 1

Call Teststr(bb , Sar(1))

Call Test2 'call sub

Test2 'or use without CALL

'Note that when calling a sub without the statement CALL, the enclosing parentheses must be left out

Bb = 1

Call Test(1 , Bb) 'call sub with parameters

```vb
Print Bb 'print value that is changed

'now test all the variable types

```
Call Testvar(bb , I , W , L , S )

```vb
Print Bb ; I ; W ; L ; S

'now pass an array

'note that it must be passed by reference

```
Testarray 2 , Ar(1)

```vb
Print "ar(1) = " ; Ar(1)

Print "ar(3) = " ; Ar(3)

$notypecheck ' turn off type checking

```
Testvar Bb , I , I , I , S

```vb
'you can turn off type checking when you want to pass a block of memory

$typecheck 'turn it back on

End

'End your code with the subprograms

'Note that the same variables and names must be used as the declared ones

Sub Test(byval A As Byte , B1 As Byte) 'start sub

Print A ; " " ; B1 'print passed variables

```
B1 = 3 'change value

```vb
'You can change A, but since a copy is passed to the SUB,

'the change will not reflect to the calling variable

End Sub

Sub Test2 'sub without parameters

Print "No parameters"

End Sub

Sub Testvar(b As Byte , I As Integer , W As Word , L As Long , S As String)

```
Local X As Byte

X = 5 'assign local

B = X

I = -1

W = 40000

L = 20000

S = "test"

```vb
End Sub

Sub Testarray(byval A As Byte , B1 As Byte) 'start sub

Print A ; " " ; B1 'print passed variables

```
B1 = 3 'change value of element with index 1

B1(1) = 3 'specify the index which does the same as the line above

B1(3) = 3 'modify other element of array

```vb
'You can change A, but since a copy is passed to the SUB,

'the change will not reflect to the calling variable

End Sub

'notice the empty() to indicate that a string array is passed

Sub Teststr(b As Byte , Dl() As String)

```
Dl(b) = Dl(b) + "add"

End Sub

Example BYLABEL

```vb
$regfile = "m88def.dat"  
$hwstack = 40  
$swstack = 80  
$framesize = 80  
  
Dim B As Byte , W As Word  
  
Declare Sub Somesub(bylabel Mylabel As Word)  
```
Somesub Alabel  
```vb
End  
  
  
Sub Somesub(bylabel Mylabel As Word)  
```
W = Mylabel ' this points to the BYTE address of the data  
!lds _dptrl,{W } ' point to  
!LDS _dptrh,{W+1}  
Read B : Print B  
End Sub  
  
Alabel:  
Data 1 , 2 , 3

---

## DECR

Action

Decrements a variable by one.

Syntax

DECR var

Remarks

There are often situations where you want a number to be decreased by 1. It is simpler to write :

DECR var

compared to :

var = var - 1

See also

[INCR](incr.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : decr.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demostrate decr

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte , I As Integer

```
A = 5 'assign value to a

Decr A 'decrease (by one)

Print A 'print it

I = 1000

Decr I

```vb
Print I

End

```

---

## DEFxxx

Action  
  
Declares all variables that are not dimensioned of the DefXXX type.

Syntax

DEFBIT b | Define BIT  
---|---  
DEFBYTE c | Define BYTE  
DEFINT I | Define INTEGER  
DEFWORD x | Define WORD  
DEFLNG l | Define LONG  
DEFSNG s | Define SINGLE  
DEFDBL z | Define DOUBLE  
  
Remarks

While you can DIM each individual variable you use, you can also let the compiler handle it for you.

All variables that start with a certain letter will then be dimmed as the specified type.

Example

Defbit b : DefInt c ' default type for bit and integers

Set b1 ' set bit to 1

c = 10 ' let c = 10

---

## DEG2RAD

Action

Converts an angle in to radians.

Syntax

var = DEG2RAD( angle )

Remarks

Var | A numeric variable that is assigned with the radians of variable Source.  
---|---  
angle | The single or double variable to get the degrees of.  
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

Radian is the ratio between the length of an arc and its radius. The radian is the standard unit of angular measure.

You can find a good explanation at [wikipedia](<http://en.wikipedia.org/wiki/Radian>).

See Also

[RAD2DEG](rad2deg.md)

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates DEG2RAD function

'-------------------------------------------------------------------------------

Dim S As Single

```
S = 90

S = Deg2Rad(s)

Print S

S = Rad2deg(s)

```vb
Print S

End

```

---

## DELAY

Action

Delay program execution for a short time.

Syntax

DELAY

Remarks

Use DELAY to wait for a short time.

The delay time is ca. 1000 microseconds.

![notice](notice.jpg)Interrupts that occur frequently and/or take a long time to process, will let the delay last longer.

When you need a very accurate delay, you need to use a timer.

See also

[WAIT](wait.md) , [WAITMS](waitms.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : delay.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: DELAY, WAIT, WAITMS

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

```
Ddrb = &HFF 'port B as output

Portb = 255

Print "Starting"

Delay 'lets wait for a very short time

Print "Now wait for 3 seconds"

Portb = 0

```vb
Wait 3

Print "Ready"

Waitms 10 'wait 10 milliseconds

```
Portb = 255

End

---

## DELCHAR

Action

Delete one character from a string.

Syntax

DELCHAR string, pos

Remarks

string | The string where the character is removed from.  
---|---  
pos | The position where the character must be removed from. A value of 1 would remove the first character.  
  
Do not confuse with the DELCHARS statement which removes all characters based on a character value.

The DELCHAR removes one character from a string based on an index. 

DELCHAR supports [$BIGSTRINGS](bigstrings.md)

See also

[DELCHARS](delchars.md) , [INSERTCHAR](insertchar.md) , [INSTR](instr.md) , [MID](mid.md) , [CHARPOS](charpos.md) , [REPLACECHARS](replacechars.md)

Example

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' del_insert_chars.bas  
' This sample demonstrates the delchar, delchars and insertchar statements  
'-----------------------------------------------------------------  
$regfile="m88def.dat"  
$crystal = 8000000  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
dim s as string * 30  
```
s = "This is a test string" ' create a string  
delchar s, 1 ' remove the first char  
print s ' print it  
  
insertchar s,1, "t" ' put a small t back  
print s  
  
delchars s,"s" ' remove all s  
```vb
print s  
end

```

---

## DELCHARS

Action

Delete all character from a string matching the provided character value.

Syntax

DELCHARS string, value

Remarks

string | The string where the characters are removed from.  
---|---  
value | The value of the character which must be removed from the string. You can use "A" to remove all capital A characters. Or you can pass a byte with the value of 65 to remove all characters with ASCII value 65 (A)  
  
Do not confuse with the DELCHAR statement which removes one character based on an index value.

DELCHARS removes ALL characters from a string matching value. 

DELCHARS also works with [$BIGSTRINGS](bigstrings.md)

See also

[DELCHAR](delchar.md) , [INSERTCHAR](insertchar.md) , [INSTR](instr.md) , [MID](mid.md) , [CHARPOS](charpos.md) , [REPLACECHARS](replacechars.md)

Example

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' del_insert_chars.bas  
' This sample demonstrates the delchar, delchars and insertchar statements  
'-----------------------------------------------------------------  
$regfile="m88def.dat"  
$crystal = 8000000  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
dim s as string * 30  
```
s = "This is a test string" ' create a string  
delchar s, 1 ' remove the first char  
print s ' print it  
  
insertchar s,1, "t" ' put a small t back  
print s  
  
delchars s,"s" ' remove all s  
```vb
print s  
end

```

---

## Demos

There are around 67 various demos which have been ported from various sources (please respect some of the credits notes in some of

the sample demos). These have been tested and work, but some may not be optimized for the 3.5" display.

If you want to see more fantastic demo's click here [YouTube demos](<https://www.youtube.com/watch?v=3trUUc-tFKY&feature=youtu.be>)

Since the all original samples where from C/C++ sources, you may notice some demos could be further be improved or optimized or think why was is done that way. Some samples have been modified and have been enhanced and improved using Bascom's rich commands, others have been left as is. 

Also look in the Demo folder for the Snapshots folder which has all the Screen captures of the demo's.

Note: Some demos require an microSD/SDHC card to store the various pictures and fonts etc.

Here are the list of demo names:

Filename | Routine  
---|---  
Demo0 | Points ![Points](points.png)  
| Line_s ![Line_s](line_s.png)  
| Rectangles ![Rectangles](rectangles.png)  
| Bitmap ![Bitmap](bitmap.png)  
| BitmapPalette ![BitmapPalette](bitmappalette.png)  
| Fonts ![Fonts](fonts.png)  
| Text_8x8 ![Text_8x8](text_8x8.png)  
| Text_VGA ![Text_VGA](text_vga.png)  
| Bar_graph ![Bar_graph](bar_graph.png) ![Bar_Graph1](bar_graph1.png) ![Bar_Graph2](bar_graph2.png)  
| LineStrips ![LineStrips](linestrips.png)  
| EdgeStrips ![EdgeStrips](edgestrips.png)  
| Scissor ![Scissor](scissor.png)  
| Polygon ![Polygon](polygon.png)  
| Cube ![Cube](cube.png)  
| Ball_Stencil ![ball_stencil](ball_stencil.png)  
| FtdiString ![FtdiString](ftdistring.png)  
| StreetMap ![StreetMap](streetmap.png)  
| AdditiveBlendText ![AdditiveBlendText](additiveblendtext.png)  
| MacroUsage ![MacroUsage](macrousage.png)  
| AdditiveBlendPoints ![AdditiveBlendPoints](additiveblendpoints.png)  
Demo1 | Logo ![Logo](logo.png)  
| Calibrate1 ![Calibrate1](calibrate1.png)  
| Calibrate2 ![Calibrate2](calibrate2.png)  
| Touch ![Touch](touch.png)  
| Widget_Clock ![Widget_Clock](widget_clock.png)  
| Widget_Gauge ![Widget_Gauge](widget_gauge.png)  
| Widget_Gradient ![Widget_Gradient](widget_gradient.png)  
| Widget_Keys ![Widget_Keys](widget_keys.png)  
| Widget_Keys_Interactive ![Widget_Keys_Interactive](widget_keys_interactive.png)  
| Widget_Progressbar ![Widget_Progressbar](widget_progressbar.png)  
| Widget_Scroll ![Widget_Scroll](widget_scroll.png)  
| Widget_Slider ![Widget_Slider](widget_slider.png)  
| Widget_Dial ![Widget_Dial](widget_dial.png)  
| Widget_Toggle ![Widget_Toggle](widget_toggle.png)  
| Widget_Spinner ![Widget_Spinner1](widget_spinner1.png) ![Widget_Spinner2](widget_spinner2.png) ![Widget_Spinner3](widget_spinner3.png) ![Widget_Spinner4](widget_spinner4.png)  
| PowerMode ![PowerMode](powermode.png)  
Demo2 | Inflate ![Inflate](inflate.png)  
| Loadimage ![LoadImage](loadimage.png) ![Loadimage1](loadimage1.png) ![Loadimage2](loadimage2.png)  
Demo3 | Set_font ![Set_font](set_font.png)  
| Set_font2 ![Set_font2](set_font2.png)  
| ChineseFont  ![ChineseFont](chinesefont.png)  
Demo4 | Widget_Text ![Widget_Text](widget_text.png)  
| Widget_Number ![Widget_Number](widget_number.png)  
| Widget_Button  ![Widget_Button](widget_button.png)  
| Append_Cmds  ![Append_Cmds](append_cmds.png)  
| Sounds ![Sounds](sounds.png)  
| Screensaver ![Screensaver](screensaver.png)  
| Snapshot ![Snapshot](snapshot.png)  
| Sketch  ![Sketch1](sketch1.png) ![Sketch2](sketch2.png)  
| Matrix  ![Matrix](matrix.png)  
| Track  ![Track](track.png)  
DigitTest | Digit ![digits](digits.png)  
FT800 Capture | ScreenShot2  
FT800 Demo_Fizz | Fizz ![Fizz](fizz.png)  
FT800 Gauges | Gauges ![Gauges](gauges.png)  
FT800 ImageViewer | Imageviewer ![Imageviewer](imageviewer.png) ![Imageviewer2](imageviewer2.png) ![Imageviewer3](imageviewer3.png) ![Imageviewer4](imageviewer4.png)  
FT800 Keyboard | Notepad ![notepad](notepad.png)  
FT800 Loadimage | LoadImage ![LoadImage](loadimage.png) ![Loadimage1](loadimage1.png) ![Loadimage2](loadimage2.png)  
FT800 Mandelbrot1  | ![Mandelbrot1](mandelbrot1.png)  
FT800 Mandelbrot2 | ![Mandelbrot2](mandelbrot2.png)  
Ft800 Player | Player ![Player](player.png)  
FT800 Signals | Signals  ![Signals](signals.png)  
FT800 Sketch | ![FT800 Sketch](ft800 sketch.png)  
FT800 Sprites | ![Sprites](sprites.png)  
Line_Circle_Box | ![LinesCircleBox1](linescirclebox1.png) ![LinesCircleBox2](linescirclebox2.png) ![LinesCircleBox3](linescirclebox3.png)  
Plot | ![plot](plot.png)  
Test Clock  | ![Test Clock](test clock.png)  
FT800 RadioButton | ![radiobutton](radiobutton.png)  
Test Clock 2 | ![test clock2](test clock2.png)  
FT800 Blobs | ![ft800_blobs](ft800_blobs.png) ![ft800_blobs1](ft800_blobs1.png)  
FT800 Walk | ![ft800_walk](ft800_walk.png)  
FT801 Circles.bas | ![ft801_circles](ft801_circles.png)  
FT801 Bars.bas | ![ft801_bars](ft801_bars.png)  
FT801 Graph - Capacitive Touch.bas | ![ft801_graph](ft801_graph.png)  
FT801 Polygon - Capacitive Touch.bas | ![ft801_poly](ft801_poly.png)  
FT801 Polygon2 - Capacitive Touch.bas | ![ft801_poly2](ft801_poly2.png)

---

## DESDECRYPT

Action

This statement of function uses the Xmega DES encryption engine to decrypt a block of data.

Syntax

targ = DESDECRYPT ( key, var , size)

Remarks

key | The name of a label that contains 16 bytes of key data. Or an array holding 16 bytes of key data.  
---|---  
var | A variable or array containing the data to be decrypted.  
size | The number of bytes to decrypt. Encryption is done with blocks of 16 bytes. So the size should be a multiple of 16. If you supply only 14 bytes this is ok too, but the result will still be 16 bytes. It is important that your array is big enough to hold the result.  Without the full 16 byte result, you can not decrypt the data.  
targ | An array of variable that will hold the result. Since the result will be at least 16 bytes long, this is only practical with arrays.   
  
This function only works for Xmega chips that have an DES encryption unit.

Normal DES encryption is used. The DES encryption is faster than the AES but also weaker. 

You can either use a label with a fixed key, or use a variable.

You should use the same key data for encryption and decryption.

See also

[$LOADER](loader.md) , [$AESKEY](_aeskey.md) , [AESENCRYPT](aesencrypt.md) , [AESDECRYPT](aesdecrypt.md) , [DESENCRYPT](desencrypt.md) , [$XTEAKEY](xteakey.md) , [XTEAENCODE](xteaencode.md), [XTEADECODE](xteadecode.md)

Example

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' xm128-DES.bas  
' This sample demonstrates the Xmega128A3 DES encryption/decryption  
' Notice that you need to encrypt blocks with at least 8 bytes  
'-----------------------------------------------------------------  
$regfile = "xm128a3def.dat"  
$crystal = 32000000 '32MHz  
$hwstack = 128  
$swstack = 128  
$framesize = 128  
  
'first enable the osc of your choice  
Config Osc = Enabled , 32mhzosc = Enabled  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1  
  
'configure used UART  
Config Com1 = 115200 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
```
Open "com1:" For Binary As #1  
  
```vb
Dim Key(8) As Byte ' room for key  
Dim Ar(34) As Byte  
Dim Arenc(34) As Byte  
Dim J As Byte  
  
Print #1 , "DES test"  
  
```
Restore Keydata  
For J = 1 To 8 ' load a key to memory  
Read Key(j)  
```vb
Next  
  
  
'load some data  
For J = 1 To 16 ' fill some data to encrypt  
```
Ar(j) = J  
```vb
Next  
  
  
Print #1 , "Encrypt function"  
```
Arenc(1) = Desencrypt(key(1) , Ar(1) , 16) 'encrypt 16 bytes  
  
  
```vb
For J = 1 To 16  
Print #1 , Ar(j) ; "-" ; Arenc(j) 'print result and original data  
Next  
  
  
Print #1 , "Decrypt function"  
```
Ar(1) = Desdecrypt(keydata , Arenc(1) , 16) 'decrypt and return in ar()  
  
```vb
For J = 1 To 16  
Print #1 , J ; ">" ; Ar(j) ; "-" ; Arenc(j) 'print index, decrypted data and encrypted data  
Next  
  
Do  
  
Loop  
  
End  
  
  
  
```
Keydata: ' key data can go into flash ROM or into sram  
Data 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8

---

## DESENCRYPT

Action

This statement of function uses the Xmega DES encryption engine to encrypt a block of data.

Syntax

targ = DESENCRYPT ( key, var , size)

Remarks

key | The name of a label that contains 16 bytes of key data. Or an array holding 16 bytes of key data.  
---|---  
var | A variable or array containing the data to be encrypted.  
size | The number of bytes to encrypt. Encryption is done with blocks of 16 bytes. So the size should be a multiple of 16. If you supply only 14 bytes this is ok too, but the result will still be 16 bytes. It is important that your array is big enough to hold the result.  Without the full 16 byte result, you can not decrypt the data.  
targ | An array of variable that will hold the result. Since the result will be at least 16 bytes long, this is only practical with arrays.   
  
This function only works for Xmega chips that have an DES encryption unit.

Normal DES encryption is used. The DES encryption is faster than the AES but also weaker. 

You can either use a label with a fixed key, or use a variable.

You should use the same key data for encryption and decryption.

See also

[$LOADER](loader.md) , [$AESKEY](_aeskey.md) , [AESENCRYPT](aesencrypt.md) , [AESDECRYPT](aesdecrypt.md) , [DESDECRYPT](desdecrypt.md) , [$XTEAKEY](xteakey.md) , [XTEAENCODE](xteaencode.md), [XTEADECODE](xteadecode.md)

Example

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' xm128-DES.bas  
' This sample demonstrates the Xmega128A3 DES encryption/decryption  
' Notice that you need to encrypt blocks with at least 8 bytes  
'-----------------------------------------------------------------  
$regfile = "xm128a3def.dat"  
$crystal = 32000000 '32MHz  
$hwstack = 128  
$swstack = 128  
$framesize = 128  
  
'first enable the osc of your choice  
Config Osc = Enabled , 32mhzosc = Enabled  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1  
  
'configure used UART  
Config Com1 = 115200 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
```
Open "com1:" For Binary As #1  
  
```vb
Dim Key(8) As Byte ' room for key  
Dim Ar(34) As Byte  
Dim Arenc(34) As Byte  
Dim J As Byte  
  
Print #1 , "DES test"  
  
```
Restore Keydata  
For J = 1 To 8 ' load a key to memory  
Read Key(j)  
```vb
Next  
  
  
'load some data  
For J = 1 To 16 ' fill some data to encrypt  
```
Ar(j) = J  
```vb
Next  
  
  
Print #1 , "Encrypt function"  
```
Arenc(1) = Desencrypt(key(1) , Ar(1) , 16) 'encrypt 16 bytes  
  
  
```vb
For J = 1 To 16  
Print #1 , Ar(j) ; "-" ; Arenc(j) 'print result and original data  
Next  
  
  
Print #1 , "Decrypt function"  
```
Ar(1) = Desdecrypt(keydata , Arenc(1) , 16) 'decrypt and return in ar()  
  
```vb
For J = 1 To 16  
Print #1 , J ; ">" ; Ar(j) ; "-" ; Arenc(j) 'print index, decrypted data and encrypted data  
Next  
  
Do  
  
Loop  
  
End  
  
  
  
```
Keydata: ' key data can go into flash ROM or into sram  
Data 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8

---

## DIM

Action

Dimension a variable.

Syntax

DIM var[,varn] AS [XRAM/SRAM/ERAM]type [AT location/variable] [OVERLAY] [SAFE]

Remarks

Var | Any valid variable name such as b1, i or longname. var may also be an array : ar(10) for example. You can also use a list and created a number of variables of the same data type : DIM A1,A2, BVAR AS BYTE. This will create 3 BYTE variables. When using a list, you may not use identifiers such as #%!&. You may also not use the optional OVERLAY.  It is also possible to define the data type by ending the variable name with an identifier : % for Integer & for Long # for Double ! for Single Dim A!, b# would create a variable A! of the SINGLE data type and a variable B# with the DOUBLE data type When a variable is dimensioned with an identifier, the variable must be referenced with that identifier as well. We encourage the use of Hungarian Notation where you use a prefix instead : Dim bVar As Byte ' the b indicates a BYTE Dim iMyInt As Integer 'the i indicates an INTEGER common used prefixes : b - BYTE w - WORD dw - DWORD i - INTEGER l - LONG s - STRING dbl - DOUBLE sng - SINGLE The IDE can show the data type of the variable when you hover the mouse above the variable name and keep the SHIFT key pressed.  
---|---  
Type | Bit/Boolean, Byte, Word, Integer, Long, Dword, Single, Double, String or Type.  
XRAM | Specify XRAM to store variable into external memory  
SRAM | Specify SRAM to store variable into internal memory (default)  
ERAM | Specify ERAM to store the variable into EEPROM  
OVERLAY | Specify that the variable is overlaid in memory.  
location | The address or name of the variable when OVERLAY is used.  
SAFE | An optional specifier to indicate that access to this variable must be done in a safe way. See the full explanation below.  
  
A string variable needs an additional length parameter:

Dim s As XRAM String * 10

In this case, the string can have a maximum length of 10 characters. Internally one additional byte is needed to store the end of string marker. Thus in the example above, 11 bytes will be used to store the string.

BITS

Note that BITS can only be stored in internal memory.

You may also specify IRAM. IRAM is the place in memory where the registers are located : absolute address 0 - 31. BASCOM uses most of these addresses, depending on the instructions/options you use. For a [$TINY](_tiny.md) chip it makes sense to use IRAM since there is NO SRAM in most tiny AVR chips (TINY15 for example). You may also use to IRAM to overlay registers in memory.

See also [Memory usage](memory_usage.md)

Multiple variables on one line

You may Dimension multiple variables using one DIM statement when you separate them by a comma. There are 2 ways to do so :

Dim A As Byte, B As Byte, C As Word

The second method is even simpler :

Dim A, B, C As Byte

Here all variables are bytes. They are only separated by a comma. In the sample above, C is a word, so the equivalent would need :

Dim A, B As Byte, C As Word

Depending on which method you use, the variables might end up at a different memory location. When not using AT, you should not depend on the memory location of a variable.

Variables are usually stored in the same memory order as they are dimensioned. But you should not depend on it. Some optimization techniques requite that some variables are stored in a certain order. Use [VARPTR](varptr.md) to get the address of a variable in memory.

The Data/TIme routines require that sec,min and hour variables are in a specific order. For those you need to be explicit using AT :

Dim b as byte , m as byte at b + 1 , h as byte at m + 1

This will ensure that the bytes are placed in the specified order. 

SCOPE

The scope for DIM is global. So no matter where you use the DIM statements, the variable will end up as a global visible variable that is visible in all modules, procedures and functions.

When you need a LOCAL variable that is local to the procedure or function, you can use [LOCAL](local.md).

Since LOCAL variables are stored on the frame, it takes more code to dynamic generate and clean up these variables. This because all functions and subs are fully re-entrant. (re-entrant means they can call themselves recursively)

AT

The optional AT parameter lets you specify where in memory the variable must be stored. When the memory location already is occupied, the first free memory location will be used. You need to look in the report file to see where the variable is located in memory. In general it is a bad idea to use fixed locations. The SRAM starts at different locations in various processors. Some use &H60, &H100, or &H2000 for Xmega. When you have hard coded that a variable will start at &H60, and you port your code to an XMEGA this location is not usable. 

OVERLAY

The OVERLAY option will not use any variable space. It will create a sort of phantom variable.

```vb
Dim x as Long at &H60 'long uses 60,61,62 and 63 hex of SRAM  
  
Dim B1 As Byte At &H60 Overlay 'overlay at the same address at &H60  
Dim B2 As Byte At &H61 Overlay  


```
B1 and B2 are no real variables! They refer to a place in memory. In this case to &H60 and &H61. By assigning the phantom variable B1, you will write to memory location &H60 that is used by variable X.

So to define it better, OVERLAY does create a normal usable variable, but it will be stored at the specified memory location which could be already be occupied by another OVERLAY variable, or by a normal variable.

You can not overlay BIT/Boolean variables. These are global variables stored in bytes which can not be overlayed. You can however use an ALIAS : Mybit ALIAS SomeByte.0

![notice](notice.jpg)Take care with the OVERLAY option. Use it only when you understand it. Refer to a variable if possible, not to an absolute address.

You can also read the content of B1: 

Print B1

This will print the content of memory location &H60.

By using a phantom variable you can manipulate the individual bytes of real variables.

Overlay example 2

```vb
Dim L as Long at &H60  
Dim W as Word at &H62 OVERLAY

```
W will now point to the upper two bytes of the long.

Overlay example 3

Following you find the Bascom-AVR Simulator Memory status when you run the following example in Bascom-AVR Simulator. This example is intended to be used with the simulator. You need to uncomment the $sim when you want to test it on an real AVR.

![notice](notice.jpg)Strings need an additional byte (Null termination). So you need an overlay of 8 bytes when you overlay a string with 7 bytes.

![overlay_example_1](overlay_example_1.jpg)

  
  
```vb
$regfile = "m644pdef.dat"  
$crystal = 4000000  
$hwstack = 60  
$swstack = 60  
$framesize = 60 'frame space can grow rapid when using it on variables with a big size (strings)  
$baud = 9600  
$sim '$sim to use this example in Bascom-AVR simulator  
  
  
Print "-------------------------"  
  
Dim Array(5) As Byte  
Dim My_string As String * 4 At Array Overlay  
Dim K As Byte  
  
```
K = 1  
  
My_string = "Test"  
  
```vb
' ---> 4 ASCII but 5 Bytes because of 0 Termination of String which is another byte  
' This is how it will be stored in SRAM  
' Array(1) Array(2) Array(3) Array(4) Array(5)  
' +--------+--------+--------+--------+--------+  
' | T | e | s | t | 00 |  
' +--------+--------+--------+--------+--------+  
  
Print Chr(array(1))  
Print Chr(array(2))  
  
Print "-------------------------"  
  
Dim Teststring As String * 5  
Dim Ar(6) As Byte At Teststring Overlay  
Dim J As Byte  
```
J = &H03  
  
Ar(5) = 47  
  
Teststring = "Hello"  
  
```vb
' ---> 5 ASCII but 6 Bytes because of 0 Termination of String  
' This is how it will be stored in SRAM  
' Ar(1) Ar(2) Ar(3) Ar(4) Ar(5) Ar(6)  
' +--------+--------+--------+--------+--------+--------+  
' | H | e | l | l | o | 00 |  
' +--------+--------+--------+--------+--------+--------+  
  
For K = 1 To 5  
Print Chr(ar(k)) ;  
Next  
Print  
  
```
K = 1  
  
```vb
Print "-------------------------"  
  
Dim My_word As Word  
Dim Low_byte As Byte At My_word Overlay  
Dim High_byte As Byte At My_word + 1 Overlay  
  
```
Low_byte = &B0000_1111  
High_byte = &B1111_0000  
  
```vb
' This is how it will be stored in SRAM  
' <\-------my_word-------->  
' +-----------+----------+  
' | Low_byte |High_byte |  
' +-----------+----------+  
  
'But when you print it with print bin(Variable) you will see it as  
  
' <\-------my_word-------->  
' 11110000 00001111  
' +-----------+----------+  
' | High_byte |Low_byte |  
' +-----------+----------+  
  
Print "My_word = " ; Bin(my_word)  
  
Print "-------------------------"  
  
Dim My_long_1 As Long  
Dim Byte_1 As Byte At My_long_1 Overlay  
Dim Byte_2 As Byte At My_long_1 + 1 Overlay  
Dim Byte_3 As Byte At My_long_1 + 2 Overlay  
Dim Byte_4 As Byte At My_long_1 + 3 Overlay  
  
```
Byte_1 = 1  
Byte_2 = 2  
Byte_3 = 3  
Byte_4 = 4  
  
```vb
Print Bin(my_long_1)  
  
' This is how it will be stored in SRAM  
' <\-------my_long_1------------>  
' +-------+------+------+------+  
' | Byte_1|Byte_2|Byte_3|Byte_4|  
' +-------+------+------+------+  
  
'But when you print it with print bin(Variable) you will see it as  
  
' <\-------my_long_1------------>  
' +-------+------+------+------+  
' | Byte_4|Byte_3|Byte_2|Byte_1|  
' +-------+------+------+------+  
  
Print "-------------------------"  
  
Dim My_dword As Dword At $140 ' This places the my_long_2 variable at a fixed SRAM address starting at HEX 140  
Dim Byte__1 As Byte At $140 Overlay ' NOTICE: because this will be stored at the specified memory location  
Dim Byte__2 As Byte At $141 Overlay ' which could be already be occupied by another OVERLAY variable, or by a normal variable the  
Dim Byte__3 As Byte At $142 Overlay ' compiler generate an ERROR "Address already occupied" in this case.  
Dim Byte__4 As Byte At $143 Overlay  
  
  
```
Byte__1 = 1  
Byte__2 = 2  
Byte__3 = 3  
Byte__4 = 4  
  
```vb
'This is how it will be stored in SRAM  
' <\----------my_dword---------->  
' +-------+------+------+------+  
' | Byte_1|Byte_2|Byte_3|Byte_4|  
' +-------+------+------+------+  
  
'But when you print it with print bin(Variable) you will see it as  
' <\----------my_dword---------->  
' +-------+------+------+------+  
' | Byte_4|Byte_3|Byte_2|Byte_1|  
' +-------+------+------+------+  
  
Print "my_dword = " ; Bin(my_dword)  
  
Print "-------------------------"  
  
Dim My_dword_2 As Dword  
Dim My_word_2 As Word At My_dword_2 Overlay  
Dim My_byte3 As Byte At My_dword_2 + 2 Overlay  
Dim My_byte4 As Byte At My_dword_2 + 3 Overlay  
  
```
My_word_2 = &B11111111_00000000  
My_byte3 = &B00000011  
My_byte4 = &B10000000  
  
```vb
'This is how it will be stored in SRAM  
' <\--------------my_dword_2------------>  
' +---------+--------+--------+--------+  
' | my_word_2 |my_byte3|my_byte4|  
' +---------+--------+--------+--------+  
  
'But when you print it with print bin(Variable) you will see it as  
' <\--------------my_dword_2------------>  
' +---------+--------+--------+--------+  
' | my_byte4|my_byte3| my_word_2 |  
' +---------+--------+--------+--------+  
  
Print Bin(my_dword_2)  
  
Print "-------------------------"  
  
' Now we examine the Null terminator in Strings  
  
Dim My_date(11) As Byte ' 8 strings + 3 Null terminator = 11 Byte  
Dim Day As String * 2 At My_date(1) Overlay  
Dim Null_terminator As Byte At My_date(1) + 2 Overlay ' Null terminator  
Dim Month As String * 2 At My_date(1) + 3 Overlay  
Dim Null_terminator_2 As Byte At My_date(1) + 5 Overlay ' Null terminator  
Dim Year As String * 4 At My_date(1) + 6 Overlay  
Dim Null_terminator_3 As Byte At My_date(1) + 10 Overlay ' Null terminator  
  
```
Day = "16"  
Month = "11"  
Year = "2011"  
  
```vb
Print "Day= " ; Day  
Print "Month= " ; Month  
Print "Year= " ; Year  
  
'For example the print function use the Null Terminator to check the end of the string  
'When we set now the Null_terminator to "/" (forward slash) instead of 0 then the print function print until a Null terminator is recognised  
```
Null_terminator = 47 ' 47 = "/" (forward slash  
  
```vb
Print Day ' This will now print "16/11" because the first Null terminator will be found after the "11"  
  
  
  
End ' end program

```
Using variable name instead of address

As variables can be moved though the program during development it is not always convenient to specify an address. You can also use the name of the variable :

```vb
DIM W as WORD

Dim B as BYTE AT W OVERLAY

```
Now B is located at the same address as variable W.

For XRAM variables, you need [additional hardware ](adding_xram.md): an external RAM and address decoder chip.

ERAM

For ERAM variables, it is important to understand that these are not normal variables. ERAM variables serve as a way to simple read and write the EEPROM memory. You can use READEEPROM and WRITEEEPROM for that purpose too.

To write to an ERAM variable you have to use an SRAM variable as the source : eramVAR= sramVAR

To read from an ERAM variable you have to use an SRAM variable as the targer : sramVAR=eramVAR

Both variables need to be of the same data type. So when writing to an ERAM double, the source variable need to be of the double type too.

ERAM can be assigned with a numeric value too : eramVAR= 123

You can not use an ERAM variable as you would use a normal variable.

Also keep in mind that when you write to ERAM, you write to EEPROM, and that after 100.000 times, the EEPROM will not erase properly. 

Dim b as byte, bx as ERAM byte

B = 1

Bx = b ' write to EEPROM

B = bx ' read from EEPROM

Updateeprom

When you define a constant named Updateeprom in your code, the EEPROM will only be updated when the value differs. In order to do so, the EEPROM is read before the new value is written. This will take some extra time/code. The constant only need to be defined, the value itself is not important. Like : CONST Updateeprom=1

Xmega

The XMEGA need an additional configuration command : [CONFIG EEPROM](config_eeprom.md) = MAPPED, in order to use ERAM. Or use the QUICK option.

Arrays

An array is a sequential collection of elements with the same data type. Till version 2077, arrays could have only 1 index or dimension. But in 2078 this has been changed and while there are no technical limits for unlimited indexes, the limit has been set to 5. This means that you can create a variable array like : Dim ar(5,10,5) As Byte

This will create a BYTE variable named AR, and it has 3 indexes. Each index requires space, in this sample the amount of bytes required would be : 5 * 10 * 5 = 250 * lengthOfByte = 250 bytes.

```vb
For a WORD, which uses 2 bytes, the required space would have been 250 * 2 = 500 bytes.

While using multiple indexes might be a nice feature, it comes with a penalty : the processor need to calculate the address in memory based on the indexes. The more indexes you add, the more calculations/code is required.

```
When you use a single index, the old calculation method is used. When using multiple indexes, a new method is used which calls array calculator code in mcs.lib.

As mentioned, the maximum number of indexes is 5 so : Dim ar(5,5,5,10,10) As Byte would work. 

Multiple indexes is a new feature in 2078. The simulator does not support this option yet, so for the simulator, only 1 array exists. 

Lets see how memory is organized when using multiple indexes. For the sample we use an array of 5x3 bytes.

Dim ar(5,3) as byte. 

This gives us the following possible index values :

1,1 1,2 1,3

2,1 2,2 2,3

3,1 3,2 3,3

4,1 4,2 4,3

5,1 5,2 5,3

Since the memory of the processor is linear, we have 15 cells.

Address | Cell  
---|---  
n | 1,1  
n+1 | 1,2  
n+2 | 1,3  
n+3 | 1,4  
n+4 | 1,5  
n+5 | 2,1  
n+6 | 2,2  
n+7 | 2,3  
n+8 | 2,4  
n+9 | 2,5  
n+10 | 3,1  
n+11 | 3,2  
n+12 | 3,3  
n+13 | 3,4  
n+14 | 3,5  
  
Arrays start with element 1 by default. Thus DIM ar(5) will create 5 elements and the first element is ar(1). 

Some times it is more convenient to start with element 0. For this you can use the CONFIG BASE=0 option.

When [CONFIG BASE](config_base.md) is set to 0, and not the default 1, the first element will be 0 : DIM ar(5), will make ar(0) the first element, and ar(4) the last element.

![notice](notice.jpg)Multi DIM arrays are not supported for bootloaders with an address > 64KB. This means that for an Mega128 bootloader it will not work. The reason is that the compiler places a type/index table in the first segment for faster calculation. 

Size

The maximum size of an array depends on the available memory and the data type. The XMEGA supports up to 8 MB of external memory. BASCOM supports this but the implementation is still considered BETA. It should not be used for production. The only thing you need to do to activate the big memory is to specify the size with $XRAMSIZE.

For example : $XRAMSIZE=8000000 will tell the compiler that you use 8 MB of external memory.

Additional registers must be set to pass the 24 bit address. This will create more code. 

There is only one restriction : you can/may not pass variables located in the external memory to a sub or function.

The compiler will always pass a word address and does not support to pass the additional byte.

SAFE

The optional SAFE attribute can be used to specify that access to a variable must be done in a safe way. So when would it be unsafe?

Imagine that you DIM a BYTE and access this byte in your main code but also inside an interrupt service routine (ISR).

A typical piece of code would be for the main code :

1 - LDS r24, address of BYTE load into register R24 the value of the byte 

2 - Inc R24 increase the value of the register R24

3 - STS address, R24 write the updated value of the register back to the byte

The ISR will save the register R24. So that will not cause a problem. 

Imagine that the ISR must read the value of the byte, depending on the step in main, it will load a different value.

When interrupted at step 1, the ISR will load the same value

When interrupted at step 2, the ISR will load the increased value

When interrupted at step 3, the ISR will also load the new increased value

The case above will probably not cause much problems to your code.

Now what if the ISR will alter the value? It could write for example a zero to the byte. 

The ISR will have similar code like the main code :

1 - LDS r24, address of BYTE load into register R24 the value of the byte 

2 - CLR R24 clear the value of the register R24

3 - STS address, R24 write the updated value of the register back to the byte

Now depending on the step in the main code, the following will happen :

When interrupted at step 1, the register is loaded , the ISR clears the variable to 0, but since R24 was saved and restored it holds the previous value. It then will continue to be increased and saved. The other steps will have a similar outcome. 

This is normal since you interrupted a process. 

It is like printing to the serial port "Hello world" and an ISR will print a *. This star will appear in the other data.

Beside writing at the same time to the same variable, there is another problem with variables that have a longer data length than 1 byte.

Lets say you work on a WORD that is 2 bytes and has a value of &H1234

The code :

1- LDS R24, address of LSB

2- LDS R25, address of MSB

3- add some value to R24 like 1

4- add some value to R25 like 1

5- STS address of LSB, R24

6- STS address of MSB, R25

The normal outcome would be &H1335 since both registers were increased by 1.

When this code is interrupted between step 5 and 6, and the WORD variable is read, it will not have the right value. This because one of the registers is not written yet. When you read a BYTE, it will always have the value that you have written to it. (either in the main or ISR).

But in this sample you would read &H1235 because the MSB register R25 is not written to memory yet.

BITS

Bits are stored in bytes. This can cause the same problems when you manipulate bits that have the same byte address.

So what do we do to prevent problems? The normal solution is to disable interrupts in your code and re-enable them when you write to variables that are also access inside the ISR : 

DISABLE INTERRUPTS

SomeWord = 0

ENABLE INTERRUPTS

Now the ISR can not interrupt the updating of the variable. So it can not read the wrong value.

The SAFE option will disable interrupts and enables them, whenever you write or read a safe variable. 

Please notice that this will not be done inside an ISR since when an ISR is executed, the global interrupts are disabled by default at the hardware level.

And also notice that when interrupts were not enabled yet, they will be as soon you access a variable with the SAFE flag !

From version 2086 off, at the cost of some extra code, the I flag is saved and restored.

Using the SAFE flag on a BIT will make ALL the bits of the byte of that group SAFE as well. 

```vb
For example :

Dim b1 as BIT SAFE , b2 as BIT

```
Now b1 and b2 will be placed inside the same byte. And since b1 is marked with SAFE, b2 will be safe too since it shares the same memory location.

You can not use the SAFE attribute on an OVERLAY variable. 

TYPES

A type is a container for a number of normal data types. See also [TYPE](type.md).

Almost all rules apply to types. Dim rec as klm 'where klm is a defined TYPE

See Also

[CONST](const.md) , [LOCAL](local.md), [Memory usage](memory_usage.md) , [CONFIG BASE](config_base.md) , [TYPE](type.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : dim.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: DIM

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim B1 As Bit 'bit can be 0 or 1

Dim A As Byte 'byte range from 0-255

Dim C As Integer 'integer range from -32767 - +32768

Dim L As Long

Dim W As Word

Dim S As String * 11 'length can be up to 11 characters

'new feature : you can specify the address of the variable

Dim K As Integer At &H120

'the next dimensioned variable will be placed after variable s

Dim Kk As Integer

'Assign bits

```
B1 = 1 'or

```vb
Set B1 'use set

'Assign bytes

```
A = 12

A = A + 1

'Assign integer

C = -12

C = C + 100

Print C

W = 50000

```vb
Print W

'Assign long

```
L = 12345678

```vb
Print L

'Assign string

```
S = "Hello world"

```vb
Print S

End

```

---

## DIR

Action

Returns the filename that matches the specified file mask.

Syntax

sFile = DIR(mask)

sFile = DIR()

Remarks

SFile | A string variable that is assigned with the filename.  
---|---  
Mask | A file mask with a valid DOS file mask like *.TXT Use *.* to select all files.  
  
The first function call needs a file mask. All other calls do not need the file mask. In fact when you want to get the next filename from the directory, you must not provide a mask after the first call.

Dir() returns an empty string when there are no more files or when no file name is found that matches the mask.

![notice](notice.jpg)You should not use directory/file manipulation functions between DIR(mask) and DIR(). This because the first use of DIR() with a mask will search the FAT and will set up a pointer to this table. The next use of DIR() will continue to search the next match. But when you change the directory, or create a file or directory the pointer will be lost.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILELEN](filelen.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [WRITE](write.md) , [INPUT](input.md) , [MKDIR](mkdir.md), [RMDIR](rmdir.md) , [CHDIR](chdir.md)

ASM

Calls | _Dir ; with file mask | _Dir0 ; without file mask  
---|---|---  
Input | X : points to the string with the mask | Z : points to the target variable  
Output |  |   
  
Partial Example

```vb
'Lets have a look at the file we created

Print "Dir function demo"

```
S = Dir("*.*")

```vb
'The first call to the DIR() function must contain a file mask

' The * means everything.

'

While Len(s)> 0 ' if there was a file found

Print S ;" ";Filedate();" ";Filetime();" ";Filelen()

' print file , the date the fime was created/changed , the time and the size of the file

```
S = Dir()' get next

Wend

---

## DISABLE

Action

Disable specified interrupt.

Syntax

DISABLE interrupt [device]

Remarks

Interrupt | Description  
---|---  
INT0 | External Interrupt 0  
INT1 | External Interrupt 1  
OVF0,TIMER0, COUNTER0 | TIMER0 overflow interrupt  
OVF1,TIMER1, COUNTER1 | TIMER1 overflow interrupt  
CAPTURE1, ICP1 | INPUT CAPTURE TIMER1 interrupt  
COMPARE1A,OC1A | TIMER1 OUTPUT COMPARE A interrupt  
COMPARE1B,OC1B | TIMER1 OUTPUT COMPARE B interrupt  
SPI | SPI interrupt  
URXC | Serial RX complete interrupt  
UDRE | Serial data register empty interrupt  
UTXC | Serial TX complete interrupt  
SERIAL | Disables URXC, UDRE and UTXC  
ACI | Analog comparator interrupt  
ADC | A/D converter interrupt  
  
By default all interrupts are disabled.

To disable all interrupts specify INTERRUPTS.

To enable the enabling and disabling of individual interrupts use ENABLE INTERRUPTS.

The ENABLE INTERRUPTS serves as a master switch. It must be enabled/set in order for the individual interrupts to work.

The interrupts that are available will depend on the used microprocessor. The available interrupts are shown automatically in the editor.

![notice](notice.jpg) To disable the JTAG you can use DISABLED JTAG. The JTAG is not an interrupt but a device.

XTINY/MEGAX/AVRX

The newest processors can configure each pin of a port. This is done using the CONFIG XPIN statement.

The sense parameter controls how the pin is used :

INT_DISABLED : no interrupt will occur but input buffer is enabled

BOTH : on a rising or falling edge an interrupt will occur

RISING : a rising edge will trigger an interrupt

FALLING : a falling edge will trigger an interrupt

INP_DISABLED : input and digital input buffer are disabled

LOW_LEVEL : interrupt will occur on a low level

So instead of using ENABLE you need to use CONFIG XPIN and select the proper trigger mode.

Instead of DISABLE you need to use CONFIG XPIN and select INT_DISABLED for the sense mode.

See also

[ENABLE](enable.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : serint.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : serial interrupt example for AVR

'micro : 90S8535

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "8535def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

```
Const Cmaxchar = 20 ' number of characters

```vb
Dim B As Bit ' a flag for signalling a received character

Dim Bc As Byte ' byte counter

Dim Buf As String * Cmaxchar ' serial buffer

Dim D As Byte

'Buf = Space(20)

'unremark line above for the MID() function in the ISR

'we need to fill the buffer with spaces otherwise it will contain garbage

Print "Start"

On Urxc Rec_isr ' define serial receive ISR

Enable Urxc ' enable receive isr

Enable Interrupts ' enable interrupts to occur

Do

If B = 1 Then ' we received something

Disable Serial

Print Buf ' print buffer

Print Bc ' print character counter

'now check for buffer full

If Bc = Cmaxchar Then ' buffer full

```
Buf = "" ' clear

Bc = 0 ' rest character counter

```vb
End If

Reset B ' reset receive flag

Enable Serial

End If

Loop

```
Rec_isr:

```vb
Print "*"

If Bc < Cmaxchar Then ' does it fit into the buffer?

```
Incr Bc ' increase buffer counter

If Udr = 13 Then ' return?

Buf = Buf + Chr(0)

Bc = Cmaxchar

Else

Buf = Buf + Chr(udr) ' add to buffer

```vb
End If

' Mid(buf , Bc , 1) = Udr

'unremark line above and remark the line with Chr() to place

'the character into a certain position

'B = 1 ' set flag

End If

```
B = 1 ' set flag

Return

---

## DISKFREE

Action

Returns the free size of the Disk in KB.

Syntax

lFreeSize = DISKFREE()

Remarks

lFreeSize | A Long Variable, which is assigned with the available Bytes on the Disk in Kilo Bytes.  
---|---  
  
This functions returns the free size of the disk in KB.

With the support of FAT32, the return value was changed from byte into KB.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _GetDiskFreeSize  
---|---  
Input | none  
Output | r16-r19: Long-Value of free Bytes  
  
Partial Example

Dim Gbtemp1 As Byte ' scratch byte

Gbtemp1 =Initfilesystem(1) ' we must init the filesystem once

```vb
If Gbtemp1 > 0 Then

Print#1 ,"Error "; Gbtemp1

Else

Print#1 ," OK"

Print "Disksize : ";Disksize() ' show disk size in bytes

Print "Disk free: ";Diskfree() ' show free space too

End If

```

---

## DISKSIZE

Action

Returns the size of the Disk in KB.

Syntax

lSize = DISKSIZE()

Remarks

lSize | A Long Variable, which is assigned with the capacity of the disk in Kilo Bytes  
---|---  
  
This functions returns the capacity of the disk in KB.

With the support of FAT32, the return value was changed from byte into KB.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _GetDiskSize  
---|---  
Input | none  
Output | 16-r19: Long-Value of capacity in Bytes  
  
Partial Example

Dim Gbtemp1 As Byte ' scratch byte

Gbtemp1 = Initfilesystem(1) ' we must init the filesystem once

```vb
If Gbtemp1 > 0 Then

Print#1 ,"Error "; Gbtemp1

Else

Print#1 ," OK"

Print "Disksize : "; Disksize() ' show disk size in bytes

Print "Disk free: "; Diskfree() ' show free space too

End If

```

---

## DISPLAY

Action

Turn LCD display ON or OFF.

Syntax

DISPLAY ON | OFF

DISPLAY ON | OFF , CURSOR | NOCURSOR , BLINK | NOBLINK

Remarks

The display is turned on at power up.

When you use DISPLAY with a single parameter, the compiler will maintain a variable to hold the status of the display. In some cases this can lead to an unexpected result. This depends on the order of how the commands are called. 

If you experience this problem, you can use the alternative syntax which demands that all 3 parameters are specified.

This does not use any state variable and will update the LCD command register.

The second syntax is advised to be used.

See also

[LCD](lcd_2.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : lcd.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: LCD, CLS, LOWERLINE, SHIFTLCD, SHIFTCURSOR, HOME

' CURSOR, DISPLAY

'micro : Mega8515

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m8515.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$sim

'REMOVE the above command for the real program !!

'$sim is used for faster simulation

'note : tested in PIN mode with 4-bit

'Config Lcdpin = Pin , Db4 = Portb.1 , Db5 = Portb.2 , Db6 = Portb.3 , Db7 = Portb.4 , E = Portb.5 , Rs = Portb.6

Config Lcdpin = Pin , Db4 = Porta.4 , Db5 = Porta.5 , Db6 = Porta.6 , Db7 = Porta.7 , E = Portc.7 , Rs = Portc.6

'These settings are for the STK200 in PIN mode

'Connect only DB4 to DB7 of the LCD to the LCD connector of the STK D4-D7

'Connect the E-line of the LCD to A15 (PORTC.7) and NOT to the E line of the LCD connector

'Connect the RS, V0, GND and =5V of the LCD to the STK LCD connector

```
Rem with the config lcdpin statement you can override the compiler settings

```vb
Dim A As Byte

Config Lcd = 16 * 2 'configure lcd screen

'other options are 16 * 4 and 20 * 4, 20 * 2 , 16 * 1a

'When you dont include this option 16 * 2 is assumed

'16 * 1a is intended for 16 character displays with split addresses over 2 lines

'$LCD = address will turn LCD into 8-bit databus mode

' use this with uP with external RAM and/or ROM

' because it aint need the port pins !

```
Cls 'clear the LCD display

Lcd "Hello world." 'display this at the top line

Wait 1

Lowerline 'select the lower line

Wait 1

Lcd "Shift this." 'display this at the lower line

```vb
Wait 1

For A = 1 To 10

```
Shiftlcd Right 'shift the text to the right

```vb
Wait 1 'wait a moment

Next

For A = 1 To 10

```
Shiftlcd Left 'shift the text to the left

```vb
Wait 1 'wait a moment

Next

```
Locate 2 , 1 'set cursor position

Lcd "*" 'display this

Wait 1 'wait a moment

Shiftcursor Right 'shift the cursor

Lcd "@" 'display this

Wait 1 'wait a moment

Home Upper 'select line 1 and return home

Lcd "Replaced." 'replace the text

Wait 1 'wait a moment

Cursor Off Noblink 'hide cursor

Wait 1 'wait a moment

Cursor On Blink 'show cursor

Wait 1 'wait a moment

Display Off 'turn display off

Wait 1 'wait a moment

Display On 'turn display on

'-----------------NEW support for 4-line LCD------

Thirdline

Lcd "Line 3"

Fourthline

Lcd "Line 4"

Home Third 'goto home on line three

Home Fourth

Home F 'first letteer also works

Locate 4 , 1 : Lcd "Line 4"

```vb
Wait 1

'Now lets build a special character

'the first number is the characternumber (0-7)

'The other numbers are the rowvalues

'Use the LCD tool to insert this line

```
Deflcdchar 1 , 225 , 227 , 226 , 226 , 226 , 242 , 234 , 228 ' replace ? with number (0-7)

Deflcdchar 0 , 240 , 224 , 224 , 255 , 254 , 252 , 248 , 240 ' replace ? with number (0-7)

Cls 'select data RAM

Rem it is important that a CLS is following the deflcdchar statements because it will set the controller back in datamode

Lcd Chr(0) ; Chr(1) 'print the special character

'----------------- Now use an internal routine ------------

_temp1 = 1 'value into ACC

!rCall _write_lcd 'put it on LCD

End

---

## Display_E

Action

End the display list. FT800 will ignore all the commands following this command.

Syntax

Display_E

See Also

[CALL_C](call_c.md) , [JUMP](jump.md), [RETURN_C](return_c.md) , [MACRO_R](macro_r.md)

Remarks

Note: The Bascom FT800 Lib calls Display_E from within [UpdateScreen](upperline.md) so it's not required in most circumstances.

---

## DO-LOOP

Action

Repeat a block of statements until condition is true.

Syntax

DO

statements

LOOP [ UNTIL expression]

Remarks

You can exit a DO..LOOP with the EXIT DO statement.

The DO-LOOP is always performed at least once.

The main part of your code can best be executed within a DO.. LOOP.

You could use a GOTO also but it is not as clear as the DO LOOP.

Main:

```vb
' code

GOTO Main

Do

' Code

Loop

```
Of course in the example above, it is simple to see what happens, but when the code consist of a lot of lines of code, it is not so clear anymore what the GOTO Main does.

See also

[EXIT](exit.md) , [WHILE-WEND](while_wend.md) , [FOR-NEXT](for_next.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : do_loop.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: DO, LOOP

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte

```
A = 1 'assign a var

```vb
Do 'begin a do..loop

Print A 'print var

```
Incr A 'increase by one

```vb
Loop Until A = 10 'do until a=10

End

'You can write a never-ending loop with the following code

Do

'Your code goes here

Loop

```

---

## DOUBLE

The double.lbx (lib) is written by Josef Franz VÃ¶gel. The library supports the basic operations :

•| Addition (+)  
---|---  
  
•| Subtraction (-)  
---|---  
  
•| Multiplication (*)  
---|---  
  
•| Division (/)  
---|---  
  
•| Val() , INPUT  
---|---  
  
•| Str() , PRINT  
---|---  
  
•| Int()  
---|---  
  
•| Frac()  
---|---  
  
•| Fix()  
---|---  
  
•| Round()  
---|---  
  
•| Conversion from double to single and long  
---|---  
  
•| Conversion from single and long to double  
---|---  
  
The double library uses special Mega instructions not available in all AVR chips. But as the old chips are not manufactured anymore, this should not be a problem.

In version 1.11.9.8 a software multiplication is performed so the trig functions can be used on any chip that has enough internal memory.

In the report file you can find out if your micro supports the HWMUL. the _HWMUL conststant is set to 1 in that case. 

When software multiplication is used, the multiply routine needs more processor cycles. A number of trig functions depend on the multiplication code and as a result, they become more slow too. 

All Trig() functions are supported by the double too!

---

## DriveCheck

Action

Checks the Drive, if it is ready for use

Syntax

bErrorCode = DRIVECHECK()

Remarks

bErrorCode | A Byte Variable, which is assigned with the return value of the function  
---|---  
  
This function checks the drive, if it is ready for use (for example, whether a compact flash card is inserted). The functions returns 0 if the drive can be used, otherwise an error code is returned. For Error code see section Error codes.

See also

[DriveReset](drivereset.md) , [DriveInit](driveinit.md) , [DriveGetIdentity](drivegetidentity.md) , [DriveWriteSector](drivewritesector.md) , [DriveReadSector](drivereadsector.md)

ASM

Calls | _DriveCheck |   
---|---|---  
Input | none |   
Output | r25: Errorcode | C-Flag: Set on Error  
  
Partial Example

Dim bError as Byte

bError = DriveCheck()

---

## DriveGetIdentity

Action

Returns the Parameter information from the Card/Drive

Syntax

bErrorCode = DRIVEGETIDENTITY(wSRAMPointer)

Remarks

BErrorCode | A Byte Variable, which is assigned with the error code of the function  
---|---  
wSRAMPointer | A Word Variable, which contains the SRAM address (pointer) , to which the information of the Drive should be written  
  
The Identify Drive Function returns the parameter information (512 Bytes) from the Compact Flash Memory Card/Drive and writes it to SRAM starting at the address, to which the content of the variable wSRAMPointer is pointing. This information are for example number of sectors of the card, serial number and so on. Refer to the Card/Drive manual for further information. The functions returns 0 if no error occurred. For Error code see section Error codes.

Note: For meaning of wSRAMPointer see Note in DriveReadSector

See also

[DriveCheck](drivecheck.md), [DriveReset](drivereset.md) , [DriveInit](driveinit.md) , [DriveWriteSector](drivewritesector.md) , [DriveReadSector](drivereadsector.md)

ASM

Calls | _DriveGetIdentity |   
---|---|---  
Input |  | Z: SRAM-Address of buffer *)  
Output | r25: Errorcode | C-Flag: Set on Error  
  
![notice](notice.jpg) *) Please note: This is not the address of wSRAMPointer, it is its content, which is the starting-address of the buffer.

Partial Example

```vb
Dim bError as Byte

Dim aBuffer(512) as Byte' Hold Sector to and from CF-Card

Dim wSRAMPointer as Word' Address-Pointer for write

' give Address of first Byte of the 512 Byte Buffer to Word-Variable

```
wSRAMPointer =VarPtr(aBuffer(1))

' Now read the parameter Information from CF-Card

bError = DriveGetIdentity( wSRAMPointer)

---

## DriveInit

Action

Sets the AVR-Hardware (PORTs, PINs) attached to the Drive and resets the Drive.

Syntax

bErrorCode = DRIVEINIT()

Remarks

BErrorCode | A Byte Variable, which is assigned with the error code of the function  
---|---  
  
Set the Ports and Pins attaching the Drive for Input/Output and give initial values to the output-pins. After that the Drive is reset. 

Which action is done in this function depends of the drive and its kind of connection to the AVR. The functions returns 0 if no error occurred.

For Error code see section Error codes.

See also

[DriveCheck](drivecheck.md), [DriveReset](drivereset.md) , [DriveGetIdentity](drivegetidentity.md) , [DriveWriteSector](drivewritesector.md) , [DriveReadSector](drivereadsector.md), [AVR-DOS File System](avr_dos_file_system.md)

ASM

Calls | _DriveInit |   
---|---|---  
Input | none |   
Output | r25: Errorcode | C-Flag: Set on Error  
  
Partial Example

Dim bError as Byte

bError = DriveInit()

---

## DriveReadSector

Action

Read a Sector (512 Bytes) from the (Compact Flashcard) Drive

Syntax

bErrorCode = DRIVEREADSECTOR(wSRAMPointer, lSectorNumber)

Remarks

bErrorCode | A Byte Variable, which is assigned with the error code of the function  
---|---  
wSRAMPointer | A Word Variable, which contains the SRAM address (pointer) , to which the Sector from the Drive should be written  
lSectorNumber | A Long Variable, which give the sector number on the drive be transfer.  
  
Reads a Sector (512 Bytes) from the Drive and write it to SRAM starting at the address, to which the content of the variable wSRAMPointer is pointing. The functions returns 0 if no error occurred. For Error code see section Error codes.

Note: wSRAMPointer is not the variable, to which the content of the desired drive-sector should be written, it is the Word-Variable/Value which contains the SRAM address of the range, to which 512 Bytes should be written from the Drive. This gives you the flexibility to read and write every SRAM-Range to and from the drive, even it is not declared as variable. If you know the SRAM-Address (from the compiler report) of a buffer you can pass this value directly, otherwise you can get the address with the BASCOM-function VARPTR (see example).

See also

[DriveCheck](drivecheck.md), [DriveReset](drivereset.md) , [DriveInit](driveinit.md) , [DriveGetIdentity](drivegetidentity.md) , [DriveWriteSector](drivewritesector.md)

ASM

Calls | _DriveReadSector |   
---|---|---  
Input | Z: SRAM-Address of buffer *) | X: Address of Long-variable with sectornumber  
Output | r25: Errorcode | C-Flag: Set on Error  
  
![notice](notice.jpg)This is not the address of wSRAMPointer, it is its content, which is the starting-address of the buffer.

Partial Example

```vb
Dim bError as Byte

Dim aBuffer(512)as Byte' Hold Sector to and from CF-Card

Dim wSRAMPointer as Word' Address-Pointer for write

Dim lSectorNumber as Long' Sector Number

' give Address of first Byte of the 512 Byte Buffer to Word-Variable

```
wSRAMPointer =VarPtr(aBuffer(1))

' Set Sectornumber, sector 32 normally holds the Boot record sector of first partition

lSectorNumber = 32

' Now read in sector 32 from CF-Card

bError = DriveReadSector( wSRAMPointer , lSectorNumber)

' Now Sector number 32 is in Byte-Array bBuffer

---

## DriveReset

Action

Resets the Drive.

Syntax

bErrorCode = DRIVERESET()

Remarks

BErrorCode | A Byte Variable, which is assigned with the error code of the function  
---|---  
  
This function resets the drive and brings it to an initial state. The functions returns 0 if no error occurred. For Error code see section Error codes.

See also

[DriveCheck](drivecheck.md), [DriveInit](driveinit.md) , [DriveGetIdentity](drivegetidentity.md) , [DriveWriteSector](drivewritesector.md) , [DriveReadSector](drivereadsector.md)

ASM

Calls | _DriveReset |   
---|---|---  
Input | none |   
Output | r25: Errorcode | C-Flag: Set on Error  
  
Partial Example

Dim bError as Byte

bError = DriveReset()

---

## DriveWriteSector

Action

Write a Sector (512 Bytes) to the (Compact Flashcard) Drive

Syntax

bErrorCode = DRIVEWRITESECTOR(wSRAMPointer, lSectorNumber)

Remarks

bErrorCode | A Byte Variable, which is assigned with the error code of the function  
---|---  
wSRAMPointer | A Word Variable, which contains the SRAM address (pointer), from which the Sector to the Drive should be written  
lSectorNumber | A Long Variable, which give the sector number on the drive to transfer.  
  
Writes a Sector (512 Bytes) from SRAM starting at the address, to which the content of the variable wSRAMPointer is pointing to the Drive to sector number lSectornumber. The functions returns 0 if no error occurred. For Error code see section Error codes.

![notice](notice.jpg) For the meaning of wSRAMPointer see Note in DriveReadSector

See also

[DriveCheck](drivecheck.md), [DriveReset](drivereset.md) , [DriveInit](driveinit.md) , [DriveGetIdentity](drivegetidentity.md) , [DriveReadSector](drivereadsector.md)

ASM

Calls | _DriveWriteSector |   
---|---|---  
Input | Z: SRAM-Address of buffer *) | X: Address of Long-variable with sectornumber  
Output | r25: Errorcode | C-Flag: Set on Error  
  
![notice](notice.jpg) This is not the address of wSRAMPointer, it is its content, which is the starting-address of the buffer.

Partial Example

```vb
Dim bError as Byte

Dim aBuffer(512) as Byte' Hold Sector to and from CF-Card

Dim wSRAMPointer as Word' Address-Pointer for read

Dim lSectorNumber as Long' Sector Number

' give Address of first Byte of the 512 Byte Buffer to Word-Variable

```
wSRAMPointer =VarPtr(aBuffer(1))

' Set Sectornumber

lSectorNumber = 3

' Now Write in sector 3 from CF-Card

bError = DriveWriteSector( wSRAMPointer , lSectorNumber)

---

## DTMFOUT

Action

Sends a DTMF tone to the compare1 output pin of timer 1.

Syntax

DTMFOUT number, duration

DTMFOUT string , duration

Remarks

Number | A variable or numeric constant that is equivalent with the number of your phone keypad.  
---|---  
Duration | Time in mS the tone will be generated.  
string | A string variable that holds the digits to be dialed.  
  
The DTMFOUT statement is based on an Atmel application note (314).

It uses TIMER1 to generate the dual tones. As a consequence, timer1 can not be used in interrupt mode by your application. You may use it for other tasks.

Since the TIMER1 is used in interrupt mode you must enable global interrupts with the statement [ENABLE INTERRUPTS](enable.md). The compiler could do this automatic but when you use other interrupts as well it makes more sense that you enable them at the point where you want them to be enabled.

The working range is from 4 MHz to 10 MHz system clock(xtal).

The DTMF output is available on the TIMER1 OCA1 pin. For a 2313 this is PORTB.3.

Take precautions when connecting the output to your telephone line.

![important](important.jpg) Ring voltage can be dangerous!

System Resources used

TIMER1 in interrupt mode

See also

NONE

ASM

The following routine is called from mcs.lib : _DTMFOUT

R16 holds the number of the tone to generate, R24-R25 hold the duration time in mS.

Uses R9,R10,R16-R23

The DTMF table is remarked in the source and shown for completeness, it is generated by the compiler however with taking the used crystal in consideration.

Example

```vb
'-----------------------------------------------------------------------------------------

'name : dtmfout.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates DTMFOUT statement based on AN 314 from Atmel

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'since the DTMFOUT statement uses the TIMER1 interrupt you must enable

'global interrupts

'This is not done by the compiler in case you have more ISRs

Enable Interrupts

'the first sample does dtmfout in a loop

Dim Btmp As Byte , Sdtmf As String * 10

```
Sdtmf = "12345678" ' number to dial

Do

Dtmfout Sdtmf , 50 ' lets dial a number

```vb
' ^ duration is 50 mS for each digit

Waitms 1000 ' wait for one second

' As an alternative you can send single digits

' there are 16 dtmf tones

For Btmp = 0 To 15

```
Dtmfout Btmp , 50 ' dtmf out on PORTB.3 for the 2313 for 500 mS

```vb
'output is on the OC1A output pin

Waitms 500 ' wait 500 msec

Next

Loop

End

'the keypad of most phones looks like this :

'1 2 3 optional are A

'4 5 6 B

'7 8 9 C

'* 0 # D

'the DTMFOUT translates a numeric value from 0-15 into :

' numeric value phone key

' 0 0

' 1 1

' 2 2

' 3 3

' etc.

' 9 9

' 10 *

' 11 #

' 12 A

' 13 B

' 14 C

' 15 D

```

---

## ECHO

Action

Turns the ECHO on or off while asking for serial INPUT.

Syntax

ECHO value

Remarks

Value | ON to enable ECHO and OFF to disable ECHO.  
---|---  
  
When you use INPUT to retrieve values for variables, all info you type can be echoed back. In this case you will see each character you enter. When ECHO is OFF, you will not see the characters you enter.

In versions 1.11.6.2 and earlier the ECHO options were controlled by an additional parameter on the INPUT statement line like : INPUT "Hello " , var NOECHO

This would suppress the ECHO of the typed data. The new syntax works by setting ECHO ON and OFF. For backwards compatibility, using NOECHO on the INPUT statement line will also work. In effect it will turn echo off and on automatic.

By default, ECHO is always ON.

See also

[INPUT](input.md)

ASM

The called routines from mcs.lib are _ECHO_ON and _ECHO_OFF

The following ASM is generated when you turn ECHO OFF.

Rcall Echo_Off

This will set bit 3 in R6 that holds the ECHO state.

When you turn the echo ON the following code will be generated

Rcall Echo_On

Example

```vb
'-----------------------------------------------------------------------------------------

'name : input.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: INPUT, INPUTHEX

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim V As Byte , B1 As Byte

Dim C As Integer , D As Byte

Dim S As String * 15

Input "Use this to ask a question " , V

Input B1 'leave out for no question

Input "Enter integer " , C

Print C

```
Inputhex "Enter hex number (4 bytes) " , C

Print C

Inputhex "Enter hex byte (2 bytes) " , D

```vb
Print D

Input "More variables " , C , D

Print C ; " " ; D

Input C Noecho 'supress echo

Input "Enter your name " , S

Print "Hello " ; S

Input S Noecho 'without echo

Print S

End

```

---

## Elektor CF-Interface

The popular Electronics magazine Elektor, published an article about a CF-card interface. This interface was connected to an 89S8252. This interface can be used and will use little pins of the micro.

Note that because of the FAT buffer requirement, it is not possible to use a 8051 micro.,

At this moment, only the Mega128 and the Mega103 AVR microâs are good chips to use with AVR-DOS.

You can use external memory with other chips like the Mega162.

![cf-elektor](cf-elektor.gif)

Changes of the hardware pins is possible in the file Config_FlashCardDrive_EL_PIN.bas.

The default library is FlashCardDrive.lib but this interface uses the library FlashCardDrive_EL_PIN.lib.

See also: [AVR-DOS File System](avr_dos_file_system.md)

---

## ELSE

Action

Executed if the IF-THEN expression is false.

Syntax

ELSE

Remarks

You don't have to use the ELSE statement in an IF THEN .. END IF structure.

You can use the ELSEIF statement to test for another condition.

IF a = 1 THEN

...

ELSEIF a = 2 THEN

..

ELSEIF b1 > a THEN

...

ELSE

...

END IF

See also

[IF](if_then_else_end_if.md) , [END IF](if_then_else_end_if.md) , [SELECT-CASE](select_case_end_select.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : if_then.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: IF, THEN, ELSE

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte , B1 As Byte

Input "Number " , A 'ask for number

If A = 1 Then 'test number

Print "You got it!"

End If

If A = 0 Then 'test again

Print "Wrong" 'thats wrong

Else 'print this if a is not 0

Print "Almost?"

End If

```
Rem You Can Nest If Then Statements Like This

B1 = 0

```vb
If A = 1 Then

If B1 = 0 Then

Print "B1=0"

End If

Else

Print "A is not 0"

End If

Input "Number " , A

If A = 1 Then '

Print "Ok"

```
Elseif A = 2 Then 'use elseif for more tests

Print "2" : A = 3

Elseif A = 3 Then

```vb
Print "3"

End If

If A.1 = 1 Then Print "Bit 1 set" 'test for a bit

End

```

---

## EM4095 RFID Reader

Introduction

RFID technology is an exciting technology. The EM4095 chip allows us to create a reader with little code or processor resources.

A complete KIT is available from the web shop at [www.mcselec.com](<http://www.mcselec.com/tiny/shop/8/171>)

This topic describes the reference design. 

The data sheets you can download from:

[EM4095](<http://www.mcselec.com/tiny/dwn/192/54>) (chip) , [EM4102](<http://www.mcselec.com/tiny/dwn/193/54>) (transponder)

The circuit

![em4095_sch](em4095_sch.zoom49.png)

As you can see from the data sheets, the EM4095 needs little external hardware. A coil, capacitors that tune the coil for 125 KHz, are basically all that you need. IC1 is a voltage regulator that regulates the input voltage to 5V. (you can operate it from a 9V battery). The capacitors stabilize the output voltage. The DEMOD output of the EM4095 is connected to the microprocessor and the pin is used in input mode. The MOD and SHD pins are connected to micro pins that are used in output mode.

The micro(mega88) has a small 32 KHz crystal so the soft clock can be used. There are 3 switches that can be used for menu input, and there is a relay that can be used to activate a door opener. Parallel on the relay there is a LED for a visible indication.

IC4 is a serial interface buffer so we can connect the PCB to our computer for logging and programming. The Mega88 is delivered with a Boot loader and thus can be serial programmed with the MCS Boot loader. That is why pin 4 of X6 (DTR) is connected via IC4(pin 8-9) to the reset pin of the micro(pin 1).

Further there is a standard 10-pins ISP programmer connector for the USB-ISP or STK200, and an LCD connector for an optional LCD display.

The PCB

![em4095_pcb](em4095_pcb.zoom67.png)

Part list

Component | Value  
---|---  
C1 | 470uF/25V  
C2,C3,C5,C6,C9,CDEC,CAGND | 100nF (104)  
C4 | 100uF/16V  
CRES1,CRES, CDV2 | 1nF(102)  
CDV1 | 47pF  
CDC2,CFCAP | 10nF(103)  
C11,C12,C13,C14 | 1uF/16V  
RSER | 68  
R4,R6 | 10K  
R5 | 470  
R8 | 47  
R3 | 47K  
R9 | 1K-10K pot  
IC1 | 7805  
IC2 | EM4095  
IC3 | ATMEGA88  
IC4 | MAX232  
20 pin IC feet, 16 pin IC feet |   
  
X1,X2 | 2-pin header  
X3 | 16 pin boxed header  
X4 | 3-pin header  
X5 | 10-pin boxed header  
X6 | DB-9 female connector  
T1 | BC547  
D1 | 1N4148  
LED1 | 3 mm LED, red  
K1 | Relay, 5V  
S1,S2,S3 | switch  
Q1 | 32768 Hz crystal  
Antenna |   
  
M3x6 bolt and nut |   
  
4 rubber feet |   
  
  
Building the PCB

As usually we start with the components that have the lowest height. And normally we would solder all passive components first, and insert/solder the active components last. This to prevent damage to the active components(IC). But since the EM4095 is only available in SMD, we need to solder this chip first. Make sure the chip is lined out right and that pin 1 matches the small dot on the chip which is an indication for pin 1.

Then solder pin 1 and 16 so the chip can not be moved anymore. Now solder the remaining pins. Use an iron with a small tip. When you use too much solder, and two feet are soldered together do not panic. Just finish soldering and when ready, use some copper braid to remove the solder between the 2 feet. This works best when you lay the braid over the 2 pins, then push the solder iron to the braid so it will heat up. Then after some seconds, add some solder which will get sucked into the braid. This will in turn suck the other solder into the braid. While it does not seem logical to add solder, it will conduct the heat better. But since the used SMD chip is relatively large there should not be any problem.

Now mount and solder the following components :

•| RSER (68 ohm)  
---|---  
  
•| R3 (47K)  
---|---  
  
•| R4,R6 (10 K)  
---|---  
  
•| R5 (470)  
---|---  
  
•| R8 (47 for LCD)  
---|---  
  
•| D1 (diode 1N4148). The black line must match the line on the PCB(Kathode)  
---|---  
  
•| C2,C3,C5,C6,C9,CDEC,CAGND (100 nF)  
---|---  
  
•| CRES1,CRES , CDV2 (1nF)  
---|---  
  
•| CDV1 (47pF)  
---|---  
  
•| CDC2,CFCAP (10nF)  
---|---  
  
•| 28 pins IC feet for the Mega88 and 16 pins IC feet for the MAX232  
---|---  
  
•| Bend the wires of IC1 and mount IC1 with the bolt and nut  
---|---  
  
•| Bend the wires of the crystal and mount Q1  
---|---  
  
•| S1,S2,S3 (switches)  
---|---  
  
•| LED1. The square pad matches the longest wire of the LED(Anode)  
---|---  
  
•| R9 (potmeter for LCD contrast)  
---|---  
  
•| T1(transistor BC547)  
---|---  
  
•| Boxed header X5 and X3. Notice the gap in the middle which must match with the PCB  
---|---  
  
•| X6 (DB9-female connector)  
---|---  
  
•| K1 (relay)  
---|---  
  
•| C11,C12,C13,C14 (1uF/16V)  
---|---  
  
•| C4 (100uF/16V)  
---|---  
  
•| X1,X2 (2 pins screw connectors)  
---|---  
  
•| X4 (3 pin screw connector)  
---|---  
  
•| C1 (470 uF/25V)  
---|---  
  
•| 4 rubber feet  
---|---  
  
Operation

Now the PCB is ready. Make sure there are no solder drops on the PCB. You can measure with an Ohm-meter if there is a short circuit.

Measure pin 1 and pin 2 of IC1 (the voltage input) and pin 3 and pin 2 of IC1 (the voltage output). 

When everything is ok, insert the MAX232 and the MEGA88. 

You can connect the battery cord to header X1. The red wire is the plus. Since the circuit is not for beginners, there is no reverse polarity protection. While the 7805 does not mind a short circuit, the C1 elco might not like it. 

Connect the battery and measure with a Volt meter if IC1 actual outputs 5V. If not, check the input voltage, and for a possible shortcut.

Connect the antenna to connector X2. The PCB is now ready for use. When you have the LCD display, connect it to the LCD header and adjust the variable resistor R9 so you can see square blocks.

Since the chip has a boot loader, you can serial program the device. We made a simple AN that can be used as a door opener. It has simple menu, and we can add new tags. When a valid tag is held in front of the antenna, it will activate the relay for 2 seconds. The LED will be turned on as well.

Compile the program AN_READHITAG_EM4095.BAS and select the MCS Boot Loader programmer. Connect a serial cable to X6 and press F4 to program.

You need a normal straight cable.

![db9-cable](db9-cable.png)

When you did not used the MCS Bootloader before, check the COM port settings and make sure the BAUD is set to 38400 as in the following screenshot:

![bootloader_sample](bootloader_sample.png)

You also need to set 'RESET via DTR' on the 'MCS Loader' TAB. 

Now the program will start and show some info on the LCD. Each time you hold a RFID tag before the antenna/coil, the TAG ID will be shown. 

When you press S3, you can store an RFID. Press S3, and then hold the TAG before the coil. When there is room , or the tag is new, it will be stored. Otherwise it will be ignored. The TAG ID is also stored in EEPROM.

Now when you hold the tag before the coil, the relay is activated for 2 seconds. 

The AN is very simple and you can change and extend it easily.

One nice idea from Gerhard : use one TAG as a master tag to be able to add/remove tags.

Security

To make the code more secure you could add a delay so that a valid tag must be received twice, so after the valid TAG, wait 1 second, and then start a new measurement and check if the TAG is valid again.

This will prevent where a bit generator could be used to generate all possible codes. With 64 bit times a second, it would take ages before it would work. 

The other hack would be to listen with a long range 125 KHz antenna, and recording all bits. A long range scanner would be very hard to make. It would be easier to open the door with a crowbar.

When you open your door with this device, make sure you have a backup option like a key in case there is no power. Also, when the door is opened by a magnetic door opener, make sure it has the right quality for the entrance you want to protect. 

![em4095_board](em4095_board.jpg)

AN Code

```vb
'-------------------------------------------------------------------------------

' (c) 1995-2025 MCS Electronics

' This sample will read a HITAG chip based on the EM4095 chip

' Consult EM4102 and EM4095 datasheets for more info

'-------------------------------------------------------------------------------

' The EM4095 was implemented after an idea of Gerhard Günzel

' Gerhard provided the hardware and did research at the coil and capacitors.

' The EM4095 is much simpler to use than the HTRC110. It need less pins.

' A reference design with all parts is available from MCS

'-------------------------------------------------------------------------------

$regfile = "M88def.dat"

$baud = 19200

$crystal = 8000000

$hwstack = 40

$swstack = 40

$framesize = 40

Declare Function Havetag(b As Byte ) As Byte

'Make SHD and MOD low

```
_md Alias Portd.4

Config _md = Output

_md = 0

_shd Alias Portd.5

Config _shd = Output

_shd = 0

Relay Alias Portd.2

Config Relay = Output

S3 Alias Pinb.0

S2 Alias Pinb.2

S1 Alias Pinb.1

Portb = &B111 ' these are all input pins and we activate the pull up resistor

```vb
Config Clock = Soft 'we use a clock

Config Date = Dmy , Separator = -

Enable Interrupts ' the clock and RFID code need the int

```
Date$ = "15-12-07" ' just a special date to start with

Time$ = "00:00:00"

```vb
'Config Lcd Sets The Portpins Of The Lcd

Config Lcdpin = Pin , Db4 = Portc.2 , Db5 = Portc.3 , Db6 = Portc.4 , Db7 = Portc.5 , E = Portc.1 , Rs = Portc.0

Config Lcd = 16 * 2 '16*2 type LCD screen

```
Cls

Lcd " EM4095 sample"

Lowerline : Lcd "MCS Electronics"

```vb
Dim Tags(5) As Byte 'make sure the array is at least 5 bytes

Dim J As Byte , Idx As Byte

Dim Eramdum As Eram Byte ' do not use first position

Dim Etagcount As Eram Byte ' number of stored tags

Dim Etags(100) As Eram Byte 'room for 20 tags

Dim Stags(100) As Byte 'since we have enough SRAM store them in sram too

Dim Btags As Byte , Tmp1 As Byte , Tmp2 As Byte

Dim K As Byte , Tel As Byte , M As Byte

Config Hitag = 64 , Type = Em4095 , Demod = Pind.3 , Int = @int1

Print "EM4095 sample"

'you could use the PCINT option too, but you must mask all pins out so it will only respond to our pin

' Pcmsk2 = &B0000_0100

' On Pcint2 Checkints

' Enable Pcint2

On Int1 Checkints Nosave 'we use the INT1 pin all regs are saved in the lib

Config Int1 = Change 'we have to config so that on each pin change the routine will be called

Enable Interrupts 'as last we have to enable all interrupts

'read eeprom and store in sram

'when the program starts we read the EEPROM and store it in SRAM

For Idx = 1 To 100 'for all stored tags

```
Stags(idx) = Etags(idx)

```vb
Print Hex(stags(idx)) ; ",";

Next

```
Btags = Etagcount ' get number of stored tags

```vb
If Btags = 255 Then ' an empty cell is FF (255)

Print "No tags stored yet"

```
Btags = 0 : Etagcount = Btags ' reset and write to eeprom

```vb
Else ' we have some tags

For J = 1 To Btags

```
Tmp2 = J * 5 'end

Tmp1 = Tmp2 - 4 'start

```vb
Print "RFID ; " ; J ' just for debug

For Idx = Tmp1 To Tmp2

Print Hex(stags(idx)) ; ",";

Next

Print

Next

End If

Do

Print "Check..."

```
Upperline : Lcd Time$ ; " Detect"

If Readhitag(tags(1)) = 1 Then 'this will enable INT1

Lowerline

```vb
For J = 1 To 5

Print Hex(tags(j)) ; ",";

```
Lcd Hex(tags(j)) ; ","

Next

M = Havetag(tags(1)) 'check if we have this tag already

```vb
If M > 0 Then

Print "Valid TAG ;" ; M

```
Relay = 1 'turn on relay

Waitms 2000 'wait 2 secs

Relay = 0 'relay off

```vb
End If

Print

Else

Print "Nothing"

End If

If S3 = 0 Then 'user pressed button 3

Print "Button 3"

```
Cls : Lcd "Add RFID"

```vb
Do

If Readhitag(tags(1)) = 1 Then 'this will enable INT1

If Havetag(tags(1)) = 0 Then 'we do not have it yet

If Btags < 20 Then 'will it fit?

```
Incr Btags 'add one

Etagcount = Btags

Idx = Btags * 5 'offset

Idx = Idx - 4

Lowerline

For J = 1 To 5

Lcd Hex(tags(j)) ; ","

Stags(idx) = Tags(j)

Etags(idx) = Tags(j)

Incr Idx

Next

Cls

Lcd "TAG stored" : Waitms 1000

```vb
End If

End If

Exit Do

End If

Loop

End If

If S2 = 0 Then

Print "Button 2"

End If

If S1 = 0 Then

Print "Button 1"

End If

Waitms 500

Loop

'check to see if a tag is stored already

'return 0 if not stored

'return value 1-20 if stored

Function Havetag(b As Byte ) As Byte

Print "Check if we have TAG : ";

For K = 1 To 5

Print Hex(b(k)) ; ","

Next

For K = 1 To 20

```
Tmp2 = K * 5 'end addres

Tmp1 = Tmp2 - 4 'start

Tel = 0

For Idx = Tmp1 To Tmp2

Incr Tel

```vb
If Stags(idx) <> B(tel) Then 'if they do not match

Exit For 'exit and try next

End If

Next

If Tel = 5 Then 'if we did found 5 matching bytes we have a match

Print "We have one"

```
Havetag = K 'set index

```vb
Exit Function

End If

Next

```
Havetag = 0 'assume we have nothing yet

End Function

Checkints:

Call _checkhitag 'in case you have used a PCINT, you could have other code here as well

Return

Tips and Tricks

The oscillator frequency must be 125 KHz. You can measure this with an oscilloscope. It is possible that you need to remove a few windings of the antenna coil to get an exact 125 KHz. This will result in a higher distance that you can use for the tags.

---

## ENABLE

Action

Enable specified interrupt.

(ATTINY, ATMEGA, ATXMEGA)

Syntax

ENABLE interrupt [, prio]

[, prio] is only for ATXMEGA

Remarks

Interrupt | Description  
---|---  
INT0 | External Interrupt 0  
INT1 | External Interrupt 1  
OVF0,TIMER0, COUNTER0 | TIMER0 overflow interrupt  
OVF1,TIMER1, COUNTER1 | TIMER1 overflow interrupt  
CAPTURE1, ICP1 | INPUT CAPTURE TIMER1 interrupt  
COMPARE1A,OC1A or COMPARE1, OC1 | TIMER1 OUTPUT COMPARE A interrupt In case of only one compare interrupt  
COMPARE1B,OC1B | TIMER1 OUTPUT COMPARE B interrupt  
SPI | SPI interrupt  
URXC | Serial RX complete interrupt  
UDRE | Serial data register empty interrupt  
UTXC | Serial TX complete interrupt  
SERIAL | Disables URXC, UDRE and UTXC  
ACI | Analog comparator interrupt  
ADC | A/D converter interrupt  
  
|   
  
XMEGA ONLY |   
  
prio | The priority you want to assign to the interrupt. Specify Lo, Hi or Med.  In the Xmega you must provide the priority of the interrupts. Lo=Low priority. Hi=High priority and Med=Medium priority. If you do not specify a priority, MED will be used.  
  
By default all interrupts are disabled.

The global interrupts master switch is also disabled by default. 

If you enable an interrupt, it will only fire if the master interrupt switch is enabled.

You enable this master switch with ENABLE INTERRUPTS.

You can disable it with DISABLE INTERRUPTS.

If an interrupt is executed, the global master switch will be disabled automatically by the hardware.

This is to prevent other interrupts to occur. 

When the interrupt routine returns, the processor hardware will automatically enable the master switch so new interrupts may occur.

The following schematic demonstrates the interrupt master switch. It forms an AND with the other interrupts. This means that both the interrupt of a hardware source and the master switch interrupt must be enabled. ENABLE interrupts will enable the I flag in SREG.

![int-global](int-global.png)

It depends on the processor how many and which interrupts it has. If you type ENABLE in the editor, you will get a pop up with a list of interrupts you can chose from.

ATTINY & ATMEGA Interrupt List

In normal AVR chips the priority is determined by the interrupts address. The lower the address, the higher the priority.

In the DAT file you can find a list with interrupts and their address.

For example , taken from the m1280def.dat file :

[INTLIST]

count=56

INTname1=INT0,$002,EIMSK.INT0,EIFR.INTF0

INTname2=INT1,$004,EIMSK.INT1,EIFR.INTF1

INTname3=INT2,$006,EIMSK.INT2,EIFR.INTF2

INTname4=INT3,$008,EIMSK.INT3,EIFR.INTF3

INTname5=INT4,$00a,EIMSK.INT4,EIFR.INTF4

INTname6=INT5,$00c,EIMSK.INT5,EIFR.INTF5

INT0 has the highest priority since it has the lowest address (address 2)

Following an Overview where INT0 is used as an example.

Overview

1\. You configure an Interrupt

  
```vb
On Int0 Int0_isr   
Config Int0 = Low Level

```
2\. You enable the specific Interrupt

  
Enable Int0  


3\. Enable all Interrupts

  
Enable Interrupts  
  
  
4\. You have an Interrupt Service Routine after the "End" with an Return  


```vb
End

' Interrupt Service Routine  
```
Int0_isr:  
```vb
' so someting.....  
Return

```
XMEGA

The XMEGA has a priority system. You can specify if an interrupt has a low, medium or high priority.

But you MUST enable these priorities with [CONFIG PRIORITY](config_priority.md)

Please read the topic [CONFIG PRIORITY](config_priority.md) in order to understand which interrupt to enable.

In the DAT file you can find a list with interrupts and their address.

For example , taken from the "xm128A4Udef.dat file "

INTLIST]

count=95

INTname1=OSCFAIL,$0002,OSC_XOSCFAIL.0,OSC_XOSCFAIL.1 ; XOSC Failure Detection Register

INTname2=PORTC_INT0,$0004,#PORTC_INTCTRL.0,PORTC_INTFLAGS.0

INTname3=PORTC_INT1,$0006,#PORTC_INTCTRL.2,PORTC_INTFLAGS.1

INTname4=PORTR_INT0,$0008,#PORTR_INTCTRL.0,PORTR_INTFLAGS.0

INTname5=PORTR_INT1,$000A,#PORTR_INTCTRL.2,PORTR_INTFLAGS.1

INTname6=DMA_CH0,$000C,#,DMA_CH0_CTRLB.0,DMA_CH0_CTRLB.4

INTname7=DMA_CH1,$000E,#,DMA_CH1_CTRLB.0,DMA_CH1_CTRLB.4

INTname8=DMA_CH2,$0010,#,DMA_CH2_CTRLB.0,DMA_CH2_CTRLB.4

INTname9=DMA_CH3,$0012,#,DMA_CH3_CTRLB.0,DMA_CH3_CTRLB.4

INTname10=RTC_OVF,$0014,#RTC_INTCTRL.0,RTC_INTFLAGS.0

INTname11=RTC_COMP,$0016,#RTC_INTCTRL.2,RTC_INTFLAGS.1

Example with PORTC_INT0  
  
```vb
On Portc_int0 portc_isr  
Enable Portc_int0 , Hi  


```
In [ATXMEGA](atxmega.md) there is an example for Pin Interrupt.

XTINY/MEGAX/AVRX

The newest processors can configure each pin of a port. This is done using the CONFIG XPIN statement.

The sense parameter controls how the pin is used :

INT_DISABLED : no interrupt will occur but input buffer is enabled

BOTH : on a rising or falling edge an interrupt will occur

RISING : a rising edge will trigger an interrupt

FALLING : a falling edge will trigger an interrupt

INP_DISABLED : input and digital input buffer are disabled

LOW_LEVEL : interrupt will occur on a low level

So instead of using ENABLE you need to use CONFIG XPIN and select the proper trigger mode.

Instead of DISABLE you need to use CONFIG XPIN and select INT_DISABLED for the sense mode.

See also

[DISABLE](disable.md) , [ON](on_interrupt.md) , [CONFIG PRIORITY](config_priority.md), [ATXMEGA](atxmega.md)

Example

  
```vb
$regfile = "attiny25.dat"  
$crystal = 1000000 ' 1MHz  
$hwstack = 10  
$swstack = 0  
$framesize = 24  
  
  
On Int0 Int0_isr ' INT0 will be the wake-up source for Powerdown Mode  
Config Int0 = Low Level ' External Pull-up (47K) on Portb.2  
Enable Int0  
  
'###############################################################################  
Do  
Wait 3 ' now we have 3 second to measure the Supply Current in Active Mode  
  
Enable Interrupts  
  
' Now call Powerdown function  
Config Powermode = Powerdown  
  
'Here you have time to measure PowerDown current consumption until a Low Level on Portb.1 which is the PowerDown wake-up  
Loop  
'###############################################################################  
End  
  
  
```
Int0_isr:  
```vb
' wake_up  
Return

```

---

## ENCODER

Action

Reads pulses from a rotary encoder.

Syntax

Var = ENCODER( pin1, pin2, LeftLabel, RightLabel , wait)

Remarks

Var | The target variable that is assigned with the result. This should be a byte. This byte is used to maintain the state.  
---|---  
Pin1 and pin2 | These are the names of the PIN registers to which the output of the encoder is connected. Both pins must be on the same PIN register. So Pinb.0 and Pinb.7 is valid while PinB.0 and PinA.0 is not.  
LeftLabel | The name of the label that will be called/executed when a transition to the left is encountered.  
RightLabel | The name of the label that will be called/executed when a transition to the right is encountered.  
wait | A value of 0 will only check for a rotation/pulse. While a value of 1 will wait until a user actual turns the encoder. A value of 1 will thus halt your program.  
  
There are some conditions you need to fulfill :

•| The label that is called by the encoder must be terminated by a RETURN statement.  
---|---  
  
•| The pin must work in the input mode. By default all pins work in input mode.  
---|---  
  
•| The pull up resistors must be activated by writing a logic 1 to the port registers as the example shows.  
---|---  
  
Rotary encoders come in many flavors. Some encoders also have a build in switch.

A sample of an encoder

![rotary_encoder](rotary_encoder.gif)

![rotary2](rotary2.gif)

Since the microprocessor has internal pull up resistors, you do not need external pull up resistors for most encoders.

An encoder has 2 output pins which change state when you turn the knob. For one 'click' you can get one or more pulses. This depends on the model of the encoder. Both output pins are sampled and compared with their previous value.

![encoder_state](encoder_state.png)

The table above show the states when rotating left and right. For example, when you turn left, the encoder will change state from 00 to 10 to 11 to 01 to 00 etc.

The software loads the pin values and compares the value with the previous value.

Only if you turn the knob there will be a different value. 

Next the old state nibbles are swapped so that for example state 0000_0011 becomes 0011_0000 and the new state is added to this value. For a left rotation you get the values 2,35,49 and 16. In all other cases, the rotation was right.

When you call the encoder routine often enough, you will not miss any pulses. Most new processors support the pin change interrupt. This means that an interrupt occurs when the logic level of a pin changes. you can use this interrupt to call the encoder function. This way you can be sure you will not miss a pulse.

The example will just show the direction but the idea is that you can increase or decrease a variable in these routines. For example for volume. 

Example

```vb
'-----------------------------------------------------------------------------------------

'name : encoder.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstration of encoder function

'micro : Mega128

'suited for demo : yes

'commercial addon needed : no

'An encoder has 2 outputs and a ground

'We connect the outputs to pinb.0 and pinb.1

'You may choose different pins as long as they are at the same PORT

'The pins must be configured to work as input pins

'This function works for all PIN registers

'-----------------------------------------------------------------------------------------

$regfile = "m128def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Print "Encoder test"

Dim B As Byte

'we have dimmed a byte because we need to maintain the state of the encoder

```
Portb = &B11 ' activate pull up registers

Do

B = Encoder(pinb.0 , Pinb.1 , Links , Rechts , 1)

```vb
' ^--- 1 means wait for change which blocks programflow

' ^--------^---------- labels which are called

' ^-------^---------------------------- port PINs

Print B

Waitms 10

Loop

End

'so while you can choose PINB0 and PINB7,they must be both member of PINB

'this works on all PIN registers

```
Links:

```vb
Print "left rotation"

Return

```
Rechts:

```vb
Print "right rotation"

Return

End

```

---

## END

Action

Terminate program execution.

Syntax

END

Remarks

STOP can also be used to terminate a program.

When an END statement is encountered, all interrupts are disabled and a never-ending loop is generated.

When a STOP is encountered the interrupts will not be disabled. Only a never ending loop will be created.

In an embedded application you probably do not want to end the application. But there are cases where you do want to end the application. For example when you control some motors, and you determine a failure, you do not want to use a Watchdog reset because then the failure will occur again. In that case you want to display an error, and wait for service personal to fix the failure.

It is important to notice that without the END statement, your program can behave strange in certain cases. For example :

Print "Hello"

Note that there is no END statement. So what will happen? The program will print "Hello". But as the compiler places the library code behind the program code, the micro will execute the library code ! But without being called. As most library code are assembler sub routines that end with a RET, your program will most likely crash, or reset and repeat for ever.

See also

[STOP](stop.md)

Example

```vb
Print "Hello" ' print this

End ' end program execution and disable all interrupts

```

---

## End_G

Action

End drawing a graphics primitive.

Syntax

End_G

Remarks

It is recommended to have an End_G for each [Begin_G](begin_g.md). 

For advanced users you can avoid the usage of End_G in order to save extra graphics instructions in the

Display List RAM.

See also

[BEGIN_G](begin_g.md) , [VERTEX2F](vertex2f.md), [VERTEX2II](vertex2ii.md)

---

## EOF

Action

Returns the End of File Status.

Syntax

bFileEOFStatus = EOF(#bFileNumber)

Remarks

bFileEOFStatus | (Byte) A Byte Variable, which assigned with the EOF Status  
---|---  
bFileNumber | (Byte) Number of the opened file  
  
This functions returns information about the End of File Status

Return value | Status  
---|---  
0 | NOT EOF  
255 | EOF  
  
In case of an error (invalid file number) 255 (EOF) is returned too.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileEOF |   
---|---|---  
Input | r24: Filenumber |   
Output | r24: EOF Status | r25: Error code  
| C-Flag: Set on Error |   
  
Partial Example

Ff =Freefile()' get file handle

Open "test.txt" For Input As #ff ' we can use a constant for the file too

```vb
Print Lof(#ff); " length of file"

Print Fileattr(#ff); " file mode" ' should be 1 for input

Do

```
LineInput #ff , S ' read a line

```vb
' line input is used to read a line of text from a file

Print S ' print on terminal emulator

Loop Until Eof(#ff)<> 0

'The EOF() function returns a non-zero number when the end of the file is reached

'This way we know that there is no more data we can read

```
Close #ff

---

## Error Codes

The following table lists errors that can occur.

Error | Description  
---|---  
1 | Unknown statement  
2 | Unknown structure EXIT statement  
3 | WHILE expected  
4 | No more space for IRAM BIT  
5 | No more space for BIT  
6 | . expected in filename  
7 | IF THEN expected  
8 | BASIC source file not found  
9 | Maximum 128 aliases allowed  
10 | Unknown LCD type  
11 | INPUT, OUTPUT, 0 or 1 expected  
12 | Unknown CONFIG parameter  
13 | CONST already specified  
14 | Only IRAM bytes supported  
15 | Wrong data type  
16 | Unknown Definition  
17 | 9 parameters expected  
18 | BIT only allowed with IRAM or SRAM  
19 | STRING length expected (DIM S AS STRING * 12 ,for example)  
20 | Unknown DATA TYPE  
21 | Out of IRAM space  
22 | Out of SRAM space  
23 | Out of XRAM space  
24 | Out of EPROM space  
25 | Variable already dimensioned  
26 | AS expected  
27 | parameter expected  
28 | IF THEN expected  
29 | SELECT CASE expected  
30 | BIT's are GLOBAL and can not be erased  
31 | Invalid data type  
32 | Variable not dimensioned  
33 | GLOBAL variable can not be ERASED  
34 | Invalid number of parameters  
35 | 3 parameters expected  
36 | THEN expected  
37 | Invalid comparison operator  
38 | Operation not possible on BITS  
39 | FOR expected  
40 | Variable can not be used with RESET  
41 | Variable can not be used with SET  
42 | Numeric parameter expected  
43 | File not found  
44 | 2 variables expected  
45 | DO expected  
46 | Assignment error  
47 | UNTIL expected  
50 | Value doesn't fit into INTEGER  
51 | Value doesn't fit into WORD  
52 | Value doesn't fit into LONG  
60 | Duplicate label  
61 | Label not found  
62 | SUB or FUNCTION expected first  
63 | Integer or Long expected for ABS()  
64 | , expected  
65 | device was not OPEN  
66 | device already OPENED  
68 | channel expected  
70 | BAUD rate not possible  
71 | Different parameter type passed then declared  
72 | Getclass error. This is an internal error.  
73 | Printing this FUNCTION not yet supported  
74 | 3 parameters expected  
80 | Code does not fit into target chip  
81 | Use HEX(var) instead of PRINTHEX  
82 | Use HEX(var) instead of LCDHEX  
85 | Unknown interrupt source  
86 | Invalid parameter for TIMER configuration  
87 | ALIAS already used  
88 | 0 or 1 expected  
89 | Out of range : must be 1-4  
90 | Address out of bounds  
91 | INPUT, OUTPUT, BINARY, or RANDOM expected  
92 | LEFT or RIGHT expected  
93 | Variable not dimensioned  
94 | Too many bits specified  
95 | Falling or rising expected for edge  
96 | Pre scale value must be 1,8,64,256 or 1024  
97 | SUB or FUNCTION must be DECLARED first  
98 | SET or RESET expected  
99 | TYPE expected  
100 | No array support for IRAM variables  
101 | Can't find HW-register  
102 | Error in internal routine  
103 | = expected  
104 | LoadReg error  
105 | StoreBit error  
106 | Unknown register  
107 | LoadnumValue error  
108 | Unknown directive in device file  
109 | = expected in include file for .EQU  
110 | Include file not found  
111 | SUB or FUNCTION not DECLARED  
112 | SUB/FUNCTION name expected  
113 | SUB/FUNCTION already DECLARED  
114 | LOCAL only allowed in SUB or FUNCTION  
115 | #channel expected  
116 | Invalid register file  
117 | Unknown interrupt  
126 | NEXT expected.  
129 | ( or ) missing.  
200 | .DEF not found  
201 | Low Pointer register expected  
202 | .EQU not found, probably using functions that are not supported by the selected chip  
203 | Error in LD or LDD statement  
204 | Error in ST or STD statement  
205 | } expected  
206 | Library file not found  
207 | Library file already registered  
210 | Bit definition not found  
211 | External routine not found  
212 | LOW LEVEL, RISING or FALLING expected  
213 | String expected for assignment  
214 | Size of XRAM string 0  
215 | Unknown ASM mnemonic  
216 | CONST not defined  
217 | No arrays allowed with BIT/BOOLEAN data type  
218 | Register must be in range from R16-R31  
219 | INT0-INT3 are always low level triggered in the MEGA  
220 | Forward jump out of range  
221 | Backward jump out of range  
222 | Illegal character  
223 | * expected  
224 | Index out of range  
225 | () may not be used with constants  
226 | Numeric of string constant expected  
227 | SRAM start greater than SRAM end  
228 | DATA line must be placed after the END statement  
229 | End Sub or End Function expected  
230 | You can not write to a PIN register  
231 | TO expected  
232 | Not supported for the selected micro  
233 | READ only works for normal DATA lines, not for EPROM data  
234 | ') block comment expected first  
235 | '( block comment expected first  
236 | Value does not fit into byte  
238 | Variable is not dimensioned as an array  
239 | Invalid code sequence because of AVR hardware bug  
240 | END FUNCTION expected  
241 | END SUB expected  
242 | Source variable does not match the target variable  
243 | Bit index out of range for supplied data type  
244 | Do not use the Y pointer  
245 | No arrays supported with IRAM variable  
246 | No more room for .DEF definitions  
247 | . expected  
248 | BYVAL should be used in declaration  
249 | ISR already defined  
250 | GOSUB expected  
251 | Label must be named SECTIC  
252 | Integer or Word expected  
253 | ERAM variable can not be used  
254 | Variable expected  
255 | Z or Z+ expected  
256 | Single expected  
257 | "" expected  
258 | SRAM string expected  
259 | \- not allowed for a byte  
260 | Value larger than string length  
261 | Array expected  
262 | ON or OFF expected  
263 | Array index out of range  
264 | Use ECHO OFF and ECHO ON instead  
265 | offset expected in LDD or STD like Z+1  
266 | TIMER0, TIMER1 or TIMER2 expected  
267 | Numeric constant expected  
268 | Param must be in range from 0-3  
269 | END SELECT expected  
270 | Address already occupied  
322 | Data type not supported with statement  
323 | Label too long  
324 | Chip not supported by I2C slave library  
325 | Pre-scale value must be 1,8,32,128,256 or 1024  
326 | #ENDIF expected  
327 | Maximum size is 255  
328 | Not valid for SW UART  
329 | FileDateTime can only be assigned to a variable  
330 | Maximum value for OUT is &H3F  
332 | $END ASM expected  
334 | ') blockcomment end expected  
335 | Use before DIM statements  
336 | Could not set specified CLOCK value  
337 | No more space for labels  
338 | AS expected  
339 | Bytes to read may not be 0.  
340 | Variable is used as CONSTANT  
341 | OFFSET Error, contact MCS  
342 | OFFSET not allowed, too many locals used  
343 | Variable not supported with this function/statement  
344 | Program will overwrite bootloader  
345 | UART not available for the selected micro  
346 | External interrupt not supported or no settings found in DAT file  
347 | External interrupt mode not supported or found in DAT file  
349 | Setting not supported or not found in DAT file  
350 | Interrupt needs return  
351 | Not supported yet.  
352 | ALIAS can not be CONST or DIMMED variable  
353 | Reserved word may not be used  
354 | Previous Macro definition must be ended first  
355 | Macro previously defined  
356 | String constant size exceeded  
357 | Too many constants, increase resource languages  
358 | .DEF error, already defined  
359 | Operation not allowed on register  
360 | PRESCALE can not be used in COUNTER mode  
361 | Member expected  
362 | SBIC or SBIS was used followed by IN, OUT, SBIC, SBIS, SBI or CBI that also need to be converted.  
363 | No more room for EPROM DATA Index  
364 | Name not allowed, is used by constant/variable  
365 | Function not allowed in PRINT  
366 | Bit value out or range  
367 | Function name not allowed  
368 | Name used by label  
369 | Duplicate label name used by const or variable  
370 | Out of Flash memory  
371 | Function not allowed  
372 | SE entry missing in DAT file  
373 | Re-Configuration not allowed  
374 | . not allowed.  
375 | Duplicate definition  
376 | Config not found  
377 | Unexpected non numeric characters found  
378 | CAN BAUD not possible  
379 | Syntax error  
380 | Array<>Non Array mismatch  
381 | CONFIG RC5 not found  
382 | variable does not match FOR  
383 | Register range must be within [R16-R23]  
384 | Register range must be within [R16-R31]  
385 | Register must be even within [R0-R30]  
386 | Register R0 expected  
387 | IO address must be in range [0-31]  
388 | Bit number must be in range [0-7]  
389 | Constant out of range [0-65535]  
390 | Float not allowed for index  
391 | JTAG can not be disabled  
392 | Invalid operator  
393 | UART is fixed  
394 | Unsupported data type for BYREG  
395 | Index out of range  
396 | Delay not possible with selected frequency. Use WAITMS  
397 | .ORG exceeds PC  
398 | Single or Double expected  
399 | ASM reserved word not allowed  
400 | No structure found for REDO  
401 | No structure found for CONTINUE  
402 | MULTI-DIM not supported for specified page address  
403 | Integer Numeric constant expected  
404 | Mode not possible  
405 | SRAM DAT FILE ERROR  
406 | Insufficient $FRAMESPACE  
407 | Channel not defined  
408 | Invalid channel  
409 | END TYPE expected  
410 | TYPE expected  
411 | MEMBER already exists  
500 | XTINY LICENSE Required  
  
|   
  
998,999 | DEMO/BETA only supports 4096 bytes of code  
9999 | Illegal version. Please remove this illegal crack. You will not always get this message or error. When bascom finds traces of an illegal version it will generated random bugs in your code which are hard to find. It can also show this error.  Only download software from the mcselec.com server.  
  
Other error codes are internal ones. Please report them to support@ when you encounter them.

The Code explorer can give different errors. Here is a table with errors and how you can modify your code.

Config Lcd = 16 * 2  | Config Lcd = 16X2  | Change the * into an X  
---|---|---  
Cursor Off Noblink | Cursor Off , Noblink | Add a comma

---

## EUROTIMEDATE

The CONFIG CLOCK statement for using the asynchrony timer of the 8535, M163, M103 or M128 (and others) allows you to use a software based clock. See [TIME$](time_.md) and [DATE$](date_.md).

By default the date format is in MM/DD/YY.

By specifying:

[$LIB](lib.md) "EURODATETIME.LBX"

The DATE$ will work in European format : DD-MM-YY

Note that the eurotimedate library should not be used anymore. It is replaced by the [DATETIME](datetime.md) library which offers many more features.

---

## EXIT

Action

Exit a FOR..NEXT, DO..LOOP , WHILE ..WEND, SUB..END SUB or FUNCTION..END FUNCTION.

Syntax

```vb
EXIT FOR

EXIT DO

EXIT WHILE

EXIT SUB

EXIT FUNCTION

```
Remarks

With the EXIT statement you can exit a structure at any time. 

Remarks about EXIT SUB/FUNCTION

It is important that you exit a SUB or FUNCTION with EXIT. Do not use a RETURN. A return can be used inside a sub routine to return from a sub routine located inside the sub routine.

```vb
For example:

Sub Test()

gosub label1

Exit Sub

```
label1:

```vb
print "test"

return

End Sub

```
When you use EXIT SUB or EXIT FUNCTION, the compiler will create a jump to a label with the sub/function name, prefixed with two underscores.

For example your Sub routine is named Test(), and you use Exit Sub, a label will be created with the name __TEST:

See Also

[DO](do_loop.md), [WHILE](what_is_new_in_2081.md), [FOR](for_next.md) , [SUB](sub.md), [FUNCTION](sub.md) , [CONTINUE](continue.md), [REDO](redo.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : exit.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: EXIT

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim B1 As Byte , A As Byte

```
B1 = 50 'assign var

```vb
For A = 1 To 100 'for next loop

If A = B1 Then 'decision

Exit For 'exit loop

End If

Next

Print "Exit the FOR..NEXT when A was " ; A

```
A = 1

Do

Incr A

```vb
If A = 10 Then

Exit Do

End If

Loop

Print "Loop terminated"

End

```

---

## EXP

Action

Returns e( the base of the natural logarithm) to the power of a single or double variable.

Syntax

Target = EXP(source)

Remarks

Target | The single or double that is assigned with the Exp() of the target.  
---|---  
Source | The source to get the Exp of.  
  
See also

[LOG](log.md) , [LOG10](log10.md)

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega88

'suited for demo : no, but without the DOUBLE, it works for DEMO too in M48

'commercial addon needed : no

'purpose : demonstrates EXP function

'-------------------------------------------------------------------------------

$regfile = "m88def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 40 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim X As Single

```
X = Exp(1.1)

```vb
Print X

'prints 3.004166124

```
X = 1.1

X = Exp(x)

```vb
Print X

'prints 3.004164931

Dim D As Double

```
D = Exp(1.1)

```vb
Print D

'prints 3.00416602394643

```
D = 1.1

D = Exp(d)

```vb
Print D

'prints 3.00416602394638

End

```

---

## FILEATTR

Action

Returns the file open mode.

Syntax

bFileAttribut = FILEATTR(bFileNumber)

Remarks

bFileAttribut | (Byte) File open mode, See table  
---|---  
bFileNumber | (Byte) Number of the opened file  
  
This functions returns information about the File open mode

Return value | Open mode  
---|---  
1 | INPUT  
2 | OUTPUT  
8 | APPEND  
32 | BINARY  
  
See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md), [WRITE](write.md) , [INPUT](input.md) , [GETATTR](getattr.md)

ASM

Calls | _FileAttr |   
---|---|---  
Input | r24: Filenumber |   
Output | 24: File open mode | r25: Errorcode  
| C-Flag: Set on Error |   
  
Partial Example

'open the file in BINARY mode

Open "test.biN" For Binary As #2

Print Fileattr(#2); " file mode" ' should be 32 for binary

Put #2 , Sn ' write a single

Put #2 , Stxt ' write a string

Close #2

---

## FILEDATE

Action

Returns the date of a file

Syntax

sDate = FILEDATE ()

sDate = FILEDATE (file)

Remarks

Sdate | A string variable that is assigned with the date.  
---|---  
File | The name of the file to get the date of.  
  
This function works on any file when you specify the filename. When you do not specify the filename, it works on the current selected file of the DIR() function.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md), [GET](get.md) , [PUT](put.md), [FILELEN](filelen.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileDateS ; with filename | _FileDateS0 ; for current file from DIR()  
---|---|---  
Input | X : points to the string with the mask | Z : points to the target variable  
Output |  |   
  
Partial Example

```vb
Print "File demo"

Print Filelen("josef.img");" length" ' length of file

Print Filetime("josef.img");" time" ' time file was changed

Print Filedate("josef.img");" date" ' file date

```

---

## FILEDATETIME

Action

Returns the file date and time of a file

Syntax

Var = FILEDATETIME ()

Var = FILEDATETIME (file)

Remarks

Var | A string variable or byte array that is assigned with the file date and time of the specified file  
---|---  
File | The name of the file to get the date time of.  
  
When the target variable is a string, it must be dimensioned with a length of at least 17 bytes.

When the target variable is a byte array, the array size must be at least 6 bytes.

When you use a numeric variable, the internal file date and time format will be used.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [GET](get.md) , [PUT](put.md) , [FILELEN](filelen.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [DIR](dir.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileDateTimeS | _FileDateTimeS0  
---|---|---  
Input |  |   
Output |  |   
  
Calls | _FileDateTimeB | _FileDateTimeB0  
---|---|---  
Input |  |   
Output |  |   
  
Example

See fs_subfunc_decl_lib.bas in the samples dir.

---

## FILELEN

Action

Returns the size of a file

Syntax

lSize = FILELEN ()

lSize = FILELEN (file)

Remarks

lSize | A Long Variable, which is assigned with the file size in bytes of the file.  
---|---  
File | A string or string constant to get the file length of.  
  
This function works on any file when you specify the filename. When you do not specify the filename, it works on the current selected file of the DIR() function.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileLen |   
---|---|---  
Input |  |   
Output |  |   
  
Partial Example

```vb
Print "File demo"

Print Filelen("josef.img");" length" ' length of file

Print Filetime("josef.img");" time" ' time file was changed

Print Filedate("josef.img");" date" ' file date

```

---

## FILETIME

Action

Returns the time of a file

Syntax

sTime = FILETIME ()

sTime = FILETIME (file)

Remarks

Stime | A string variable that is assigned with the file time.  
---|---  
File | The name of the file to get the time of.  
  
This function works on any file when you specify the filename. When you do not specify the filename, it works on the current selected file of the DIR() function.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [GET](get.md) , [PUT](put.md) , [FILELEN](filelen.md) , [FILEDATE](filedate.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileTimeS ; with file param | _FileTimeS0 ; current file  
---|---|---  
Input | X : points to the string with the mask | Z : points to the target variable  
Output |  |   
  
Example

```vb
Print "File demo"

Print Filelen("josef.img");" length" ' length of file

Print Filetime("josef.img");" time" ' time file was changed

Print Filedate("josef.img");" date" ' file date

```

---

## FIX

Action

Returns for values greater then zero the next lower value, for values less then zero the next upper value.

Syntax

var = FIX( x )

Remarks

Var | A single or double variable that is assigned with the FIX of variable x.  
---|---  
X | The floating point variable to get the FIX of.  
  
See Also

[INT](int.md) , [ROUND](round.md) , [SGN](sgn.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : round_fix_int.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : ROUND,FIX

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As Single , Z As Single

For S = -10 To 10 Step 0.5

Print S ; Spc(3) ; Round(s) ; Spc(3) ; Fix(s) ; Spc(3) ; Int(s)

Next

End

```

---

## FLUSH

Action

Write current buffer of File to Card and updates Directory

Syntax

FLUSH #bFileNumber

FLUSH

Remarks

BFileNumber | Filenumber, which identifies an opened file such as #1 or #ff  
---|---  
  
This function writes all information of an open file, which is not saved yet to the Disk. Normally the Card is updated, if a file will be closed or changed to another sector.

When no file number is specified, all open files will be flushed.

Flush does not need additional buffers. You could use FLUSH to be absolutely sure that data is written to the disk. For example in a data log application which is updated infrequently. A power failure could result in a problem when there would be data in the buffer. 

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileFlush | _FilesAllFlush  
---|---|---  
Input | r24: filenumber |   
Output | r25: Errorcode | C-Flag: Set on Error  
  
Partial Example

```vb
$include "startup.inc"

'open the file in BINARY mode

```
Open "test.bin" For Binary As #2

Put #2 , B ' write a byte

Put #2 , W ' write a word

Put #2 , L ' write a long

Ltemp = Loc(#2) + 1 ' get the position of the next byte

```vb
Print Ltemp ;" LOC" ' store the location of the file pointer

Print Lof(#2);" length of file"

Print Fileattr(#2);" file mode" ' should be 32 for binary

```
Put #2 , Sn ' write a single

Put #2 , Stxt ' write a string

Flush #2 ' flush to disk

Close #2

---

## FM24C16

The FM24C16 library is a library that uses a RAMTRON I2C serial EEPROM.

Ramtron memory chips are as quick as RAM and can be overwritten almost unlimited times. 

An external EEPROM is a safe alternative to the internal EEPROM.

By using : $lib "fm24c16.lib" 

The EEPROM read and write routines from the library will be used instead of the internal EEPROM.

Thus you can still use : Dim BE as ERAM Byte

And you can use READEEPROM and WRITEEEPROM, but instead of using the internal EEPROM, the external I2C EEPROM is used.

The lib is for the FM24C16. It uses I2C/TWI.

![notice](notice.jpg)This library is only included in the full version. It is not included with the DEMO.

Example

```vb
'-----------------------------------------------------------------------------------------  
'name : 24C256 simple RW test.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : Testing Read/Write operation with external EEPROM  
'micro : Mega8535  
'suited for demo : no  
'commercial addon needed : no  
'-----------------------------------------------------------------------------------------  
  
$regfile = "m8535.dat" ' specify the used micro  
$crystal = 8000000 ' used crystal frequency  
$baud = 19200 ' use baud rate  
$hwstack = 64 ' default use 32 for the hardware stack  
$swstack = 20 ' default use 10 for the SW stack  
$framesize = 40 ' default use 40 for the frame space  
  
$lib "i2c_twi.lbx" ' we do not use software emulated I2C but the TWI  
  
Config Scl = Portc.0 ' we need to provide the SCL pin name  
Config Sda = Portc.1 ' we need to provide the SDA pin name  
  
```
I2cinit ' we need to set the pins in the proper state  
  
```vb
Config Twi = 100000 ' wanted clock frequency  
  
' External EEPROM Config  
$eepromsize = &H8000  
$lib "fm24c64_256.lib"  
  
Dim A(101) As Eram Byte  
Dim B As Byte  
Dim C As Byte  
Dim D As Byte  
  
Do  
Input "Data to write ? (0-255)" , D  
  
Print "Reading content of EEPROM (via ERAM Byte)"  
For C = 0 To 100  
```
B = A(c)  
```vb
Print "Read ";C ; ":" ; B ; "/" ; Hex(b)  
Waitms 4  
Next  
  
Wait 1  
  
Print "Writing data to EEPROM (via ERAM Byte)"  
For C = 0 To 100  
```
A(c) = D  
```vb
Print "Write " ; C ; ":" ; D ; "/" ; Hex(d)  
Waitms 4  
Next  
  
Wait 1  
  
Print "Reading back data from EEPROM (via ERAM Byte)"  
For C = 0 To 100  
```
B = A(c)  
```vb
Print "Read " ; C ; ":" ; B ; "/" ; Hex(b)  
Waitms 4  
Next  
  
Wait 2  
  
Input "Data to write ? (0-255)" , D  
  
Print "Reading content of EEPROM (via READEEPROM)"  
For C = 0 To 100  
```
Readeeprom B , C  
```vb
Print "Read ";C ; ":" ; B ; "/" ; Hex(b)  
Waitms 4  
Next  
  
Wait 1  
  
Print "Writing data to EEPROM (via WRITEEEPROM)"  
For C = 0 To 100  
```
Writeeeprom D , C  
```vb
Print "Writing " ; C ; ":" ; D ; "/" ; Hex(d)  
Waitms 4  
Next  
  
Wait 1  
  
Print "Reading content of EEPROM (via READEEPROM)"  
For C = 0 To 100  
```
Readeeprom B , C  
```vb
Print "Read ";C ; ":" ; B ; "/" ; Hex(b)  
Waitms 4  
Next  
  
Wait 2  
  
Loop  
  
End  
'-------------------------------------------------------------------------------

```

---

## FM24C64_256

The FM24C64_256 library is a library that uses a RAMTRON I2C serial EEPROM.

Ramtron memory chips are as quick as RAM and can be overwritten almost unlimited times. 

An external EEPROM is a safe alternative to the internal EEPROM.

By using : $lib "fm24c64_256.lib" 

The EEPROM read and write routines from the library will be used instead of the internal EEPROM.

Thus you can still use : Dim BE as ERAM Byte

And you can use READEEPROM and WRITEEEPROM, but instead of using the internal EEPROM, the external I2C EEPROM is used.

The lib is for the FM24C64 to FM24C256. It uses I2C/TWI.

It was also tested with the M24512 an 1 MBit EEPROM. 

While intended for RAMTRON memory it will work with most normal I2C EEPROM as well. 

You should test it since some normal EEPROM might require a certain delay after the write.

![notice](notice.jpg)This library is only included in the full version. It is not included with the DEMO.

For an example see [FM24C16](fm24c16.md)

---

## FM25C256

The FM24C256 library is a library that uses a RAMTRON SPI serial EEPROM.

Ramtron memory chips are as quick as RAM and can be overwritten almost unlimited times. 

An external EEPROM is a safe alternative to the internal EEPROM. You can also increase the size of the EEPROM this way.

By using : $lib "fm25c256.lib" 

The EEPROM read and write routines from the library will be used instead of the internal EEPROM.

Thus you can still use : Dim BE as ERAM Byte

And you can use READEEPROM and WRITEEEPROM, but instead of using the internal EEPROM, the external I2C EEPROM is used.

The lib is for the FM25C256. It uses SPI

For the SPI you have to define the pins. The pin named fram_so is connected to SO of the FRAM. SI is connected to SI.

A sample is shown below. The clock, cs and SI pins need to be configured as output pins.

Fram_cs Alias Portl.7 : Const Fram_csp = 7 : Const Fram_csport = Portl

Fram_so Alias Pind.1 : Const Fram_sop = 1 : Const Fram_soport = Pind

Fram_si Alias Portd.0 : Const Fram_sip = 0 : Const Fram_siport = Portd

Fram_sck Alias Portl.6 : Const Fram_sckp = 6 : Const Fram_sckport = Portl

![notice](notice.jpg)This library is only included in the full version. It is not included with the DEMO.

Example

```vb
'-----------------------------------------------------------------------------------------  
'name : 25C256 simple RW test.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : Testing Read/Write operation with external EEPROM  
'micro : Mega8535  
'suited for demo : no  
'commercial addon needed : no  
'-----------------------------------------------------------------------------------------  
  
$regfile = "m8535.dat" ' specify the used micro  
$crystal = 8000000 ' used crystal frequency  
$baud = 19200 ' use baud rate  
$hwstack = 64 ' default use 32 for the hardware stack  
$swstack = 20 ' default use 10 for the SW stack  
$framesize = 40 ' default use 40 for the frame space  
  
  
  
' External EEPROM Config  
Config Portb.4 = Output  
Config Portb.7 = Output  
Config Portb.5 = Output  
```
Fram_cs Alias Portb.4 : Const Fram_csp = 4 : Const Fram_csport = Portb  
Fram_so Alias Pinb.6 : Const Fram_sop = 6 : Const Fram_soport = Pinb  
Fram_si Alias Portb.5 : Const Fram_sip = 5 : Const Fram_siport = Portb  
Fram_sck Alias Portb.7 : Const Fram_sckp = 7 : Const Fram_sckport = Portb  
  
```vb
$eepromsize = &H8000  
$lib "fm25c256.lib"  
  
Dim A(101) As Eram Byte  
Dim B As Byte  
Dim C As Byte  
Dim D As Byte  
  
Do  
  
Input "Data to write ? (0-255)" , D  
  
Print "Reading content of EEPROM (via ERAM Byte)"  
For C = 0 To 100  
```
B = A(c)  
```vb
Print "Read " ; C ; ":" ; B ; "/" ; Hex(b)  
Waitms 4  
Next  
  
Wait 1  
  
Print "Writing data to EEPROM (via ERAM Byte)"  
For C = 0 To 100  
```
A(c) = D  
```vb
Print "Write " ; C ; ":" ; D ; "/" ; Hex(d)  
Waitms 4  
Next  
  
Wait 1  
  
Print "Reading back data from EEPROM (via ERAM Byte)"  
For C = 0 To 100  
```
B = A(c)  
```vb
Print "Read " ; C ; ":" ; B ; "/" ; Hex(b)  
Waitms 4  
Next  
  
Wait 2  
  
Input "Data to write ? (0-255)" , D  
  
Print "Reading content of EEPROM (via READEEPROM)"  
For C = 0 To 100  
```
Readeeprom B , C  
```vb
Print "Read " ; C ; ":" ; B ; "/" ; Hex(b)  
Waitms 4  
Next  
  
Wait 1  
  
Print "Writing data to EEPROM (via WRITEEEPROM)"  
For C = 0 To 100  
```
Writeeeprom D , C  
```vb
Print "Writing " ; C ; ":" ; D ; "/" ; Hex(d)  
Waitms 4  
Next  
  
Wait 1  
  
Print "Reading content of EEPROM (via READEEPROM)"  
For C = 0 To 100  
```
Readeeprom B , C  
```vb
Print "Read " ; C ; ":" ; B ; "/" ; Hex(b)  
Waitms 4  
Next  
  
Wait 2  
  
  
Loop  
  
End  
'-------------------------------------------------------------------------------

```
Example 2, shared bus

  
```vb
' Using the FM25C256 library  
  
' The FM25C256 library uses the CYPRESS FM25W256 chip (before named FM25C256 by Ramtron)  
' This chip is based in FRAM technology, which makes it much faster than an EEPROM and has a much  
' longer life (100.000.000.000.000 read/writes)  
' To give an idea of speed, writting a byte to an XMEGA192A3 internal EEPROM takes more than 10580us  
' while writing a byte to the FM25W256 chip using the FM25C256 library takes 32,5us in this example;  
' this is more than 325 times faster.  
  
' NOTES:  
' - This library allows you to use an external EEPROM INSTEAD of the internal EEPROM (you cannot use both)  
' - Do not use the "Config Eeprom = " command when using this library  
' - The FM25C256 library uses software SPI; therefore, if you need to share the SPI bus with another chip  
' that uses HW SPI, you must:  
' - Configure the HW SPI normally (with the "Config SpiX =" command in XMEGA chips) as needed for  
' the other chip  
' - Disable HW SPI before reading or writing to EEPROM, and enable it after.  
  
' In this example, there are two chips connected to the SPIC bus of an XMEGA192A3, an accelerometer BMA180  
' and the FM25W256 FRAM chip.  
  
' The HW SPIC of the XMEGA192A3 is configured at the beginning to allow for the BMA180 to be read while the  
' FM25W256 is not used.  
'____________________________________________________________________________________  
  
$regfile = "xm192a3def.dat"  
$hwstack = 256  
$swstack = 256  
$framesize = 256  
'____________________________________________________________________________________  
  
' For 16MHz crystal  
Config Osc = Disabled , Extosc = Enabled , Range = 12mhz_16mhz , Startup = Xtal_1kclk , 32khzosc = Enabled  
' Set PLL OSC conditions:  
```
Osc_pllctrl = &B1100_0010 ' Reference external oscillator, set the PLL' multiplication factor to 2 (bits 0 - 4)  
Set Osc_ctrl.4 ' Enable PLL Oscillator  
Bitwait Osc_status.4 , Set ' wait until the pll clock reference source is stable  
Clk_ctrl = &B0000_0100 ' switch system clock to pll  
```vb
' Prescale  
Config Sysclock = Pll , Prescalea = 1 , Prescalebc = 1_1  
$crystal = 32000000  
'____________________________  
```
Const Fclock = 32000000  
```vb
'____________________________________________________________________________________  
  
'Config Eeprom = Mapped ' Do not put this command when using an external EEPROM  
'____________________________________________________________________________________  
  
Config Priority = Static , Vector = Application , Lo = Enabled , Med = Enabled , Hi = Enabled  
Enable Interrupts  
  
'================================ COM1 (C2 C3) C0 ==================================  
  
' COM1 RS232_1  
Config Com1 = 230400 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
Config Serialin = Buffered , Size = 254  
Config Serialout = Buffered , Size = 254  
```
Open "COM1:" For Binary As #1  
  
```vb
'================================== SPIC for FRAM ================================  
  
' External EEPROM Config  
```
Fram_cs Alias Porta.7 : Const Fram_csp = 7 : Const Fram_csport = Porta : Config Porta.7 = Output  
Fram_si Alias Portc.5 : Const Fram_sip = 5 : Const Fram_siport = Portc : Config Portc.5 = Output  
Fram_sck Alias Portc.7 : Const Fram_sckp = 7 : Const Fram_sckport = Portc : Config Portc.7 = Output  
Fram_so Alias Port.6 : Const Fram_sop = 6 : Const Fram_soport = Pinc  
  
```vb
$eepromsize = &H8000 ' Size, in bytes, of the FM25W256 memory  
'____________________________________________________________________________________  
  
$lib "fm25c256.lib" '  
'NOTE:  
'While using the lib, the hardware SPI should be disabled. you can do this by writing to the SPIx_CTRL register  
' SPIC_CTRL.6=0 'disable SPI  
'Then use the eeprom commands, and re-enable the SPI after that : SPIC_CTRL.6=1  
'Also notice that clock level must be low at entrance for FM25W256  
' Fram_sck = 0 ' Need to put this before accesing the chip  
'eprom commands here  
' Before re-enable hw spi, set clock pin to high, and enabe with spic_ctrl.6=1  
'____________________________________________________________________________________  
  
' Configure HW SPIC to use a BMA180  
Config Spic = Hard , Master = Yes , Mode = 3 , Clockdiv = Clk8 , Data_order = Msb , Ss = None  
' Open device  
```
Open "SPIC" For Binary As #10  
  
Bma_ss Alias Portc.4 : Config Portc.4 = Output : Bma_ss = 1 ' /SS del bma180  
  
```vb
'____________________________________________________________________________________  
  
Dim Dwtemp_ee As Eram Dword  
Dim Dwtemp As Dword  
Dim N As Byte  
```
N = 0  
```vb
Dim I As Byte  
  
Dim Acel_x As Integer  
'____________________________________________________________________________________  
  
Do  
' ------------------------  
```
Incr N  
```vb
' ------------------------  
' Disable HW SPi before writing to EEPROM FM25W256  
```
Spic_ctrl.6 = 0  
Fram_sck = 0 ' Clock level must be low at entrance for fm25256  
' Write to EEPROM FM25W256  
Dwtemp = N ' Convert Byte to Dword. When writing to EEPROM variables must be of the same type  
Dwtemp_ee = Dwtemp ' This takes 51,1us  
' Read from EEPROM FM25W256  
Dwtemp = Dwtemp_ee ' This takes 42,2us  
' Enable HW SPI. It must be done with SCK high  
Fram_sck = 1  
Spic_ctrl.6 = 1 ' Enable HW SPI  
```vb
' ------------------------  
' Show value stored and then retrieved from EEPROM  
Print #1 , N ; ":" ; Dwtemp ; " ";  
' ------------------------  
Gosub Read_bma_x  
Print #1 , Acel_x ; "mG"  
' ------------------------  
Waitms 500  
' ------------------------  
Loop  
  
'____________________________________________________________________________________  
  
' READ THE BMA180 X AXIS ACCELERATION  
'____________________________________________________________________________________  
  
Dim Bma_adr_byte As Byte  
Dim Spi_byte As Byte  
Dim Msb_itemp As Integer  
Dim Lsb_itemp As Integer  
' Dim Aceleracion_tmp As Integer  
```
Const Acc_x_msb = &H3  
Const Acc_x_lsb = &H2  
'____________________________________________________________________________________  
  
Read_bma_x:  
'_________________________ Read Acel_X_LSB  
Bma_ss = 0  
Bma_adr_byte = Acc_x_lsb ' X_LSB  
Bma_adr_byte.7 = 1 ' Read command  
```vb
Print #10 , Bma_adr_byte ' Send address  
Input #10 , Spi_byte ' Read spibyte= | d5 d4 d3 d2 d1 d0 | 0 | 1 |  
```
Bma_ss = 1 ' De-select BMA 180  
Shift Spi_byte , Right , 2  
Lsb_itemp = Spi_byte  
'_________________________ Read Acel_X_MSB  
Bma_ss = 0  
Bma_adr_byte = Acc_x_msb ' X_MSB  
Bma_adr_byte.7 = 1 ' Read command  
```vb
Print #10 , Bma_adr_byte ' Send address  
Input #10 , Spi_byte ' Read spibyte= |d13 d12 d11 d10 d9 d8 d7 d6 |  
```
Bma_ss = 1 ' De-select BMA180  
Msb_itemp = Spi_byte  
Shift Msb_itemp , Left , 6  
Lsb_itemp = Lsb_itemp Or Msb_itemp  
Lsb_itemp.14 = Spi_byte.7  
Lsb_itemp.15 = Spi_byte.7  
  
Acel_x = Lsb_itemp  
  
```vb
Return  
'____________________________________________________________________________________  
  
End

```

---

## Font Editor

In version 2079 the Font Editor plugin is replaced by the integrated Font Editor from the [Tools menu](tools_font_editor.md). It has the same options.  
  
The Font Editor is a Plug in that is intended to create Fonts that can be used with Graphical display such as SED1521, KS108, color displays, etc.

When you have installed the Font Editor , a menu option becomes available under the Tools menu : Font Editor.

When you choose this option the following window will appear:

![font_editor](font_editor.gif)

You can open an existing Font file, or Save a modified file.

The supplied font files are installed in the Samples directory.

You can copy an image from the clipboard, and you can then move the image up , down, left and right.

When you select a new character, the current character is saved. The suggest button will draw an image of the current selected character.

When you keep the left mouse button pressed, you can set the pixels in the grid. When you keep the right mouse button pressed, you can clear the pixels in the grid.

When you choose the option to create a new Font, you must provide the name of the font, the height of the font in pixels and the width of the font in pixels.

The Max ASCII is the last ASCII character value you want to use. Each character will occupy space. So it is important that you do not choose a value that is too high and will not be used.

When you display normal text, the maximum number is 127 so it does not make sense to specify a value of 255.

A font file is a plain text file. 

Lets have a look at the first few lines of the 8x8 font:

Font8x8:

$asm

.db 1,8,8,0

.db 0,0,0,0,0,0,0,0 ; 

.db 0,0,6,95,6,0,0,0 ; !

The first line contains the name of the font. With the [SETFONT](setfont.md) statement you can select the font. Essential, this sets a data pointer to the location of the font data.

The second line ($ASM) is a directive for the internal assembler that asm code will follow.

All other lines are data lines. 

The third line contains 4 bytes: 1 (height in bytes of the font) , 8 (width in pixels of the font), 8 (block size of the font) and a 0 which was not used before the 'truetype' support, but used for aligning the data in memory. This because AVR object code is a word long.

This last position is 0 by default. Except for 'TrueType' fonts. In BASCOM a TrueType font is a font where every character can have it's own width. The letter 'i' for example takes less space then the letter 'w'. The EADOG128 library demonstrates the TrueType option.

In order to display TT, the code need to determine the space at the left and right of the character. This space is then skipped and a fixed space is used between the characters. You can replace the 0 by the width you want to use. The value 2 seems a good one for small fonts.

All other lines are bytes that represent the character.

---

## FOR-NEXT

Action

Execute a block of statements a number of times.

Syntax

FOR var = start TO end [STEP value]

Remarks

var | The variable counter to use  
---|---  
start | The starting value of the variable var  
end | The ending value of the variable var  
value | The value var is increased/decreased with each time NEXT is encountered.  
  
•| For incremental loops, you must use TO.  
---|---  
  
•| For decremental loops, you must use a negative step size.  
---|---  
  
•| You must end a FOR structure with the NEXT statement.  
---|---  
  
•| The use of STEP is optional. By default, a value of 1 is used.  
---|---  
  
When you know in advance how many times a block of code must be executed, the FOR..NEXT loop is convenient to use.

You can exit a FOR .. NEXT loop with the EXIT FOR statement. 

It is important that the if you use variables for START and END, that these are of the same data type. So for example:

```vb
Dim x, as byte, st as byte, ed as byte

FOR x = st TO ED ' this is ok since all variables are of the same data type

Dim x as Byte, st as Word, Ed as Long

FOR x = st TO ED ' this is NOT ok since all variables are of different data type. 

```
The reason is that when the condition is evaluated, it will create a compare on 2 bytes, while you actually want to have a word since the end variable is a word. 

A for next loop with an integer has an upper limit of 32766 and not 32767, the maximum value that fits into an integer.

This is done in order to save code space. Checking an overflow from 32767 to -32768 would cost extra code. 

There are also other alternatives. You can use a Do.. Loop for example :

```vb
Dim Var As Byte

Do

'code

```
Incr Var

Loop Until Var = 10

There are various way to get the result you need.

See also

[EXIT FOR](exit.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : for_next.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: FOR, NEXT

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte , B1 As Byte , C As Integer

For A = 1 To 10 Step 2

Print "This is A " ; A

Next A

Print "Now lets count down"

For C = 10 To -5 Step -1

Print "This is C " ; C

Next

Print "You can also nest FOR..NEXT statements."

For A = 1 To 10

Print "This is A " ; A

For B1 = 1 To 10

Print "This is B1 " ; B1

Next ' note that you do not have to specify the parameter

Next A

End

```

---

## FORMAT

Action

Formats a numeric string.

Syntax

target = FORMAT(source, "mask")

Remarks

target | The string that is assigned with the formatted string.  
---|---  
source | The source string that holds the number.  
mask | The mask for formatting the string. When spaces are in the mask, leading spaces will be added when the length of the mask is longer than the source string. " " '8 spaces when source is "123" it will be " 123". When a + is in the mask (after the spaces) a leading + will be assigned when the number does not start with the - (minus) sign. "+" with number "123" will be "+123". When zero's are provided in the mask, the string will be filled with leading zero's. " +00000" with 123 will become " +00123" An optional decimal point can be inserted too: "000.00" will format the number 123 to "001.23" Combinations can be made but the order must be : spaces, + , 0 an optional point and zero's. In version 2080 the mask may be a variable as well.  
  
When you do not want to use the overhead of the single or double, you can use the LONG. You can scale the value by a factor for example 100.

```vb
Then use FORMAT to show the value.

For example : 

Dim L as Long, X as Long , Res as Long

```
L = 1

X = 2

Res = L / X

```vb
' Now this would result in 0 because an integer or Long does not support floating point.

' But when you scale L with a factor 100, you get :

```
L = 100

X = 2

Res = L / X '50

Now Res will be 50. To show it the proper way we can use FORMAT. Format works with strings so the variables need to be converted to string first.

```vb
Dim S1 as string * 16 : s1 = Str(Res)

Print Format(s1,"000.00")

```
See also

[FUSING](fusing.md) , [STR](str.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : format.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : FORMAT

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As String * 10

Dim I As Integer

```
S = "12345"

S = Format(s , "+")

Print S ' +12345

S = "123"

S = Format(s , "00000") 

Print S ' 00123

S = "12345"

S = Format(s , "000.00")

Print S ' 123.45

S = "12345"

S = Format(s , "+000.00")

```vb
Print S ' +123.45

End

```

---

## FOURTHLINE

Action

Set LCD cursor to the start of the fourth line.

Syntax

FOURTHLINE

Remarks

Only valid for LCD displays with 4 lines.

See also

[HOME](home.md) , [UPPERLINE](upperline.md) , [LOWERLINE](lowerline.md) , [THIRDLINE](thirdline.md), [LOCATE](locate.md)

Example

Thirdline

Lcd "Line 3"

Fourthline

Lcd "Line 4"

Home Third 'goto home on line three

Home Fourth

Home F  'first letter also works

---

## FP_TRIG

The FP_TRIG library is written by Josef Franz VÃ¶gel.

All trig functions are stored in fp_trig.lib library.

The fp_trig.lbx contains the compiled object code and is used by BASCOM.

This sample demonstrates all the functions from the library:

```vb
'-----------------------------------------------------------------------------------------

'name : test_fptrig2.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstates FP trig library from Josef Franz VÃ¶gel

'micro : Mega8515

'suited for demo : no

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m8515.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S1 As Single , S2 As Single , S3 As Single , S4 As Single , S5 As Single , S6 As Single

Dim Vcos As Single , Vsin As Single , Vtan As Single , Vatan As Single , S7 As Single

Dim Wi As Single , B1 As Byte

Dim Ms1 As Single

```
Const Pi = 3.14159265358979

'calculate PI

Ms1 = Atn(1) * 4

Testing_power:

```vb
Print "Testing Power X ^ Y"

Print "X Y x^Y"

For S1 = 0.25 To 14 Step 0.25

```
S2 = S1 \ 2

S3 = Power(s1 , S2)

```vb
Print S1 ; " ^ " ; S2 ; " = " ; S3

Next

Print : Print : Print

```
Testing_exp_log:

```vb
Print "Testing EXP and LOG"

Print "x exp(x) log([exp(x)]) Error-abs Error-rel"

Print "Error is for calculating exp and back with log together"

For S1 = -88 To 88

```
S2 = Exp(s1)

S3 = Log(s2)

S4 = S3 - S1

S5 = S4 \ S1

```vb
Print S1 ; " " ; S2 ; " " ; S3 ; " " ; S4 ; " " ; S5 ; " " ;

Print

Next

Print : Print : Print

```
Testing_trig:

```vb
Print "Testing COS, SIN and TAN"

Print "Angle Degree Angle Radiant Cos Sin Tan"

For Wi = -48 To 48

```
S1 = Wi * 15

S2 = Deg2rad(s1)

Vcos = Cos(s2)

Vsin = Sin(s2)

Vtan = Tan(s2)

```vb
Print S1 ; " " ; S2 ; " " ; Vcos ; " " ; Vsin ; " " ; Vtan

Next

Print : Print : Print

```
Testing_atan:

```vb
Print "Testing Arctan"

Print "X atan in Radiant, Degree"

```
S1 = 1 / 1024

Do

S2 = Atn(s1)

S3 = Rad2deg(s2)

Print S1 ; " " ; S2 ; " " ; S3

S1 = S1 * 2

```vb
If S1 > 1000000 Then

Exit Do

End If

Loop

Print : Print : Print

```
Testing_int_fract:

```vb
Print "Testing Int und Fract of Single"

Print "Value Int Frac"

```
S2 = Pi \ 10

For S1 = 1 To 8

S3 = Int(s2)

S4 = Frac(s2)

Print S2 ; " " ; S3 ; " " ; S4

S2 = S2 * 10

```vb
Next

Print : Print : Print

Print "Testing degree - radiant - degree converting"

Print "Degree Radiant Degree Diff-abs rel"

For S1 = 0 To 90

```
S2 = Deg2rad(s1)

S3 = Rad2deg(s2)

S4 = S3 - S1

S5 = S4 \ S1

```vb
Print S1 ; " " ; S2 ; " " ; S3 ; " " ; S4 ; " " ; S5

Next

```
Testing_hyperbolicus:

```vb
Print : Print : Print

Print "Testing SINH, COSH and TANH"

Print "X sinh(x) cosh(x) tanh(x)"

For S1 = -20 To 20

```
S3 = Sinh(s1)

S2 = Cosh(s1)

S4 = Tanh(s1)

```vb
Print S1 ; " " ; S3 ; " " ; S2 ; " " ; S4

Next

Print : Print : Print

```
Testing_log10:

```vb
Print "Testing LOG10"

Print "X log10(x)"

```
S1 = 0.01

S2 = Log10(s1)

Print S1 ; " " ; S2

S1 = 0.1

S2 = Log10(s1)

```vb
Print S1 ; " " ; S2

For S1 = 1 To 100

```
S2 = Log10(s1)

```vb
Print S1 ; " " ; S2

Next

Print : Print : Print

'test MOD on FP

```
S1 = 10000

S2 = 3

S3 = S1 Mod S2

```vb
Print S3

Print "Testing_SQR-Single"

For S1 = -1 To 4 Step 0.0625

```
S2 = Sqr(s1)

```vb
Print S1 ; " " ; S2

Next

Print

For S1 = 1000000 To 1000100

```
S2 = Sqr(s1)

```vb
Print S1 ; " " ; S2

Next

```
Testing_atn2:

```vb
Print "Testing Sin / Cos / ATN2 / Deg2Rad / Rad2Deg / Round"

Print "X[deg] X[Rad] Sin(x) Cos(x) Atn2 Deg of Atn2 Rounded"

For S1 = -180 To 180 Step 5

```
S2 = Deg2rad(s1)

S3 = Sin(s2)

S4 = Cos(s2)

S5 = Atn2(s3 , S4)

S6 = Rad2deg(s5)

S7 = Round(s6)

```vb
Print S1 ; " " ; S2 ; " " ; S3 ; " " ; S4 ; " " ; S5 ; " " ; S6 ; " " ; S7

Next

Print "note: -180Â° is equivalent to +180Â°"

Print

```
Testing_asin_acos:

```vb
Print "Testing ASIN, ACOS"

Print "X asin(x) acos(x)"

For S1 = -1.125 To 1.125 Step 0.0625

```
S2 = Asin(s1)

S3 = Acos(s1)

```vb
Print S1 ; " " ; S2 ; " " ; S3

Next

Print "Note: > 1.0 and < -1.0 are invalid and shown here for error handling"

```
Testing_shift:

S1 = 12

For B1 = 1 To 20

S2 = S1 : S3 = S1

Shift S2 , Left , B1

Shift S3 , Right , B1

```vb
Print S1 ; " " ; S2 ; " " ; S3

Next

Print "End of testing"

End

```
![btn_Back](btn_back.gif)

---

## FRAC

Action

Returns the fraction of a single.

Syntax

var = FRAC( single )

Remarks

var | A numeric single variable that is assigned with the fraction of variable single.  
---|---  
single | The single variable to get the fraction of.  
  
The fraction is the right side after the decimal point of a single.

See Also

[INT](int.md)

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates FRAC function

'-------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 40 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim X As Single

```
X = 1.123456

```vb
Print X

Print Frac(x)

End

```

---

## FREEFILE

Action

Returns a free Filenumber.

Syntax

bFileNumber = FREEFILE()

Remarks

bFileNumber | A byte variable , which can be used for opening next file  
---|---  
  
This function gives you a free file number, which can be used for file â opening statements. In contrast to VB this file numbers start with 128 and goes up to 255. Use range 1 to 127 for user defined file numbers to avoid file number conflicts with the system numbers from FreeFile()

This function is implemented for compatility with VB.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _GetFreeFileNumber |   
---|---|---  
Input | none |   
Output | r24: Filenumber | r25: Errorcode  
| C-Flag: Set on Error |   
  
Partial Example

Ff =Freefile() ' get file handle

Open"test.txt" For Input As #ff ' we can use a constant for the file too

```vb
Print Lof(#ff);" length of file"

Print Fileattr(#ff);" file mode" ' should be 1 for input

Do

```
LineInput #ff , S ' read a line

```vb
' line input is used to read a line of text from a file

Print S ' print on terminal emulator

Loop UntilEof(ff)<> 0

'The EOF() function returns a non-zero number when the end of the file is reached

'This way we know that there is no more data we can read

```
Close #ff

---

## FUSING

Action

FUSING returns a formatted string of a single value.

Syntax

target = FUSING(source, "mask")

Remarks

target | The string that is assigned with the formatted string.  
---|---  
source | The source variable of the type SINGLE that will be converted  
mask | The mask for formatting the string. The mask is a string constant that always must start with #. After the decimal point you can provide the number of digits you want the string to have: #.### will give a result like 123.456. Rounding is used when you use the # sign. So 123.4567 will be converted into 123.457 When no rounding must be performed, you can use the & sign instead of the # sign. But only after the DP. #.&&& will result in 123.456 when the single has the value 123.4567  
  
When the single is zero, 0.0 will be returned, no matter how the mask is set up.

See also

[FORMAT](format.md) , [STR](str.md) , [CONFIG SINGLE](configsingle.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : fusing.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : FUSING

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As Single , Z As String * 10

'now assign a value to the single

```
S = 123.45678

'when using str() you can convert a numeric value into a string

Z = Str(s)

Print Z 'prints 123.456779477

Z = Fusing(s , "#.##")

```vb
'now use some formatting with 2 digits behind the decimal point with rounding

Print Fusing(s , "#.##") 'prints 123.46

'now use some formatting with 2 digits behind the decimal point without rounding

Print Fusing(s , "#.&&") 'prints 123.45

'The mask must start with #.

'It must have at least one # or & after the point.

'You may not mix & and # after the point.

End

```

---

## GET

Action

Reads a byte from the hardware or software UART.

Reads data from a file opened in BINARY mode.

Syntax UART

GET #channel, var

Syntax DOS

GET #channel, var

GET #channel, var , [pos] [, length]

Remarks

GET in combination with the software/hardware UART reads one byte from the UART. 

GET in combination with the AVR-DOS file system is very flexible and versatile. It works on files opened in BINARY mode and you can reads all data types.

#channel | A channel number, which identifies an opened file. This can be a hard coded constant or a variable.  
---|---  
Var | The variable or variable array that will be assigned with the data from the file  
Pos | This is an optional parameter that may be used to specify the position where the reading must start from. This must be a long variable.  
Length | This is an optional parameter that may be used to specify how many bytes must be read from the file.  
  
By default you only need to provide the variable name. When the variable is a byte, 1 byte will be read. When the variable is a word or integer, 2 bytes will be read. When the variable is a long or single, 4 bytes will be read. When the variable is a string, the number of bytes that will be read is equal to the dimensioned size of the string. DIM S as string * 10 , would read 10 bytes.

Note that when you specify the length for a string, the maximum length is 254. The maximum length for a non-string array is 65535.

In BASCOM-8051, GET was implemented to read only from the UART. While BASCOM-AVR supports GET for the UART, its primary purpose is to read from files with AVR-DOS. For the UART, GET is limited to read 1 byte, just like WAITKEY. 

Partial Example :

GET #1 , var ,,2 ' read 2 bytes, start at current position

GET #1, var , PS ' start at position stored in long PS

GET #1, var , PS, 2 ' start at position stored in long PS and read 2 bytes

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

current position | goto new position first  
---|---  
Byte: |   
_FileGetRange_1 Input: r24: File number X: Pointer to variable T-Flag cleared | _FileGetRange_1 Input: r24: File number X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
Word/Integer: |   
_FileGetRange_2 Input: r24: File number X: Pointer to variable T-Flag cleared | _FileGetRange_2 Input: r24: File number X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
Long/Single: |   
_FileGetRange_4 Input: r24: File number X: Pointer to variable T-Flag cleared | _FileGetRange_4 Input: r24: File number X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
String (<= 255 Bytes) with fixed length |   
_FileGetRange_Bytes Input: r24: File number r20: Count of Bytes X: Pointer to variable T-Flag cleared | _FileGetRange_Bytes Input: r24: File number r20: Count of bytes X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
Array (> 255 Bytes) with fixed length |   
_FileGetRange Input: r24: File number r20/21: Count of Bytes X: Pointer to variable T-Flag cleared | _FileGetRange Input: r24: File number r20/21: Count of bytes X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
  
Output from all kind of usage:

r25: Error Code

C-Flag on Error

X: requested info

Partial Example

```vb
'for the binary file demo we need some variables of different types

Dim B As Byte , W As Word , L As Long , Sn As Single , Ltemp As Long

Dim Stxt As String * 10

```
B = 1 : W = 50000 : L = 12345678 : Sn = 123.45 : Stxt = "test"

'open the file in BINARY mode

Open "test.biN"for Binary As #2

Put#2 , B ' write a byte

Put#2 , W ' write a word

Put#2 , L ' write a long

Ltemp = Loc(#2) + 1 ' get the position of the next byte

```vb
Print Ltemp ; " LOC" ' store the location of the file pointer

Print Seek(#2) ; " = LOC+1"

Print Lof(#2) ; " length of file"

Print Fileattr(#2) ; " file mode" ' should be 32 for binary

```
Put #2 , Sn ' write a single

Put #2 , Stxt ' write a string

Flush #2 ' flush to disk

Close #2

'now open the file again and write only the single

Open "test.bin" For Binary As #2

L = 1 'specify the file position

B = Seek(#2 , L) ' reset is the same as using SEEK #2,L

Get#2 , B ' get the byte

Get#2 , W ' get the word

Get#2 , L ' get the long

Get#2 , Sn ' get the single

Get#2 , Stxt ' get the string

Close #2

---

## GETADC

Action

Retrieves the analog value from the specified channel.

Syntax

var = GETADC(channel [,offset])

Syntax Xmega

var = GETADC( ADC , channel [,MUX])

Syntax Xtiny

var = GETADC()

var = GETADC(channel)

var = GETADC(ADC , channel)

Remarks AVR

Var | The variable that is assigned with the A/D value. This should be a Word or other 16 bit variable.  
---|---  
Channel | The channel to measure. This is actual the MUX value that will be used. Most older chips with A/D converter only have 8 channels with singled ended input. Here you would use values from 0-7. Newer chips like the ATMEGA2560 have multiple modes. A MUX value of 0-7 would use single ended input mode and would read ADC0-ADC7. But a value from 8-15 would select differential mode using ADC0-ADC3 with different gain factors. Please have a look in the data sheet to see how the channel value translates into the mode and channel. It is different for most chips.  
Offset | An optional numeric variable of constant that specifies gain or mode. This option has effect on newer AVR microâs only. The offset will be added to the channel value and inserted into the ADMUX register. This way you can control gain.  
  
Remarks XMEGA

var | The variable that is assigned with the A/D value. This should be a Word or other 16 bit variable.  
---|---  
ADC | The ADC to use. This is either ADCA or ADCB.  
Channel | The channel to use. There are 4 channels in the range from 0-3.  
MUX | An optional numeric variable or constant that specifies the MUX value thus which input pin is used for the measurement. The MUX number is coded with negative and positive input pin info. The positive pins are have an offset of 8. So PIN0 in single ended mode would need a value of 8. When you do not supply the mux value, the value used by the CONFIG ADC command will be used. If you supply it, it will change the MUX register of the corresponding channel.  
  
Remarks Xtiny

var | The variable that is assigned with the A/D value. This should be a Word or other 16 bit variable.  
---|---  
ADC | The ADC to use. This is either ADC0 or ADC1.  
Channel | The channel to use. This value depends on the processor. Some channel values access the internal reference or temperature sensor. This value will set the MUX register. When there is no channel provided the current MUX setting will be used. When you define a constant named _adc_kelvin reading the internal temp sensor will return the result in Kelvin.  The value of _adc_kelvin is not important. When you include this constant, the ADC routine will check if the internal temperature sensor is read. If so, the result is compensated with the temp gain and offset. To convert Kelvin to Celsius you can subtract 273.15 from the result.   
  
Note:

It is the users responsibility to check the Channel values are in range.

Please check and consult your Microcontroller Datasheet.

The GETADC() function only will work on microprocessors that have an A/D converter.

The pins of the A/D converter input can be used for digital I/O too.

But it is important that no I/O switching is done while using the A/D converter.

NORMAL AVR

Make sure you turn on the AD converter with the [START](start.md) ADC statement or by setting the proper bit in the ADC configuration register.

Some microâs have more then 7 channels. This is supported as well. The ADCSRB register contains a bit named MUX5 that must be set when a channel higher then 7 is used. The compiler will handle this automatic. This is true for new chips like Mega1280, Mega2560 and probably other new chips with 100 pins.

An example on how to read singled ended input on a Mega1280:

W = Getadc(0, 32) ' from data sheet : 100000 ADC8

W = Getadc(1, 32) ' from data sheet : 100001 ADC9

This will read channel 0 and 1. The offset is 32 in order to use singled ended input. 

ADC8 is portK.0

Without the offset, you need to provide the proper value for the channel.

So GetADC(0,32) would become : GetADC(32)

And GetADC(1,32) would become : GetADC(33)

GetADC() returns a word variable since the A/D converter data registers consist of 2 registers. The resolution depends on the chip.

The variable ADCD can be used to access the data register directly. The compiler will handle access to the byte registers automatically.

See also

[CONFIG ADC](config_adc.md) , [CONFIG ADCA](config_adca.md) , [CONFIG ADC0](config_adc0_adcx.md)

Example

```vb
'--------------------------------------------------------------------------------

'name : adc.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstration of GETADC() function for 8535 or M163 micro

'micro : Mega163

'suited for demo : yes

'commercial addon needed : no

'use in simulator : possible

' Getadc() will also work for other AVR chips that have an ADC converter

'--------------------------------------------------------------------------------

$regfile = "m163def.dat" ' we use the M163

$crystal = 4000000

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 'default use 10 for the SW stack

$framesize = 40 'default use 40 for the frame space

'configure single mode and auto prescaler setting

'The single mode must be used with the GETADC() function

'The prescaler divides the internal clock by 2,4,8,16,32,64 or 128

'Because the ADC needs a clock from 50-200 KHz

'The AUTO feature, will select the highest clockrate possible

Config Adc = Single , Prescaler = Auto

'Now give power to the chip

```
Start Adc

```vb
'With STOP ADC, you can remove the power from the chip

'Stop Adc

Dim W As Word , Channel As Byte

```
Channel = 0

```vb
'now read A/D value from channel 0

Do

```
W = Getadc(channel)

Print "Channel " ; Channel ; " value " ; W

Incr Channel

```vb
If Channel > 7 Then Channel = 0

Loop

End

'The new M163 has options for the reference voltage

'For this chip you can use the additional param :

'Config Adc = Single , Prescaler = Auto, Reference = Internal

'The reference param may be :

'OFF : AREF, internal reference turned off

'AVCC : AVCC, with external capacitor at AREF pin

'INTERNAL : Internal 2.56 voltage reference with external capacitor ar AREF pin

'Using the additional param on chip that do not have the internal reference will have no effect.

```
Example Xmega

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' xm128-ADC.bas  
' This sample demonstrates the Xmega128A1 ADC  
'-----------------------------------------------------------------  
  
$regfile = "xm128a1def.dat"  
$crystal = 32000000  
$hwstack = 64  
$swstack = 64  
$framesize = 64  
  
  
'First Enable The Osc Of Your Choice  
Config Osc = Enabled , 32mhzosc = Enabled  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1  
  
Config Com1 = 19200 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
  
Print "ADC test"  
  
'setup the ADC-A converter  
Config Adca = Single , Convmode = Unsigned , Resolution = 12bit , Dma = Off , Reference = Int1v , Event_mode = None , Prescaler = 32 , Ch0_gain = 1 , Ch0_inp = Single_ended , Mux0 = &B000_00 _  
```
Ch1_gain = 1 , Ch1_inp = Single_ended , Mux1 = &B1_000 , Ch2_gain = 1 , Ch2_inp = Single_ended , Mux2 = &B10_000 , Ch3_gain = 1 , Ch3_inp = Single_ended , Mux3 = &B11_000  
  
```vb
Dim W As Word , I As Byte , Mux As Byte  
Do  
```
Mux = I * 8 ' or you can use shift left,3 to get the proper offset  
W = Getadc(adca , 0 , Mux)  
```vb
' W = Getadc(adca , 0) 'when not using the MUX parameter the last value of the MUX will be used!  
' use ADCA , use channel 0, and use the pinA.0-pinA.3  
Print "RES:" ; I ; "-" ; W  
```
Incr I  
```vb
If I > 3 Then I = 0  
Waitms 500  
Loop Until Inkey(#1) = 27

```
Example Xtiny

```vb
'--------------------------------------------------------------------------------  
'name : adc.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demonstrates ADC and DAC. Notice that DAC is not available on all processors  
'micro : xtiny816  
'suited for demo : no  
'commercial addon needed : yes  
'--------------------------------------------------------------------------------  
$regfile = "atXtiny816.dat"  
$crystal = 20000000  
$hwstack = 16  
$swstack = 16  
$framesize = 24  
  
'set the system clock and prescaler  
Config Sysclock = 20mhz , Prescale = 1  
  
'configure the USART  
Config Com1 = 115200 , Mode = Asynchroneous , Parity = None , Databits = 8 , Stopbits = 1  
  
'configure the internal reference to be 1v1 for both the ADC and the DAC  
Config Vref = Dummy , Adc0 = 1v1 , Dac0 = 1v1  
  
'configure the ADC0 to read the DAC  
Config Adc0 = Single , Resolution = 10bit , Adc = Enabled , Reference = Internal , Prescaler = 32 , Sample_len = 1 , Sample_cap = Above_1v , Init_delay = 32 , Mux = Dac0  
  
'configure the DAC. We do not output the signal on a port pin otherwise out_enable would be required too  
Config Dac0 = Enabled  
  
'dimension a variable  
Dim W As Word , B As Byte  
  
Print "Test ADC"  
  
'set the DAC to halve the output which would be halve of 1.1V which is 0.55V  
```
Dac0_data = 127  
  
```vb
Do  
'when getadc() does not have parameters, it will use the current mux setting  
'other options are : getadc(channel) and getadc(adc0 | adc1 , channel)  
```
W = Getadc() : Print "W:" ; W  
```vb
'output should be 512  
Waitms 1000  
```
Incr B  
```vb
Loop Until B = 3  
  
'now read the internal temp sensor  
```
Const _adc_kelvin = 1  
Do  
W = Getadc(&H1e) 'get internal temp sensor value  
```vb
Print W 'this is in KELVIN  
'to adjust to Celsius, sub 273.15  
Waitms 1000  
Loop  
  
End

```

---

## GETATKBD

Action

Reads a key from a PC AT keyboard.

Syntax

var = GETATKBD()

Remarks

var | The variable that is assigned with the key read from the keyboard. It may be a byte or a string variable. When no key is pressed a 0 will be returned.  
---|---  
  
The GETAKBD() function needs 2 input pins and a translation table for the keys. You can read more about this at the [CONFIG KEYBOARD](config_keyboard.md) compiler directive.

The Getatkbd function will wait for a pressed key. When you want to escape from the waiting loop you can set the ERR bit from an interrupt routine for example.

Getatkbd is using 2 bits from register R6 : bit 4 and 5 are used to hold the shift and control key status.

AT KEYBOARD SCANCODES

Table reprinted with permission of Adam Chapweske

http://panda.cs.ndsu.nodak.edu/~achapwes

KEY | MAKE | BREAK |  | KEY | MAKE | BREAK |  | KEY | MAKE | BREAK  
---|---|---|---|---|---|---|---|---|---|---  
A | 1C | F0,1C |  | 9 | 46 | F0,46 |  | [ | 54 | FO,54  
B | 32 | F0,32 |  | ` | 0E | F0,0E |  | INSERT | E0,70 | E0,F0,70  
C | 21 | F0,21 |  | - | 4E | F0,4E |  | HOME | E0,6C | E0,F0,6C  
D | 23 | F0,23 |  | = | 55 | FO,55 |  | PG UP | E0,7D | E0,F0,7D  
E | 24 | F0,24 |  | \ | 5D | F0,5D |  | DELETE | E0,71 | E0,F0,71  
F | 2B | F0,2B |  | BKSP | 66 | F0,66 |  | END | E0,69 | E0,F0,69  
G | 34 | F0,34 |  | SPACE | 29 | F0,29 |  | PG DN | E0,7A | E0,F0,7A  
H | 33 | F0,33 |  | TAB | 0D | F0,0D |  | U ARROW | E0,75 | E0,F0,75  
I | 43 | F0,43 |  | CAPS | 58 | F0,58 |  | L ARROW | E0,6B | E0,F0,6B  
J | 3B | F0,3B |  | L SHFT | 12 | FO,12 |  | D ARROW | E0,72 | E0,F0,72  
K | 42 | F0,42 |  | L CTRL | 14 | FO,14 |  | R ARROW | E0,74 | E0,F0,74  
L | 4B | F0,4B |  | L GUI | E0,1F | E0,F0,1F |  | NUM | 77 | F0,77  
M | 3A | F0,3A |  | L ALT | 11 | F0,11 |  | KP / | E0,4A | E0,F0,4A  
N | 31 | F0,31 |  | R SHFT | 59 | F0,59 |  | KP * | 7C | F0,7C  
O | 44 | F0,44 |  | R CTRL | E0,14 | E0,F0,14 |  | KP - | 7B | F0,7B  
P | 4D | F0,4D |  | R GUI | E0,27 | E0,F0,27 |  | KP + | 79 | F0,79  
Q | 15 | F0,15 |  | R ALT | E0,11 | E0,F0,11 |  | KP EN | E0,5A | E0,F0,5A  
R | 2D | F0,2D |  | APPS | E0,2F | E0,F0,2F |  | KP . | 71 | F0,71  
S | 1B | F0,1B |  | ENTER | 5A | F0,5A |  | KP 0 | 70 | F0,70  
T | 2C | F0,2C |  | ESC | 76 | F0,76 |  | KP 1 | 69 | F0,69  
U | 3C | F0,3C |  | F1 | 05 | F0,05 |  | KP 2 | 72 | F0,72  
V | 2A | F0,2A |  | F2 | 06 | F0,06 |  | KP 3 | 7A | F0,7A  
W | 1D | F0,1D |  | F3 | 04 | F0,04 |  | KP 4 | 6B | F0,6B  
X | 22 | F0,22 |  | F4 | 0C | F0,0C |  | KP 5 | 73 | F0,73  
Y | 35 | F0,35 |  | F5 | 03 | F0,03 |  | KP 6 | 74 | F0,74  
Z | 1A | F0,1A |  | F6 | 0B | F0,0B |  | KP 7 | 6C | F0,6C  
0 | 45 | F0,45 |  | F7 | 83 | F0,83 |  | KP 8 | 75 | F0,75  
1 | 16 | F0,16 |  | F8 | 0A | F0,0A |  | KP 9 | 7D | F0,7D  
2 | 1E | F0,1E |  | F9 | 01 | F0,01 |  | ] | 5B | F0,5B  
3 | 26 | F0,26 |  | F10 | 09 | F0,09 |  | ; | 4C | F0,4C  
4 | 25 | F0,25 |  | F11 | 78 | F0,78 |  | ' | 52 | F0,52  
5 | 2E | F0,2E |  | F12 | 07 | F0,07 |  | , | 41 | F0,41  
6 | 36 | F0,36 |  | PRNT SCRN | E0,12, E0,7C | E0,F0, 7C,E0, F0,12 |  | . | 49 | F0,49  
7 | 3D | F0,3D |  | SCROLL | 7E | F0,7E |  | / | 4A | F0,4A  
8 | 3E | F0,3E |  | PAUSE | E1,14,77, E1,F0,14, F0,77 | -NONE- |  |  |  |   
  
These are the usable scan codes from the keyboard. If you want to implement F1 , you look at the generated scan code : 05 hex. So in the table, at position 5+1=6, you write the value for F1.

In the sample program below, you can find the value 200. When you now press F1, the value form the table will be used so 200 will be returned.

See also

[CONFIG KEYBOARD](config_keyboard.md) , [GETATKBDRAW](getatkbdraw.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : getatkbd.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : PC AT-KEYBOARD Sample

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "8535def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'For this example :

'connect PC AT keyboard clock to PIND.2 on the 8535

'connect PC AT keyboard data to PIND.4 on the 8535

'The GetATKBD() function does not use an interrupt.

'But it waits until a key was pressed!

'configure the pins to use for the clock and data

'can be any pin that can serve as an input

'Keydata is the label of the key translation table

Config Keyboard = Pind.2 , Data = Pind.4 , Keydata = Keydata

'Dim some used variables

Dim S As String * 12

Dim B As Byte

'In this example we use SERIAL(COM) INPUT redirection

$serialinput = Kbdinput

'Show the program is running

Print "hello"

Do

'The following code is remarked but show how to use the GetATKBD() function

' B = Getatkbd() 'get a byte and store it into byte variable

'When no real key is pressed the result is 0

'So test if the result was > 0

' If B > 0 Then

' Print B ; Chr(b)

' End If

'The purpose of this sample was how to use a PC AT keyboard

'The input that normally comes from the serial port is redirected to the

'external keyboard so you use it to type

Input "Name " , S

'and show the result

Print S

'now wait for the F1 key , we defined the number 200 for F1 in the table

Do

```
B = Getatkbd()

```vb
Loop Until B <> 0

Print B

Loop

End

'Since we do a redirection we call the routine from the redirection routine

'

```
Kbdinput:

```vb
'we come here when input is required from the COM port

'So we pass the key into R24 with the GetATkbd function

' We need some ASM code to save the registers used by the function

$asm

```
push r16 ; save used register

push r25

push r26

push r27

Kbdinput1:

rCall _getatkbd ; call the function

tst r24 ; check for zero

breq Kbdinput1 ; yes so try again

pop r27 ; we got a valid key so restore registers

pop r26

pop r25

pop r16

```vb
$end Asm

'just return

Return

'The tricky part is that you MUST include a normal call to the routine

'otherwise you get an error

'This is no clean solution and will be changed

```
B = Getatkbd()

'This is the key translation table

Keydata:

'normal keys lower case

Data 0 , 0 , 0 , 0 , 0 , 200 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , &H5E , 0

Data 0 , 0 , 0 , 0 , 0 , 113 , 49 , 0 , 0 , 0 , 122 , 115 , 97 , 119 , 50 , 0

Data 0 , 99 , 120 , 100 , 101 , 52 , 51 , 0 , 0 , 32 , 118 , 102 , 116 , 114 , 53 , 0

Data 0 , 110 , 98 , 104 , 103 , 121 , 54 , 7 , 8 , 44 , 109 , 106 , 117 , 55 , 56 , 0

Data 0 , 44 , 107 , 105 , 111 , 48 , 57 , 0 , 0 , 46 , 45 , 108 , 48 , 112 , 43 , 0

Data 0 , 0 , 0 , 0 , 0 , 92 , 0 , 0 , 0 , 0 , 13 , 0 , 0 , 92 , 0 , 0

Data 0 , 60 , 0 , 0 , 0 , 0 , 8 , 0 , 0 , 49 , 0 , 52 , 55 , 0 , 0 , 0

Data 48 , 44 , 50 , 53 , 54 , 56 , 0 , 0 , 0 , 43 , 51 , 45 , 42 , 57 , 0 , 0

'shifted keys UPPER case

Data 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0

Data 0 , 0 , 0 , 0 , 0 , 81 , 33 , 0 , 0 , 0 , 90 , 83 , 65 , 87 , 34 , 0

Data 0 , 67 , 88 , 68 , 69 , 0 , 35 , 0 , 0 , 32 , 86 , 70 , 84 , 82 , 37 , 0

Data 0 , 78 , 66 , 72 , 71 , 89 , 38 , 0 , 0 , 76 , 77 , 74 , 85 , 47 , 40 , 0

Data 0 , 59 , 75 , 73 , 79 , 61 , 41 , 0 , 0 , 58 , 95 , 76 , 48 , 80 , 63 , 0

Data 0 , 0 , 0 , 0 , 0 , 96 , 0 , 0 , 0 , 0 , 13 , 94 , 0 , 42 , 0 , 0

Data 0 , 62 , 0 , 0 , 0 , 8 , 0 , 0 , 49 , 0 , 52 , 55 , 0 , 0 , 0 , 0

Data 48 , 44 , 50 , 53 , 54 , 56 , 0 , 0 , 0 , 43 , 51 , 45 , 42 , 57 , 0 , 0

---

## GETATKBDRAW

Action

Reads a key from a PC AT keyboard.

Syntax

var = GETATKBDRAW()

Remarks

var | The variable that is assigned with the key read from the keyboard. It may be a byte or a string variable. When no key is pressed a 0 will be returned.  
---|---  
  
The GETATKBDRAW() function needs 2 input pins and a translation table for the keys. You can read more about this at the [CONFIG KEYBOARD](config_keyboard.md) compiler directive.

The GetatkbdRAW function will return RAW data from a PS/2 keyboard or Mouse.

While GetatKBD is intended to wait for pressed keys, GetATkbdRAW just returns raw PS/2 data so you can use your own code to process the data.

See Also

[GETATKBD](getatkbd.md) , [CONFIG KEYBOARD](config_keyboard.md)

Example

See GETATKBD.BAS

---

## GETATTR

Action

Returns the file Attribute.

Syntax

bFileAttribut = GETATTR([sFile])

Remarks

bFileAttribut | Numeric variable which is assigned with the file attribute.  
---|---  
sFile | The name of the file (no wildcard) to get the attribute from. You may also omit the name in which case the file will be used previous found by the DIR() function.  
  
This functions returns the DOS file attributes. A file can have multiple attributes.

Return value | DOS Attribute  
---|---  
1 | Read Only  
2 | Hidden  
4 | System File  
8 | Volume Label  
16 | Sub Directory  
32 | Archive  
64,128 | reserved  
  
A file could have an attribute of 3 (hidden+ read only).

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md), [WRITE](write.md) , [INPUT](input.md) , [FILEATTR](fileattr.md)

Partial Example

```vb
'open the file in BINARY mode

Print Getattr("somefile.bin")

```

---

## GETDSTPORT

Action

Returns the port number of the peer.

Syntax

Result = GETDSTPort( socket)

Remarks

Result | A WORD variable that is assigned with the port number of the peer or destination port number.  
---|---  
Socket | The socket number in the range from 0-3  
  
When you are in server mode, it might be desirable to detect the port number of the connecting client.

You can use this for logging, security, etc.

See also

[CONFIG TCPIP](config_tcpip.md), [GETSOCKET](getsocket.md) , [SOCKETCONNECT](socketconnect.md), [SOCKETSTAT](socketstat.md) , [TCPWRITE](tcpwrite.md), [TCPWRITESTR](tcpwritestr.md), [CLOSESOCKET](socketclose.md) , [SOCKETLISTEN](socketlisten.md) , [GETDSTIP](getdstip.md), [URL2IP](url2ip.md)

Example

```vb
'-----------------------------------------------------------------------------------------  
'name : servertest_TWI.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : start the easytcp after the chip is programmed  
' and create 2 connections  
'micro : Mega88  
'suited for demo : no  
'commercial addon needed : yes  
'-----------------------------------------------------------------------------------------  
  
$regfile = "m88def.dat" ' specify the used micro  
$crystal = 8000000 ' used crystal frequency  
$baud = 19200 ' use baud rate  
  
$hwstack = 128 ' default use 32 for the hardware stack  
$swstack = 128 ' default use 10 for the SW stack  
$framesize = 128 ' default use 40 for the frame space  
' xram access  
Print "Init , set IP to 192.168.1.70" ' display a message  
Enable Interrupts ' before we use config tcpip , we need to enable the interrupts  
Config Tcpip = Int1 , Mac = 12.128.12.34.56.78 , Ip = 192.168.1.70 , Submask = 255.255.255.0 , Gateway = 192.168.1.1 , Localport = 1000 , Tx = $55 , Rx = $55 , Chip = W5100 , Spi = 1  
  
  
Dim Bclient As Byte ' socket number  
Dim Idx As Byte  
Dim Result As Word , Result2 As Word ' result  
Dim S As String * 80  
Dim Flags As Byte  
Dim Peer As Long  
Dim L As Long  
  
  
Do  
Waitms 1000  
For Idx = 0 To 3  
```
Result = Socketstat(idx , 0) ' get status  
```vb
Select Case Result  
Case Sock_established  
If Flags.idx = 0 Then ' if we did not send a welcome message yet  
```
Flags.idx = 1  
Result = Tcpwrite(idx , "Hello from W3100A{013}{010}") ' send welcome  
End If  
Result = Socketstat(idx , Sel_recv) ' get number of bytes waiting  
```vb
Print "Received : " ; Result  
If Result > 0 Then  
Do  
Print "Result : " ; Result  
```
Result = Tcpread(idx , S)  
Print "Data from client: " ; Idx ; " " ; Result ; " " ; S  
Peer = Getdstip(idx)  
```vb
Print "Peer IP " ; Ip2str(peer)  
Print "Peer port : " ; Getdstport(idx)  
'you could analyse the string here and send an appropiate command  
'only exit is recognized  
If Lcase(s) = "exit" Then  
```
Closesocket Idx  
Elseif Lcase(s) = "time" Then  
Result2 = Tcpwrite(idx , "12:00:00{013}{010}")' you should send date$ or time$  
```vb
End If  
Loop Until Result = 0  
End If  
Case Sock_close_wait  
Print "close_wait"  
```
Closesocket Idx  
```vb
Case Sock_closed  
Print "closed"  
```
Bclient = Getsocket(idx , Sock_stream , 5000 , 64) ' get socket for server mode, specify port 5000  
Print "Socket " ; Idx ; " " ; Bclient  
  
Socketlisten Idx  
Print "Result " ; Result  
Flags.idx = 0 ' reset the hello message flag  
```vb
Case Sock_listen ' this is normal  
Case Else  
Print "Socket status : " ; Result  
End Select  
Next  
Loop  
  
  
  
End

```

---

## GETKBD

Action

Scans a 4x4 matrix keyboard and return the value of the key pressed.

Syntax

var = GETKBD()

Remarks

Var | The numeric variable that is assigned with the value read from the keyboard  
---|---  
  
The GETKBD() function can be attached to a port of the uP.

You can define the port with the CONFIG KBD statement.

A schematic for PORTB is shown below

![matrixkbd](matrixkbd.gif)

Note that the port pins can be used for other tasks as well. But you might need to set the port direction of those pins after you have used getkbd(). For example the LCD pins are set to output at the start of your program. A call to getkbd() would set the pins to input.

By setting DDR.x register you can set the pins to the proper state again.

As an alternative you can use CONFIG PIN or CONFIG PORT.

When no key is pressed 16 will be returned.

When using the 2 additional rows, 24 will be returned when no key is pressed.

On the STK200 this might not work since other hardware is connected too that interferes.

You can use the [Lookup()](lookup.md) function to convert the byte into another value. This because the GetKBD() function does not return the same value as the key pressed. It will depend on which keyboard you use.

Sometimes it can happen that it looks like a key is pressed while you do not press a key. This is caused by the scanning of the pins which happens at a very high frequency.

It will depend on the used keyboard. You can add series resistors with a value of 470-1K

The routine will wait for 100 mS by default after the code is retrieved. With CONFIG KBD you can set this delay.

See also

[CONFIG KBD](config_kbd.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : getkbd.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : GETKBD

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'specify which port must be used

'all 8 pins of the port are used

Config Kbd = Portb

'dimension a variable that receives the value of the pressed key

Dim B As Byte

'loop for ever

Do

```
B = Getkbd()

```vb
'look in the help file on how to connect the matrix keyboard

'when you simulate the getkbd() it is important that you press/click the keyboard button

' before running the getkbd() line !!!

Print B

'when no key is pressed 16 will be returned

'use the Lookup() function to translate the value to another one

' this because the returned value does not match the number on the keyboad

Loop

End

```

---

## GETRC

Action

Retrieves the value of a resistor or a capacitor.

Syntax

var = GETRC( pin , number )

Remarks

Var | The word variable that is assigned with the value.  
---|---  
Pin | The PIN name for the R/C is connection.  
Number | The port pin for the R/C is connection.  
  
The name of the input port (PIND for example) must be passed even when all the other pins are configured for output. The pin number must also be passed. This may be a constant or a variable.

A circuit is shown below:

![getrc](getrc.gif)

The capacitor is charged and the time it takes to discharge it is measured and stored in the variable. Now when you vary either the resistor or the capacitor, different values will be returned. This function is intended to return a relative position of a resistor wiper, not to return the value of the resistor. But with some calculations it can be retrieved.

The GETRC function passes the address of the PIN register to the _GETRC library code.

This will not work for PINF of the ATMEGA128. The PORTF, PINF, DDRF map is not continuous grouped together.

To solve this, you can use the $lib "getRc_m128_PINF.lib"

This lib is only for the M128/M64 PORTF, and when the compatibility fuse is not set to M103.

See also

NONE

Example

```vb
'-----------------------------------------------------------------------------------------

'name : getrc.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates how to get the value of a resistor

'micro : AT90S8535

'suited for demo : yes

'commercial addon needed : no

' The library also shows how to pass a variable for use with individual port

' pins. This is only possible in the AVR architecture and not in the 8051

'-----------------------------------------------------------------------------------------

$regfile = "8535def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'The function works by charging a capacitor and uncharge it little by little

'A word counter counts until the capacitor is uncharged.

'So the result is an indication of the position of a pot meter not the actual

'resistor value

'This example used the 8535 and a 10K ohm variable resistor connected to PIND.4

'The other side of the resistor is connected to a capacitor of 100nF.

'The other side of the capacitor is connected to ground.

'This is different than BASCOM-8051 GETRC! This because the architecture is different.

'The result of getrc() is a word so DIM one

Dim W As Word

Do

'the first parameter is the PIN register.

'the second parameter is the pin number the resistor/capacitor is connected to

'it could also be a variable!

```
W = Getrc(pind , 4)

```vb
Print W

Wait 1

Loop

```

---

## GETREG

Action

Reads a byte from an internal register.

Syntax

var = GETREG( Reg )

Remarks

Most AVR chips have 32 registers named R0-R31. The GetReg function will return the value of the specified register.

Reg | The register name : R0-R31 or a register definition.  
---|---  
Var | The name of a variable that will be assigned with the content of the register.  
  
PEEK and POKE work with an address. And will return a HW register on the Xmega since Xmega has a different address map.

GetReg and SetReg will read/write registers on all AVR processors.

![notice](notice.jpg)In version 2078, all internal registers (R0-R31) are made available as normal BYTE variables. This means that you can simply assign or read a register from basic : Rx=value.

This is more convenient than using SETREG and GETREG. 

See also

[SETREG](setreg.md), [PEEK](peek.md) , [POKE](poke.md)

Example

---

## Getting Started

During the Development of the Bascom FT800 library, the following FT800/LCD hardware was used:

Model | Company | LCD Type/Size | URL  
---|---|---|---  
Gameduino2 | excamera | 4.3" resistive touch display  | [excamera.com/sphinx/gameduino2](<http://excamera.com/sphinx/gameduino2/> "Gameduino2")  
4DLCD-FT843 | 4D Systems | 4.3" resistive touch display  | [www.4dsystems.com.au](<http://www.4dsystems.com.au/> "4D Systems")  
VM800C35A | FTDI | 3.5" resistive touch display | [www.ftdichip.com](<http://www.ftdichip.com/> "FTDI")  
VM800C43A | FTDI | 4.3" resistive touch display  | [www.ftdichip.com](<http://www.ftdichip.com/> "FTDI")  
VM800C50A | FTDI | 5.0" resistive touch display | [www.ftdichip.com](<http://www.ftdichip.com/> "FTDI")  
  
Minimum Microcontroller requirements would be ATMEGA328P or an Arduino.

These boards are very common and are good value for money for any beginner who wants to start learning.

```vb
For the Advanced or Professional it would be advisable to chose a micro with plenty of Flash (>32k). 

If using a microSD/SDHC (with AVR-DOS) a good start would be 4KB of SRAM (>2KB)

```
Have a look at the various [DEMO's](demos.md). The Help shows the output you should get.

---

## GOSUB

Action

Branch to and execute subroutine.

Syntax

GOSUB label

Remarks

Label | The name of the label where to branch to.  
---|---  
  
With GOSUB, your program jumps to the specified label, and continues execution at that label.

When it encounters a RETURN statement, program execution will continue after the GOSUB statement.

A GOSUB can not pass parameters, all it does is calling a label, execute it and returns.

So why use a GOSUB? Imagine you have a set of code you want to execute from different locations in your code.

While you can repeat the code, you can best write the code once, and call it using GOSUB.

Example :

```vb
if a = 1 Then

Gosub ABC

end if

if b =1 then

gosub ABC

End if

End

```
ABC:

print "this is label ABC"

a=a+1

```vb
RETURN

If A and B are both 1, the ABC label is called twice. 

Do notice the END statement which will make sure that the code does not execute the ABC label without an actual GOSUB. You can test in the simulator, and see what happens in you remark the END statement.

```
![notice](notice.jpg)Instead of using GOSUB, it is better to use a SUB procedure with a CALL. A SUB module can have local variables and you can pass parameters. 

See also

[GOTO](goto.md) , [CALL](call.md) , [RETURN](return.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : gosub.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: GOTO, GOSUB and RETURN

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Goto Continue

Print "This code will not be executed"

```
Continue: 'end a label with a colon

```vb
Print "We will start execution here"

Gosub Routine

Print "Back from Routine"

End

```
Routine: 'start a subroutine

```vb
Print "This will be executed"

Return 'return from subroutine

```

---

## GOTO

Action

Jump to the specified label or address.

Syntax

GOTO label

Remarks

Labels can be up to 32 characters long.

When you use duplicate labels, the compiler will give you a warning.

Valid labels

\- A valid label ends with a colon (:)

\- A valid label starts on the line. 

\- There is no space between the label name and the colon. 

Label: is a valid label. 

Label : is invalid

Since a colon is also used to separate multiple lines of code, the label must be the only code on the line. 

```vb
For example :

print "abc" : print "klm" 'these lines are separated by a colon. 

```
abc: : print "klm" 'this is invalid since the line starts with a label.

Besides using a label you can also specify an address. GOTO &H0000 would jump to the reset vector of the processor.

Because numeric addresses can be specified, it is advised to use non-numerical labels. 

Notice that an address in the AVR is a WORD address. AVR instructions are 16 bit wide which means that for each instruction you need at least 2 bytes.

It is best to use label names.

See also

[GOSUB](gosub.md)

Example

Dim A As Byte

Start: ' a label must end with a colon

A = A + 1 ' increment a

```vb
If A < 10 Then ' is it less than 10?

Goto Start ' do it again

End If ' close IF

Print "Ready" ' that is it

```

---

## GRAY2BIN

Action

Returns the numeric value of a Gray code.

Syntax

var1 = GRAY2BIN(var2)

Remarks

var1 | Variable that will be assigned with the binary value of the Grey code.  
---|---  
var2 | A variable in Grey format that will be converted.  
  
Gray code is used for rotary encoders. Gray2bin() works for byte, integer, word and long variables.

See also

[BIN2GRAY](bin2gray.md)

ASM

Depending on the data type of the target variable the following routine will be called from mcs.lbx:

_Bin2grey for bytes , _Bin2Grey2 for integer/word and _Bin2grey4 for longs.

Example

```vb
'-----------------------------------------------------------------------------------------

'name : graycode.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : show the Bin2Gray and Gray2Bin functions

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'Bin2Gray() converts a byte,integer,word or long into grey code.

'Gray2Bin() converts a gray code into a binary value

Dim B As Byte ' could be word,integer or long too

Print "BIN" ; Spc(8) ; "GREY"

For B = 0 To 15

Print B ; Spc(10) ; Bin2gray(b)

Next

Print "GREY" ; Spc(8) ; "BIN"

For B = 0 To 15

Print B ; Spc(10) ; Gray2bin(b)

Next

End

```

---

## Help Knowledge Base

This option will ask you to enter a search string.

![help_kb](help_kb.jpg)

This search string will be passed to the MCS support site.

The above example that searches for "FUSEBIT" will result in the following :

![help_kb_result](help_kb_result.jpg)

You can click one of the found articles to read it.

---

## Help Support

This option will start your default browser with the following URL :

<http://www.mcselec.com/support-center/>

It depends from your browser settings if a new window or TAB will be created.

At the support site you can browse articles. You can also search on keywords.

---

## HEX

Action

Returns a string representation of a hexadecimal number.

Syntax

var = HEX( x )

Remarks

var | A string variable.  
---|---  
X | A numeric variable of data type Byte, Integer, Word, Long, Single or Double.  
  
See also

[HEXVAL](hexval.md) , [VAL](val.md) , [STR](str.md) , [BIN](bin.md) , [BINVAL](binval.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim B As Byte , J As Integer , W As Word , L As Long

```
B = 1 : J = &HF001

W = &HF001

L = W

```vb
Print B ; Spc(3) ; Hex(b)

Print J ; Spc(3) ; Hex(j)

Print W ; Spc(3) ; Hex(w)

Print L ; Spc(3) ; Hex(l)

End

```

---

## HEXVAL

Action

Convert string representing a hexadecimal number into a numeric variable.

Syntax

var = HEXVAL( x )

Remarks

Var | The numeric variable that must be assigned.  
---|---  
X | The hexadecimal string that must be converted.  
  
In VB you can use the VAL() function to convert hexadecimal strings.

But since that would require an extra test for the leading &H signs that are required in VB, a separate function was designed.

The data may only contain hex decimal characters : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,a,b,c,d,e,f. Other data will lead to conversion errors. If you need spaces to be filtered you can use the alternative library named hexval.lbx

Include it to your code with $LIB "hexval.lbx" and the conversion routine from this library will be used instead of the one from mcs.lbx. The alternative library will also set the ERR flag if an illegal character is found.

See also

[HEX](hex.md) , [VAL](val.md) , [STR](str.md) , [BIN](bin.md) , [BINVAL](binval.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim L As Long

Dim S As String * 8

Do

Input "Hex value " , S

```
L = Hexval(s)

```vb
Print L ; Spc(3) ; Hex(l)

Loop

```

---

## HEXVAL

The HEXVAL library contains an enhanced version of the HEXVAL code. The library was made by MWS.

The default HEXVAL function does not ignore spaces. The routine from the hexval.lib does ignore spaces.

It will also set the ERR flag to 1 if invalid characters are found. Valid characters are 0-9, A-F,a-f

Usage : $lib "hexval.lbx"

---

## HIGH

Action

Retrieves the most significant byte of a variable.

Sets the most significant byte of a WORD variable. 

Syntax

var = HIGH( s )

HIGH( s ) = value

Remarks

Var | The variable that is assigned with the MSB of var S.  
---|---  
S | The source variable to get the MSB from when used as a function.  The target variable to set the MSB when used in an assignment   
value | The value to assign when used in an assignment.  
  
![notice](notice.jpg)When used in an assignment , only the second byte of the variable will be set. The intention purpose is to set the MSB of a WORD or INTEGER. 

It will also work on a LONG or DWORD but it will set the second byte in memory which is not the MSB of a LONG/DWORD.

Also, this will work on arrays, but there is no type checking which means that you should not use this on a single BYTE since it could overwrite other memory.

In version 2083 the HIGH function can also be used to set the MSB of a variable. This for compatibility with BASCOM-8051.

See also

[LOW](low.md) , [HIGHW](highw.md)

Example

Dim I As Integer , Z As Byte

I = &H1001

Z = High(i) ' is 10 hex or 16 dec

End

---

## HIGHW

Action

Retrieves the most significant word of a long variable.

Syntax

var = HIGHW( s )

Remarks

Var | The variable that is assigned with the MS word of var S.  
---|---  
S | The source variable to get the MSB from.  
  
There is no LowW() function. This because when you assign a Long to a word or integer, only the lower part is assigned. For this reason you do not need a Loww() function. W=L will do the same.

See also

[LOW](low.md) , [HIGH](high.md)

Example

Dim X As Word , L As Long

L = &H12345678

X = Highw(l)

Print Hex(x)

---

## HOME

Action

Place the cursor at the specified line at location 1.

Syntax

HOME UPPER | LOWER | THIRD | FOURTH

Remarks

If only HOME is used than the cursor will be set to the upper line.

You may also specify the first letter of the line like: HOME U

See also

[CLS](cls.md) , [LOCATE](locate.md)

For a complete example see [LCD](lcd_2.md)

Partial Example

Locate 2 , 1 'set cursor position

Lcd "*" 'display this

Home Upper 'select line 1 and return home

---

## How to Screen Capture

How to Screen Capture

There is nothing better than been able to produce nice Screen captures from your Graphics Display (instead of using a camera) when wanting to write a manual or a help file explaining the different screen operations/features at what they do.

The process is quite simple to implement into your program generating a Screen capture output. You can use the supplied code or you can modify the code and produce your own version.

```vb
If you look at FT800 Capture.Bas it demonstrates the Screen capture using two routines. 

Sub ScreenShot: is a demo originally from James Bowman (Gameduino2) which takes a snapshot and just outputs the data via Serial (which you have to write your own PC serial capture program).

Sub ScreenShot2: is the same as above except it uses additional control codes for handshaking and stopping the program. A sample PC (Windows) program called Capture FT800.exe demonstrate the capture process which when successful produces a BMP file. 

```
Capture FT800.exe waits for a ACK to acknowledge a ready to receive message so transmission can start, once transfer begins and then finishes it receives a EOT acknowledge end of transmission., Additional to this if the user wants to stop/quit transmission the program will send an ESC character to notify the hardware to stop sending data .

The easiest way to begin is to add Screenshot.inc to your code:

```vb
$Include "FT800.inc"  
$Include "FT800_Functions.inc"  
  
$Include "ScreenShot.inc" ' ç==== add this line 

Then decide where in your program you want to call ScreenShot2 so it can start the capturing process (working with Capture FT800.exe). 

```
This example itâs called at the end of the program:

  
Do  
Demo  
Loop

ScreenShot2  
  
End

This sample is called within a certain code area, straight after the screen is displayed.

ClearScreen  
ColorRGB 255, 255, 255  
BitmapSource RAM_G  
BitmapLayout Header_Format(1+_base), Header_Stride(1+_base), Header_Height(1+_base)  
BitmapSize NEAREST, Border, Border, Header_Width(1+_base), Header_Height(1+_base)  
Begin_G BITMAPS ' start drawing bitmaps  
Const DA = FT_DispWidth / 4  
Ln1 = Header_Width(1+_base) / 2  
Const DB = FT_DispHeight / 2  
Ln2 = Header_Height(1+_base) / 2  
BMoffsetx = DA - Ln1  
BMoffsety = DB - Ln2  
Vertex2II BMoffsetx, BMoffsety, 0, 0  
UpdateScreen

ScreenShot2

Using the Capture FT800.exe:

Note: when possible use the highest baud rate possible to decrease the wait time of receiving transmission. Donât forget to make sure the Hardware baud rate matches the Capture FT800 baud rate! (it wonât time time out if wrong).

![](embim2.png)

1)| Chose your Comm port  
---|---  
  
2)| Select the Baud rate of your Hardware  
---|---  
  
3)| You can either enter a filename or it can prompt you at the end of the capture.  
---|---  
  
4)| Press Start when ready, if successful you will see a message.  
---|---

---

## IDLE

Action

Put the processor into the idle mode.

Syntax

IDLE

Remarks

In the idle mode, the system clock is removed from the CPU but not from the interrupt logic, the serial port or the timers/counters.

The idle mode is terminated either when an interrupt is received(from the watchdog, timers, external level triggered or ADC) or upon system reset through the RESET pin.

Most new chips have many options for Power down/Idle. It is advised to consult the data sheet to see if a better mode is available.

![notice](notice.jpg)You should use the new [CONFIG POWERMODE ](config_powermode.md)statement.

See also

[POWERDOWN](powerdown.md) , [POWERSAVE](powersave.md) , [POWER mode](power_mode.md)

Example

IDLE

---

## IF-THEN-ELSE-END IF

Action

Allows conditional execution or branching, based on the evaluation of a Boolean expression.

Syntax

IF expression THEN

[ ELSEIF expression THEN ]

[ ELSE ]

END IF

Remarks

Expression | Any expression that evaluates to true or false.  
---|---  
  
The one line version of IF can be used :

IF expression THEN statement [ ELSE statement ]

The use of [ELSE] is optional.

Tests like IF THEN can also be used with bits and bit indexes.

IF var.bit = 1 THEN

^--- bit is a variable or numeric constant in the range from 0-255

You can use OR or AND to test on multiple conditions. The conditions are evaluated from left to right. 

```vb
IF A=1 OR A=2 OR A=3 OR B>10 THEN

IF A=1 AND A>3 THEN

Dim Var As Byte, Idx As Byte

```
Var = 255

Idx = 1

```vb
If Var.idx = 1 Then

Print "Bit 1 is 1"

```
EndIf

See also

[ELSE](else.md)

Example

Dim A As Integer

A = 10

```vb
If A = 10 Then 'test expression

Print "This part is executed." 'this will be printed

Else

Print "This will never be executed." 'this not

End If

If A = 10 Then Print "New in BASCOM"

If A = 10 Then Goto Label1 Else print "A<>10"

```
Label1:

Rem The following example shows enhanced use of IF THEN

```vb
If A.15 = 1 Then 'test for bit

Print "BIT 15 IS SET"

```
EndIf

Rem the following example shows the 1 line use of IF THEN [ELSE]

If A.15 = 0 Then Print "BIT 15 is cleared" Else Print "BIT 15 is set"

---

## INCR

Action

Increments a variable by one.

Syntax

INCR var

Remarks

Var | Any numeric variable.  
---|---  
  
See also

[DECR](decr.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : incr.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: INCR

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte

```
A = 5 'assign value to a

Incr A 'inc (by one)

```vb
Print A 'print it

End

```

---

## Index

![MCS help](mcs help.jpg)

Version 2.0.8.7 document build 102

MCS Electronics may update this documentation without notice. Products specification and usage may change accordingly. MCS Electronics will not be liable for any miss-information or errors found in this document. All software provided with this product package is provided 'AS IS' without any warranty expressed or implied. MCS Electronics will not be liable for any damages, costs or loss of profits arising from the usage of this product package. No part of this document may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying and recording, for any purpose, without written permission of MCS Electronics. Copyright MCS Electronics v.o.f. All rights reserved.  
---

---

## INITFILESYSTEM

Action

Initialize the file system

Syntax

bErrorCode = INITFILESYSTEM (bPartitionNumber)

Remarks

bErrorCode | (Byte) Error Result from Routine, Returns 0 if no Error  
---|---  
bPartitionNumber | (Byte) Partition number on the Flashcard Drive (normally 1)  
  
Reads the Master boot record and the partition boot record (Sector) from the flash card and initializes the file system.

This function must be called before any other file-system function is used.

See also

[OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md), [AVR-DOS File System](avr_dos_file_system.md)

ASM

Calls | _GetFileSystem |   
---|---|---  
Input | r24: partitionnumber (1-based) |   
Output | r25: Errorcode | C-Flag: Set on Error  
  
Partial Example

Dim bErrorCode as Byte

bErrorCode = InitFileSystem(1)

```vb
If bErrorCode > 0 then

Print "Error: "; bErrorCode

Else

Print "Filesystem successfully initialized"

End If

```

---

## INKEY

Action

Returns the ASCII value of the first character in the serial input buffer.

Syntax

var = INKEY()

var = INKEY(#channel)

Remarks

Var | Byte, Integer, Word, Long or String variable.  
---|---  
Channel | A constant number that identifies the opened channel if software UART mode  
  
If there is no character waiting, a zero will be returned.

Use the IsCharWaiting() function to check if there is a byte waiting.

The INKEY routine can be used when you have a RS-232 interface on your uP.

The RS-232 interface can be connected to a comport of your computer.

As zero(0) will be returned when no character is waiting, the usage is limited when the value of 0 is used in the serial transmission. You can not make a difference between a byte with the value 0 and the case where no data is available.

In that case you can use IsCharwaiting to deterimine if there is a byte waiting.

See also

[WAITKEY](waitkey.md) , [ISCHARWAITING](ischarwaiting.md) , [$TIMEOUT](_timeout.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : inkey.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: INKEY , WAITKEY

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte , S As String * 2

Do

```
A = Inkey() 'get ascii value from serial port

```vb
's = Inkey()

If A > 0 Then 'we got something

Print "ASCII code " ; A ; " from serial"

End If

Loop Until A = 27 'until ESC is pressed

```
A = Waitkey() 'wait for a key

```vb
's = waitkey()

Print Chr(a)

'wait until ESC is pressed

Do

Loop Until Inkey() = 27

'When you need to receive binary data and the bibary value 0 ,

'you can use the IScharwaiting() function.

'This will return 1 when there is a char waiting and 0 if there is no char waiting.

'You can get the char with inkey or waitkey then.

End

```

---

## INP

Action

Returns a byte read from a hardware port or any internal or external memory location.

Syntax

var = INP(address)

Remarks

var | Numeric variable that receives the value.  
---|---  
address | The address where to read the value from. (0- &HFFFF) For Xmega which supports huge memory, the address is in range from 0-&HFFFFFF.  
  
The PEEK() function will read only the lowest 32 memory locations (registers).

The INP() function can read from any memory location since the AVR has a linear memory model.

When you want to read from XRAM memory you must enable external memory access in the [Compiler Chip Options](options_compiler_chip.md).

See also

[OUT](out.md) , [PEEK](peek.md) , [POKE](poke.md), [SETREG](setreg.md), [GETREG](getreg.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : peek.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates PEEk, POKE, CPEEK, INP and OUT

'micro : Mega162

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m162def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim I As Integer , B1 As Byte

'dump internal memory

For I = 0 To 31 'only 32 registers in AVR

```
B1 = Peek(i) 'get byte from internal memory

```vb
Print Hex(b1) ; " ";

'Poke I , 1 'write a value into memory

Next

Print 'new line

'be careful when writing into internal memory !!

'now dump a part ofthe code-memory(program)

For I = 0 To 255

```
B1 = Cpeek(i) 'get byte from internal memory

```vb
Print Hex(b1) ; " ";

Next

'note that you can not write into codememory!!

```
Out &H8000 , 1 'write 1 into XRAM at address 8000

B1 = Inp(&H8000) 'return value from XRAM

```vb
Print B1

End

```

---

## INPUT

Action

Allows input from the keyboard, file or SPI during program execution.

Syntax

```vb
INPUT [" prompt" ] , var[ , varn ]

INPUT #ch, var[ , varn ]

```
Syntax SPI

INPUT #ch, var [;bts] [ , varn [;bts] ]

Remarks

Prompt | An optional string constant printed before the prompt character.  
---|---  
Var,varn | A variable to accept the input value or a string.  
Ch | A channel number, which identifies an opened file. This can be a hard coded constant or a variable.  
bts | An optional number of byes to read. Only for SPI.  
  
The INPUT routine can be used when you have an RS-232 interface on your uP.

The RS-232 interface can be connected to a serial communication port of your computer.

This way you can use a terminal emulator and the keyboard as an input device.

You can also use the built-in terminal emulator.

For usage with the AVR-DOS file system, you can read variables from an opened file. Since these variables are stored in ASCII format, the data is converted to the proper format automatically.

When you use INPUT with a file, the prompt is not supported.

When [$BIGSTRINGS](bigstrings.md) is used you can read read up to 65535 bytes.

Difference with VB

In VB you can specify &H with INPUT so VB will recognize that a hexadecimal string is being used.

BASCOM implements a new statement : INPUTHEX.

Xmega-SPI

When receiving data from the SPI interface, you need to activate the SS pin. Some chips might need an active low, others might need an active high. This will depends on the slave chip.

When you use the SS=AUTO option, the level of SS will be changed automatic. Thus SS is made low, then the data bytes are received, and finally , SS is made high again. 

Receiving data works by sending a data byte and returning the data that is shifted out. The data that will be sent is a 0. You can alter this in the library, _inputspivar routine.

You can not sent constants using the INPUT with SPI. So INPUT #10, "SPI", var is not supported. 

INPUT used with SPI will not wait for a return either. It will wait for the number of bytes that fits into the variable. See [CONFIG SPIx](config_spix.md) for an example.

Number of Bytes

The compiler will receive 1 byte for a variable which was dimensioned as a BYTE.

It will receive 2 bytes for a WORD/INTEGER, 4 bytes for a LONG/SINGLE and 8 bytes for a DOUBLE.

As with all routines in BASCOM, the least significant Byte will be received first.

If you specify an array, one element will be received.

SPI

With an optional parameter you can provide how many bytes must be received. You must use a semicolon (;) to specify this parameter. This because the comma (,) is used to receive multiple variables. 

```vb
Dim Tmparray(5) As Byte , Spi_send_byte As Byte , W as Word

Input #12 , Spi_receive_byte ; 1 ' READ 1 byte

Input #12 , Tmparray(1) ; 1 , Tmparray(2) ; B ' read 1 byte and 'b' bytes starting at element 2

```
The optional parameter is only supported for the SPI channel. When required with serial data, you can also use INPUTBIN.

See also

[INPUTHEX](inputhex.md) , [PRINT](print.md) , [ECHO](echo.md) , [WRITE](write.md) , [INPUTBIN](inputbin.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : input.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: INPUT, INPUTHEX

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim V As Byte , B1 As Byte

Dim C As Integer , D As Byte

Dim S As String * 15

Input "Use this to ask a question " , V

Input B1 'leave out for no question

Input "Enter integer " , C

Print C

```
Inputhex "Enter hex number (4 bytes) " , C

Print C

Inputhex "Enter hex byte (2 bytes) " , D

```vb
Print D

Input "More variables " , C , D

Print C ; " " ; D

Input C Noecho 'supress echo

Input "Enter your name " , S

Print "Hello " ; S

Input S Noecho 'without echo

Print S

End

```

---

## INPUTBIN

Action

Read binary data from the serial port.

Syntax

INPUTBIN var1 [;bts] [,var2]

INPUTBIN #channel , var1 [,var2]

Remarks

var1 | The variable that is assigned with the characters from the serial port.  
---|---  
var2 | An optional second (or more) variable that is assigned with the data from the serial input stream.  
bts | Optional numeric variable that specifies how many bytes must be read. This optional variable must be placed after a semi colon delimiter (;)  
  
The channel need to be used in combination with [OPEN ](open.md)and the optional [CLOSE.](open.md)

The number of bytes to read depends on the variable you use.

When you use a byte variable, 1 character is read from the serial port.

An integer will wait for 2 characters and an array will wait until the whole array is filled.

Note that the INPUTBIN statement doesn't wait for a CRLF but just for the number of bytes.

You may also specify an additional numeric parameter that specifies how many bytes will be read. This is convenient when you are filling an array.

Inputbin ar(1) , 4 ' will fill 4 bytes starting at index 1.

In version 2083 the INPUTBIN statement is enhanced with an option to specify the number of bytes to read using a variable.

In earlier versions only a constant could be used. To keep code compatible, use a semi colon followed by a variable to specify how many bytes must be read.

Inputbin ar(1) , bts ' will fill the number of bytes equal with the value of bts

See also

[PRINTBIN](printbin.md) , [CONFIG INPUTBIN](config_inputbin.md)

Example

Dim A As Byte , C As Integer

Inputbin A , C 'wait for 3 characters and fill 2 variables

End

---

## INPUTHEX

Action

Allows hexadecimal input from the keyboard during program execution.

Syntax

INPUTHEX [" prompt" ] , var[ , varn ]

Remarks

prompt | An optional string constant printed before the prompt character.  
---|---  
Var,varn | A numeric variable to accept the input value.  
  
The INPUTHEX routine can be used when you have a RS-232 interface on your uP.

The RS-232 interface can be connected to a serial communication port of your computer.

This way you can use a terminal emulator and the keyboard as input device.

You can also use the build in terminal emulator.

The input entered may be in lower or upper case (0-9 and A-F)

```vb
If var is a byte then the input can be maximum 2 characters long.

If var is an integer/word then the input can be maximum 4 characters long.

If var is a long then the input can be maximum 8 characters long.

```
In VB you can specify &H with INPUT so VB will recognize that a hexadecimal string is being used.

BASCOM implements a new statement: INPUTHEX. This is only to save code as otherwise also code would be needed for decimal conversion.

See also

[INPUT](input.md) , [ECHO](echo.md) , [INPUTBIN](inputbin.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : input.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: INPUT, INPUTHEX

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim V As Byte , B1 As Byte

Dim C As Integer , D As Byte

Dim S As String * 15

Input "Use this to ask a question " , V

Input B1 'leave out for no question

Input "Enter integer " , C

Print C

```
Inputhex "Enter hex number (4 bytes) " , C

Print C

Inputhex "Enter hex byte (2 bytes) " , D

```vb
Print D

Input "More variables " , C , D

Print C ; " " ; D

Input C Noecho 'supress echo

Input "Enter your name " , S

Print "Hello " ; S

Input S Noecho 'without echo

Print S

End

```

---

## INSERTCHAR

Action

Inserts one character into a string.

Syntax

INSERTCHAR string, pos, char

Remarks

string | The string where the character is inserted to.  
---|---  
pos | The position where the character is inserted to. A value of 1 would make the character the first character of the string.  
char | A byte or string or string constant with the character that need to be inserted. For example you can use "A" to insert an "A", or use a byte with the value 65 to insert an "A". Or use a string. In case of a string, only the first character will be used.   
  
INSERTCHAR supports [$BIGSTRINGS](bigstrings.md)

See also

[DELCHAR](delchar.md) , [DELCHARS](delchars.md) , [INSTR](instr.md) , [MID](mid.md) , [CHARPOS](charpos.md) , [REPLACECHARS](replacechars.md)

Example

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' del_insert_chars.bas  
' This sample demonstrates the delchar, delchars and insertchar statements  
'-----------------------------------------------------------------  
$regfile="m88def.dat"  
$crystal = 8000000  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
dim s as string * 30  
```
s = "This is a test string" ' create a string  
delchar s, 1 ' remove the first char  
print s ' print it  
  
insertchar s,1, "t" ' put a small t back  
print s  
  
delchars s,"s" ' remove all s  
```vb
print s  
end

```
Example

```vb
'--------------------------------------------------------------------------------  
'name : str-test.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demonstrates some string routines  
'micro : mega4809  
'suited for demo : no  
'commercial addon needed : yes  
'--------------------------------------------------------------------------------  
$regfile = "mx4809.dat"  
$crystal = 20000000  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
Config Sysclock = 16_20mhz , Prescale = 1 'set clock freq  
  
  
Dim S1 As String * 10  
Dim S2 As String * 10  
Dim S4 As String * 80  
  
```
S1 = "0123456789"  
S2 = "abcdefghij"  
Mid(s1 , 3 , 2) = "##" 'replace  
Mid(s1 , 13 , 2) = "**" 'try to do at an illegal position  
Mid(s1 , 0 , 2) = "**" 'try to do at an illegal position  
  
S1 = "0123456789"  
S2 = "abcdefghij"  
  
Mid(s1 , 3 ) = "#" 'replace  
Mid(s1 , 13 ) = "*" 'invalid  
  
S1 = "---"  
Mid(s1 , 1) = "ABC"  
  
S4 = "abcdefghijklm"  
Insertchar S4 , 0 , "*"  
Insertchar S4 , 1 , "*"  
Insertchar S4 , 20 , "*"  
  
Delchar S4 , 0  
Delchar S4 , 1  
Delchar S4 , 20  
  
End

---

## Installation of BASCOM

After you have downloaded the ZIP file you need to UNZIP the file.

On Windows XP, for the DEMO version, you may run the setupdemo.exe file from within the Zipped file. For the full version you should unzip the ZIP file.

The commercial version comes with a license file in the form of a DLL. This file is always on the disk where the file SETUP.EXE is located. When explorer does not show this file, you must set the option in explorer to view system files (because a DLL is a system file).

For the commercial version the setup file is named SETUP.EXE

Some resellers might distribute the DLL file in a zipped file. Or the file might have the extension of a number like "123". In this case you must rename the extension to DLL.

![notice](notice.jpg) Make sure the DLL is in the same directory as the SETUP.EXE file.

When you are using the DEMO version you don't need to worry about the license file.

When you are installing on a NT machine like NT4 , W2000, XP, Vista, Win7, Win8 or Win10, you need to have Administrator rights.

After installing BASCOM you must reboot the computer before you run BASCOM.

The installation example will describe how the FULL version installs. This is almost identical to the installation of the DEMO version.

Before installing the software : make sure you downloaded from mcselec.com domain. Or that you purchased from an authorized reseller.

When in doubt you can always check the executable on your PC using your browser at virustotal.com. In fact it is good practice to check files before you install them. virustotal.com will use 50 or more virus scanners. 

This will give a good idea about the safety of a file. 

Run the SETUPDEMO.EXE (or SETUP.EXE) by double clicking on it in explorer.

Depending on the windows version and your user rights, windows might give the following message :

![admin_rights](admin_rights.png)

You need to click the YES button.

The following window will appear:

(screen shots may differ a bit)

![setup_welcome](setup_welcome.png)

Click on the Next button to continue installation.

The following license info window will appear:

![setup_license](setup_license.png)

Read the instructions , select 'I accept the agreement' and press the Next button.

The following window will be shown :

![setup_readme](setup_readme.png)

Read the additional information and click the Next button to continue.

Now the next screen will appear:

![setup_destination](setup_destination.png)

You can select the drive and path where you like BASCOM to be installed. You can also accept the default value which is :

C:\MCS\BASCAVR2082

or you can install into a folder like :

C:\Program Files\MCS Electronics\BASCOM-AVR

Microsoft likes software to be installed into the Program Files folder. But this also means that all sub folders must be stored elsewhere since all folders under Program Files are write protected by Windows.

Using a user writable folder, all the files can be stored in one location. 

It is a good idea to install each new version into its own folder. This way, you can use multiple versions at the same time. As of version 2082, the settings file is stored in the application folder too.

When you are finished click the Next Button to continue.

When the directory exists, because you install a newer version, you will get a warning :

![setup_exists](setup_exists.png)

In case of this warning, select Yes. Or select NO and select a different folder.

You will now see the following window:

![setup_sample1](setup_sample1.png)

You can select the folder where the sample files are installed. This can be :

c:\users<USER>Documents\samples

or c:\MCS\BASCAVR2082\Samples

We recommend to use the second option so all files are placed under the application folder.

After you made your choice, click the Next button.

You are now presented with an optional component : parallel printer programming support.

Nowadays there are plenty serial and USB programmers available. Only select this option when you still use the LPT port for ISP programming.

![setup_parallel](setup_parallel.png)

Click the Next button to continue. 

You will now be presented a choice for the program group name and location.

![setup_startmenu](setup_startmenu.png)

You can choose to create into a new Program Group named 'BASCOM-AVR' , or you can modify the name, or install into an existing Program Group. Press the Next-button after you have made your choice.

Now the files will be installed.

![setup_installing](setup_installing.png)

After the main files are installed, some additional files will be installed. This depends on the distribution.

![setup_additional](setup_additional.png)

These additional files can be PDF files when the program is distributed on a CD-ROM.

When the installation is ready you will see the last screen :

![setup_complete](setup_complete.png)

You have to reboot your computer when you want to make advantage of the programmers that BASCOM supports. You can also do this at a later stage.

The BASCOM-AVR Program folder is created:

![setup_programgroup_created](setup_programgroup_created.png)

You can view the "Read me" and "License" files content and you can start BASCOM-AVR.

BASCOM supports both HTML Help and old Win help(HLP). The HLP file is not distributed in the setup. You need to use the Update Wiz to download it. But it is advised to use the HTML-Help file.

When you used to use the HLP file, and find it missing now, turn on 'Use HTML Help' in [Options, Environment, IDE.](options_environment.md)

When the UpdateWiz is not installed, you can download it from the [register](updates.md). 

The option [Help, Update](help_update.md) will also download the wiz. 

Till version 2074 all sample files were placed under the MCS Electronics\BASCOM-AVR folder.

Version 2075 places the sample files under the user Documents\MCS Electronics\BASCOM-AVR\Samples folder.

While we prefer to keep all files at one location and sub folders, this is not allowed in Windows 7 where the Program Files folder and all it's sub folders are write protected.

In version 2082 you can decide where the samples must be installed

The BASCOM-AVR application contains a number of folders.

\DAT : processor data files. These files contain processor info. When you use $REGFILE, the value should match with one of the files.

\LIB : library files. They have the extension LIB or LBX. LBX is a compiled LIB file. A library files contains ASM sub routines.

\INC : include files. Notice that these server only the compiler. Do not change or store include files here. Normal include files are stored along with the samples.

\PDF : PDF files with the bascom-avr manual and processor files from microchip/atmel.

\PINOUT : processor pinout and XML description files

\SAMPLES : this depends on the user choice during installation

---

## INSTR

Action

Returns the position of a sub string in a string.

Syntax

var = INSTR( start , string , substr )

var = INSTR( string , substr )

Remarks

Var | Numeric variable that will be assigned with the position of the sub string in the string. Returns 0 when the sub string is not found. When used with $BIGSTRINGS, the target variable should be a word instead of a byte.  
---|---  
Start | An optional numeric parameter that can be assigned with the first position where must be searched in the string. By default (when not used) the whole string is searched starting from position 1.  
String | The string to search.  
Substr | The search string.  
  
No constant can be used for string it must be a string variable.

Only substr can be either a string or a constant.

INSTR supports [$BIGSTRINGS](bigstrings.md)

See also

[SPLIT](split.md) , [CHARPOS](charpos.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : instr.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : INSTR function demo

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'dimension variables

Dim Pos As Byte

Dim S As String * 8 , Z As String * 8

'assign string to search

```
S = "abcdeab" ' Z = "ab"

'assign search string

Z = "ab"

'return first position in pos

Pos = Instr(s , Z)

```vb
'must return 1

'now start searching in the string at location 2

```
Pos = Instr(2 , S , Z)

'must return 6

Pos = Instr(s , "xx")

```vb
'xx is not in the string so return 0

End

```

---

## INT

Action

Returns the integer part of a single or double.

Syntax

var = INT( source )

Remarks

Var | A numeric floating point variable that is assigned with the integer of variable source.  
---|---  
Source | The source floating point variable to get the integer part of.  
  
The fraction is the right side after the decimal point of a single.

The integer is the left side before the decimal point.

1234.567 1234 is the integer part, .567 is the fraction

![notice](notice.jpg)The assigned variable must be a single or double. When you want to convert a floating point data type to an integer data type, just assign the variable to a variable of that type : someLong = someDouble

See Also

[FRAC](frac.md) , [FIX](fix.md) , [ROUND](round.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : round_fix_int.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : ROUND,FIX

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As Single , Z As Single

For S = -10 To 10 Step 0.5

Print S ; Spc(3) ; Round(s) ; Spc(3) ; Fix(s) ; Spc(3) ; Int(s)

Next

End

```

---

## International Resellers

Since the resellers list changes so now and then, it is not printed in this help. You can best look at the list at the MCS website.

See [MCS Electronics web](<http://www.mcselec.com/index.php?option=com_contact&catid=82&Itemid=59>).

There is always a reseller near you. A reseller can help you in your own language and you are in the same time zone.

Sometimes there are multiple resellers in your country. All resellers have their own unique expertise. For example : industrial, robotics, educational, etc.

---

## ISCHARWAITING

Action

Returns one(1) when a character is waiting in the hardware UART buffer.

Syntax

var = ISCHARWAITING()

var = ISCHARWAITING(#channel)

Remarks

Var | Byte, Integer, Word or Long variable.  
---|---  
Channel | A constant number that identifies the opened channel.  
  
```vb
If there is no character waiting, a zero will be returned.

If there is a character waiting, a one (1) will be returned.

```
The character is not retrieved or altered by the function.

While the Inkey() will get the character from the HW UART when there is a character in the buffer, it will return a zero when the character is zero. This makes it unusable to work with binary data that might contain the value 0.

With IsCharWaiting() you can first check for the presence of a character and when the function returns 1, you can retrieve the character with Inkey or Waitkey.

IsCharWaiting can NOT be used with a software uart (SW-UART). This because a SW-UART does not buffer the data it receives or sends.

See also

[WAITKEY](waitkey.md) , [INKEY](inkey.md) , [$TIMEOUT](_timeout.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte , S As String * 2

Do

```
A = Ischarwaiting()

If A = 1 Then 'we got something

A = Waitkey() 'get it

```vb
Print "ASCII code " ; A ; " from serial"

End If

Loop Until A = 27 'until ESC is pressed

```

---

## ISP programmer

BASCOM supports the STK200 and STK200+ and STK300 ISP programmer from Atmel.

This is a very reliable parallel printer port programmer.

The STK200 ISP programmer is included in the STK200 starter kit.

Most programs were tested with the STK200.

For those who don't have this kit and the programmer the following schematic shows how to make your own programmer:

The dongle has a chip with no identification but since the schematic is all over the web, it is included. MCS also sells a STK200 compatible programmer.

Here is a tip received from a user :

If the parallel port is disconnected from the interface and left floating, the '244 latch outputs will waver, causing your micro controller to randomly reset during operation. The simple addition of a 100K pull-up resistor between pin 1 and 20 of the latch, and another between pin 19 and 20, will eliminate this problem. You'll then have HIGH-Z on the latch outputs when the cable is disconnected (as well as when it's connected and you aren't programming), so you can use the MOSI etc. pins for I/O.

![ISP](isp.gif)

Since parallel printer ports do not exist in new equipment you better use an USB programmer.

---

## JOIN

Action

The JOIN function returns a string from a string array

Syntax

target = JOIN(source(start) ,elements [,glue] )

Remarks

target | The string that is assigned. You need to make sure that this string is dimensioned large enough to hold the content.  
---|---  
source | The source string array  
start | The starting position within the string array  
elements | The number of elements to process  
glue | This is an optional byte which you can use to glue the elements together. For example a space, or a dot  
  
The [SPLIT](split.md)() function can split up a string into elements. The JOIN() function does the exact opposite : it creates a string out of a string array.

See also

[SPLIT](split.md)

Example

```vb
'--------------------------------------------------------------------------------  
'name : join.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demonstrates JOIN function  
'micro : M88  
'suited for demo : no  
'commercial addon needed : no  
'--------------------------------------------------------------------------------  
  
$regfile = "m88def.dat"  
  
$crystal = 8000000  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
  
Config Com1 = 115200 , Parity = None , Databits = 8 , Stopbits = 1  
  
  
Dim Ar(10) As String * 20  
Dim S1 , S2 As String * 80  
Dim Cnt As Byte  
  
```
S1 = "this.is.a.test"  
Cnt = Split(s1 , Ar(1) , ".")  
  
S2 = Join(ar(1) , 3)  
Print S2  
  
S2 = Join(ar(1) , 3 , ".")  
```vb
Print S2  
  
End  


```

---

## Jump

Action

Execute commands at another location in the Display List.

Syntax

Jump dest

Remarks

dest | Display list address to be jumped  
---|---  
  
See also

[CALL_C](call_c.md) , [RETURN_C](return_c.md) , [MACRO_R](macro_r.md) , [DISPLAY_E](display_e.md)

---

## KamProg for AVR

KamProg for AVR is an USB programmer from Kamami.

You need to install the software that comes with the KamProg.

You can download the software from the web site of the manufacturer or from MCS Electronics web shop Kamprog product page.

KamProg can be used with BASCOM but also with AVR Studio.

BASCOM will use the KamProg software to either automatic or manual program the chip.

The Kamprog programmer works on Vista32 and Vista64 and requires no special drivers. It has also been tested with Win7 and Win8 and Win8.1

The KamProg programmer is available from MCS Electronics webshop.

When you use Auto program, you will see a small progress window while the processor is programmed.

When you chose manual program, you will see a familiar window, known from USB-ISP.

![kamprog](kamprog.png)

When the source code is compiled and the BIN file exists, it is loaded automatic into the buffer.

When an EEPROM image file exists (EEP), it is loaded too into the EEPROM buffer. When it does not exist you will see a warning which you can ignore.

When the target device is not read yet, the CHIP will be unidentified which is marked as ???.

In the status bar you can see the loaded file, and the size of the file. Notice that 16000 will be shown as 16 KB. 

You can select the EEPROM-TAB to view the EEPROM image. Memory locations can be altered. Select a cell, and type a new value. Then press ENTER to confirm. You can immediately see the new value. 

When you select the Lock and Fusebits-TAB the lock and fuse bits will be read.

![kamprog_lockfuse](kamprog_lockfuse.png)

As soon the target chip is determined, the chip name is shown under the tool bar.

The FLASH size and EEPROM size are shown too.

When you alter a lock or fuse bit, the corresponding Write-button will be enabled. You need to click it to write the new value. The lock and fuse bits are read again so you can see if it worked out.

The lock and fuse bits shown will depend on the used chip. Every chip has different fuse bits. Some fuse bits can not be altered via the serial programming method. For example the fuse bit 'enable serial downloading' can not be changed using the serial programming method.

Fuse bits of interest are : the clock divider and the oscillator fuse bits. When you select a wrong oscillator fuse bit (for example you select an external oscillator) the chip can not programmed anymore until you connect such an external oscillator! Of course a simple 555 chip can generate a clock signal you can use to 'wake' a locked chip. 

Once you have all settings right, you can press the 'Write PRG' button which will insert some code into your program at the current cursor position. This is the $PROG directive. 

For example : $prog &HFF , &HED , &HD0 , &HFF 

When you compile your program with the [$PROG](_prog.md) directive it will generate a PRG file with the lock and fuse bit settings. 

```vb
If you then auto program(see later) a chip, it will use these settings. 

$PROG is great to load the right lock and fuse bits into a new chip. But be careful : do not enable $PROG till you are done with development. Otherwise programming will be slow because of the extra reading and writing steps. 

```
The following menu options are available: 

Option | Description  
---|---  
File |   
  
Exit | Close programmer.  
  
|   
  
Buffer |   
  
Clear | Clear buffer. Will put a value of 255 (FF hex) into each memory location. When the FLASH-TAB has the focus, the FLASH buffer will be cleared. When the EEPROM-TAB has the focus, the EEPROM buffer will be cleared. 255 is the value of an empty memory location.  
Load from File | This will shown an open file dialog so you can select a binary file (BIN)  
  
| The file is loaded into the buffer.  
Save to File | Will save the current buffer to a file.  
Reload | Reloads the buffer from the file image.  
  
|   
  
Chip |   
  
Identify | Will attempt to read the signature of the chip. When the signature is unknown(no DAT file available) or there is no chip or other error, you will get an error. Otherwise the chip name will be shown.  
Write buffer to chip | This will write the active buffer(FLASH or EEPROM) into the chip.  
Read chipcode | When the chip lock bit is not set you can read the FLASH or EEPROM into the buffer.  
Blank check | Check if the chip FLASH or EEPROM is empty.   
Erase | Erases the chip FLASH. It depends on the fusebits if the EEPROM is erased too. Normally the EEPROM is erased too but some chip have a fuse bit to preserve EEPROM when erasing the chip. A chip MUST be erased before it can be programmed.  
Verify | Checks if the buffer matches the chip FLASH or EEPROM.  
Auto program | This will eraser, and program the FLASH and EEPROM and if $PROG is used, it will set the lock and fusebits too.   
  
In the toolbar you can also alter the ISP clock frequency. 

![notice](notice.jpg)The clock frequency should not be higher than a quarter of the oscillator frequency.

This means that a chip with an internal 8 MHz oscillator which has the 8-divider fuse enabled, will have a clock frequency of 1 Mhz.

The programming clock may not exceed 250 KHz in that case.

---

## Keyword Reference

1WIRE  
  
1Wire routines allow you to communicate with Dallas 1wire chips.

[1WRESET](1wreset.md) , [1WREAD](1wread.md) , [1WWRITE](1wwrite.md) , [1WSEARCHFIRST](1wsearchfirst.md) , [1WSEARCHNEXT](1wsearchnext.md) ,[1WVERIFY](1wverify.md) , [1WIRECOUNT](1wirecount.md)

CAN

[CONFIG CANBUSMODE](config_canbusmode.md), [CONFIG CANMOB](config_canmob.md), [CANBAUD](canbaud.md), [CANRESET](canreset.md), [CANCLEARMOB](canclearmob.md), [CANCLEARALLMOBS](canclearallmobs.md), [CANSEND](cansend.md), [CANRECEIVE](canreceive.md) , [CANID](canid.md), [CANSELPAGE](canselpage.md), [CANGETINTS](cangetints.md)

Conditions and Loops

Conditions execute a part of the program depending on a condition being True or False

[IF-THEN-ELSE-END IF](if_then_else_end_if.md) , [WHILE-WEND](while_wend.md) , [ELSE](else.md) , [DO-LOOP](do_loop.md) , [SELECT CASE - END SELECT](select_case_end_select.md) , [FOR-NEXT](for_next.md) , [CONTINUE](continue.md), [REDO](redo.md)

Conditional Compilation

[#IF #ELSE #ELSEIF #ENDIF , VAREXIST](_if_else_endif.md)

Configuration

Configuration commands initialize the hardware to the desired state.

[CONFIG](config.md) , [CONFIG ACI](config_aci.md) , [CONFIG ADC](config_adc.md) , [CONFIG ADCx](config_adca.md) , [CONFIG BCCARD](config_bccard.md) , [CONFIG CLOCK](config_clock.md) , [CONFIG COM1](config_com1.md) , [CONFIG COM2](config_com2.md) , [CONFIG DAC](config_dacx.md) , [CONFIG DATE](config_date.md) , [CONFIG DMXSLAVE](config_dmxslave.md), [CONFIG EEPROM](config_eeprom.md) ,[CONFIG EXTENDED_PORT](config_extended_port.md) , [CONFIG PS2EMU](config_ps2emu.md) , [CONFIG ATEMU](config_atemu.md) , [CONFIG I2CSLAVE](config_i2cslave.md) , [CONFIG INPUT](configinput.md), [CONFIG GRAPHLCD](config_graphlcd.md) , [CONFIG KEYBOARD](config_keyboard.md) , [CONFIG TIMER0](config_timer0.md) , [CONFIG TIMER1](config_timer1.md) , [CONFIG LCDBUS](config_lcdbus.md) , [CONFIG LCDMODE](config_lcdmode.md) , [CONFIG 1WIRE](config_1wire.md) , [CONFIG LCD](config_lcd.md) , [CONFIG OSC](config_osc.md), [CONFIG SERIALOUT](config_serialout.md) , [CONFIG SERIALIN](config_serialin.md) , [CONFIG SPI](config_spi.md) , [CONFIG SPIx](config_spix.md), [CONFIG SYSCLOCK](config_sysclock.md) , [CONFIG LCDPIN](config_lcdpin.md) , [CONFIG PRIORITY](config_priority.md) , [CONFIG SDA](config_sda.md) , [CONFIG SCL](config_scl.md) , [CONFIG DEBOUNCE](config_debounce.md) , [CONFIG WATCHDOG](config_watchdog.md) , [CONFIG PORT , ](config_port.md)[COUNTER0 AND COUNTER1](counter0_and_counter1.md) , [CONFIG TCPIP](config_tcpip.md) , [CONFIG TWISLAVE](config_twislave.md) , [CONFIG SINGLE](configsingle.md) , [CONFIG X10](config_x10.md) , [CONFIG XRAM](configxram.md) , [CONFIG USB](config_usb.md) , [CONFIG DP](config_dp.md) , [CONFIG TCXX](config_tcxx.md) , [CONFIG VPORT](config_vport.md) [CONFIG ERROR](config_error.md) , [CONFIG POWER REDUCTION](config_power_reduction.md),[ CONFIG EVENT_SYSTEM](config_event_system.md) , [CONFIG DMA ](config_dma.md), [CONFIG DMACHx](config_dmachx.md) , [CONFIG SUBMODE](config_submode.md) , [CONFIG POWERMODE](config_powermode.md) , [CONFIG XPIN](config_xpin.md) , [CONFIG FT800](config_ft800.md) , [CONFIG I2CBUS](config_i2cbus.md) , [CONFIG EDMA](config_edma.md) , [CONFIG EDMAx](config_edmax.md) , [CONFIG INPUTBIN](config_inputbin.md) , [CONFIG MODBUS](config_modbus.md) , [CONFIG PORT_MUX](config_port_mux.md) , [CONFIG VREF](config_vref.md) , , [CONFIG TCA](config_tca0.md), [CONFIG TCB](config_tcb0_tcb1.md), [CONFIG TCD](config_tcd0.md) , [CONFIG RC5](config_rc5.md), [CONFIG RC5SEND](config_rc5send.md) ,  [CONFIG VARPTRMODE](config_varptrmode.md)

Conversion

A conversion routine is a function that converts a number or string from one form to another.

[BCD](bcd.md) , [GRAY2BIN](gray2bin.md) , [BIN2GRAY](bin2gray.md) , [BIN](bin.md) , [MAKEBCD](makebcd.md) , [MAKEDEC](makedec.md) , [MAKEINT](makeint.md) , [FORMAT](format.md) , [FUSING](fusing.md) , [BINVAL](binval.md) , [CRC8](crc8.md) , [CRC16](crc16.md) , [CRC16UNI](crc16uni.md) , [CRC32](crc32.md) , [HIGH](high.md) , [HIGHW](highw.md) , [LOW](low.md) , [AESENCRYPT](aesencrypt.md) , [AESDECRYPT](aesdecrypt.md) , [FLIP](flip2.md) , [CRCMB](crcmb.md) , [CRC8UNI](crc8uni.md) , [MANCHESTERDEC](manchesterdec.md), [MANCHESTERENC](manchesterenc.md) , [DESENCRYPT](desencrypt.md) , [DESDECRYPT](desdecrypt.md)

DateTime

Date Time routines can be used to calculate with date and/or times.

[DATE](date.md) , [TIME](time.md) , [DATE$](date_.md) , [TIME$](time_.md) , [DAYOFWEEK](dayofweek.md) , [DAYOFYEAR](dayofyear.md) , [SECOFDAY](secofday.md) , [SECELAPSED](secelapsed.md) , [SYSDAY](sysday.md) , [SYSSEC](syssec.md) , [SYSSECELAPSED](syssecelapsed.md)

Delay

Delay routines delay the program for the specified time.

[WAIT](wait.md) , [WAITMS](waitms.md) , [WAITUS](waitus.md) , [DELAY](delay.md)

Directives

Directives are special instructions for the compiler. They can override a setting from the IDE.

[$ASM](asm.md) , [$BAUD](baud_1.md) , [$BAUD1](_baud1.md) , [$BIGSTRINGS](bigstrings.md) , [$BGF](_bgf.md) , [$BOOT](_boot.md) , [$CRYSTAL](crystal_1.md) , [$DATA](data_1.md) , [$DBG](_dbg.md) , [$DEFAULT](default.md) , [$EEPLEAVE](_eepleave.md) , [$EEPROM](eeprom.md) , [$EEPROMHEX](_eepromhex.md) , [$EEPROMSIZE](eepromsize.md), [$EXTERNAL](external.md) , [$HWSTACK](_hwstack.md) , [$INC](_inc.md) , [$INCLUDE](include.md) , [$INITMICRO](_initmicro.md) , [$LCD](lcd_1.md) , [$LCDRS](lcdrs.md) , [$LCDPUTCTRL](lcdputctrl.md) , [$LCDPUTDATA](lcdputdata.md) , [$LCDVFO](_lcdvfo.md) , [$LIB](lib.md) , [$LOADER](loader.md) , [$LOADERSIZE](loadersize.md) , [$MAP](_map.md) , [$NOCOMPILE](nocompile.md) , [$NOINIT](_noinit.md) , [$NORAMCLEAR](_noramclear.md) , [$NORAMPZ](norampz.md) , [$PROJECTTIME](_projecttime.md), [$PROG](_prog.md) , [$PROGRAMMER](programmer.md) , [$REGFILE](regfile.md) , [$RESOURCE](resource.md) , [$ROMSTART](_romstart.md) [$SERIALINPUT](serialinput.md), [$SERIALINPUT1](_serialinput1.md) , [$SERIALINPUT2LCD](serialinput2lcd.md) , [$SERIALOUTPUT](serialoutput.md) , [$SERIALOUTPUT1](_serialoutput1.md) , [$SIM](sim.md) , [$SWSTACK](_swstack.md) , [$TIMEOUT](_timeout.md) , [$TINY](_tiny.md) , [$WAITSTATE](_waitstate.md) , [$XRAMSIZE](xramsize.md) , [$XRAMSTART](xramstart.md) , [$XA](xa.md) , [$CRYPT](crypt.md) , [$NOTRANSFORM](notransform.md) , [$FILE](file.md) , [$AESKEY](_aeskey.md) , [$XTEAKEY](xteakey.md) , [$STACKDUMP](stackdump.md) ,[ $NOFRAMEPROTECT](noframeprotect.md) , [$FRAMEPROTECT](frameprotect.md) , [$FORCESOFTI2C](forcesofti2c.md) , [$BOOTVECTOR](bootvector.md) , [$REDUCEIVR](_aeskey.md) , [$TYPECHECK](typecheck.md) , [$NOTYPECHECK](notypecheck.md)

File

File commands can be used with AVR-DOS, the Disk Operating System for AVR.

[BSAVE](bsave.md) , [BLOAD](bload.md) , [GET](get.md) , [VER](ver.md) , [DISKFREE](diskfree.md) , [DIR](dir.md) , [DriveReset](drivereset.md) , [DriveInit](driveinit.md) , [LINE INPUT](line_input.md) , [INITFILESYSTEM](initfilesystem.md) , [EOF](eof.md) , [WRITE](write.md) , [FLUSH](flush.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [FILELEN](filelen.md) , [SEEK](seek.md) , [KILL](kill.md) , [DriveGetIdentity](drivegetidentity.md) , [DriveWriteSector](drivewritesector.md) , [DriveReadSector](drivereadsector.md) , [LOC](loc.md) , [LOF](lof.md) , [PUT](put.md) , [OPEN](open.md) , [CLOSE](close.md) , [CHDIR](chdir.md) , [MKDIR](mkdir.md) , [RMDIR](rmdir.md) , [NAME](name.md) , [GETATTR](getattr.md) , [SETATTR](setattr.md) , [CLEARATTR](clearattr.md)

Graphical LCD

Graphical LCD commands extend the normal text LCD commands.

[GLCDCMD](glcdcmd.md) , [GLCDDATA](glcddata.md) , [SETFONT](setfont.md) , [LINE](line.md) , [PSET](pset.md) , [SHOWPIC](showpic.md) , [SHOWPICE](showpice.md) , [CIRCLE](circle.md) , [BOX](box.md) , [RGB8TO16](rgb8to16.md)

I2C

I2C commands allow you to communicate with I2C chips with the TWI hardware or with emulated I2C hardware.

[I2CINIT](i2cinit.md) , [I2CRECEIVE](i2creceive.md) , [I2CSEND](i2csend.md) , [I2CSTART, I2CREPSTART, I2CSTOP,I2CRBYTE,I2CWBYTE](i2start_i2cstop__i2crbyte__i2cwbyte.md)

IO

I/O commands are related to the I/O pins and ports of the processor chip.

[ALIAS](alias.md) , [BITWAIT](bitwait.md) , [TOGGLE](toggle.md) , [RESET](reset.md) , [SET](set.md) , [SHIFTIN](shiftin.md) , [SHIFTOUT](shiftout.md) , [DEBOUNCE](debounce.md) , [PULSEIN](pulsein.md) , [PULSEOUT](pulseout.md)

Micro

Micro statements are specific to the micro processor chip.

[IDLE](idle.md) , [POWER mode](power_mode.md) , [POWERDOWN](powerdown.md) , [POWERSAVE](powersave.md) , [ON INTERRUPT](on_interrupt.md) , [ENABLE](enable.md) , [DISABLE](disable.md) , [START](start.md) , [END](end.md) , [VERSION](version.md) , [CLOCKDIVISION](clockdivision.md) , [CRYSTAL](crystal_2.md) , [STOP](stop.md)

Memory

Memory functions set or read RAM , EEPROM or flash memory.

[ADR](adr___adr2.md) , [ADR2](adr___adr2.md) , [WRITEEEPROM](writeeeprom.md) , [CPEEK](cpeek.md) , [CPEEKH](cpeekh.md) , [PEEK](peek.md) , [POKE](poke.md) , [OUT](out.md) , [READEEPROM](readeeprom.md) , [DATA](data_2.md) , [INP](inp.md) , [READ](read.md) , [RESTORE](restore.md) , [LOOKDOWN](lookdown.md) , [LOOKUP](lookup.md) , [LOOKUPSTR](lookupstr.md) , [LOADADR](loadadr.md) , [LOADLABEL](loadlabel.md) , [LOADWORDADR](loadwordadr.md) , [MEMCOPY](memcopy.md) , [GETREG](getreg.md) , [SETREG](setreg.md) , [VARPTR](varptr.md) , [MEMFILL](memfill.md)

Remote Control

Remote control statements send or receive IR commands for remote control.

[RC5SEND](rc5send.md) , [RC6SEND](rc6send.md) , [GETRC5](getrc5.md) , [SONYSEND](sonysend.md)

RS-232

RS-232 are serial routines that use the UART or emulate a UART.

[BAUD](baud_2.md) , [BAUD1](baud1.md), [BUFSPACE](bufspace.md) , [CLEAR](clear.md), [ECHO](echo.md) , [WAITKEY](waitkey.md) , [ISCHARWAITING](ischarwaiting.md) , [INKEY](inkey.md) , [INPUTBIN](inputbin.md) , [INPUTHEX](inputhex.md) , [INPUT](input.md) , [PRINT](print.md) , [PRINTBIN](printbin.md) , [SERIN](serin.md) , [SEROUT](serout.md) , [SPC](spc.md) , [MAKEMODBUS](makemodbus.md)

SPI

SPI routines communicate according to the SPI protocol with either hardware SPI or software emulated SPI.

[SPIIN](spiin.md) , [SPIINIT](spiinit.md) , [SPIMOVE](spimove.md) , [SPIOUT](spiout.md) , [SPI1IN](spiin.md) , [SPI1INIT](spiinit.md) , [SPI1MOVE](spimove.md) , [SPI1OUT](spiout.md)

String

String routines are used to manipulate strings.

[ASC](asc.md) , [CHARPOS](charpos.md), [UCASE](ucase.md) , [LCASE](lcase.md) , [TRIM](trim.md) , [SPLIT](split.md) , [LTRIM](ltrim.md) , [INSTR](instr.md) , [SPACE](space.md) , [STRING](string.md) , [RTRIM](rtrim.md) , [LEFT](left.md) , [LEN](len.md) , [MID](mid.md) , [RIGHT](right.md) , [VAL](val.md) , [STR](str.md) , [CHR](chr.md) , [CHECKSUM](checksum.md) , [CHECKSUMXOR](checksum.md), [HEX ](hex.md), [HEXVAL](hexval.md) , [QUOTE](quote.md) , [REPLACECHARS](replacechars.md) , [STR2DIGITS](str2digits.md) , [DELCHAR](delchar.md), [DELCHARS](delchars.md) , [INSERTCHAR](insertchar.md) , [JOIN](join.md)

TCP/IP

TCP/IP routines can be used with the W3100/IIM7000/IIM7010/W5100/W5200/W5300 modules.

[BASE64DEC](base64dec.md) , [BASE64ENC](base64enc.md) , [IP2STR](ip2str.md) , [UDPREAD](udpread.md) , [UDPWRITE](udpwrite.md) , [UDPWRITESTR](udpwritestr.md) , [TCPWRITE](tcpwrite.md) , [TCPWRITESTR](tcpwritestr.md) , [TCPREAD](tcpread.md) , [GETDSTIP](getdstip.md) , [GETDSTPORT](getdstport.md) , [SOCKETSTAT](socketstat.md) , [SOCKETCONNECT](socketconnect.md) , [SOCKETLISTEN](socketlisten.md) , [GETSOCKET](getsocket.md) , [SOCKETCLOSE](socketclose.md) , [SETTCP](settcp.md) , [GETTCPREGS](gettcpregs.md) , [SETTCPREGS](settcpregs.md) , [SETIPPROTOCOL](setipprotocol.md) , [TCPCHECKSUM](tcpchecksum.md) , [SOCKETDISCONNECT](socketdisconnect.md) , [SNTP](sntp.md) , [TCPREADHEADER](tcpreadheader.md) , [UDPREADHEADER](udpreadheader.md), [URL2IP](url2ip.md)

Text LCD

Text LCD routines work with normal text based LCD displays.

[HOME](home.md) , [CURSOR](cursor.md) , [UPPERLINE](upperline.md) , [THIRDLINE](thirdline.md) , [INITLCD](initlcd.md) , [LOWERLINE](lowerline.md) , [LCD](lcd_2.md) , [LCDAT](lcdat.md) , [FOURTHLINE](fourthline.md) , [DISPLAY](display.md) , [LCDCONTRAST](lcdcontrast.md) , [LOCATE](locate.md) , [SHIFTCURSOR](shiftcursor.md) , [DEFLCDCHAR](deflcdchar.md) , [SHIFTLCD](shiftlcd.md) , [CLS](cls.md) , [LCDAUTODIM](lcdautodim.md) , [LCDCMD](lcdcmd.md), [LCDDATA](lcddata.md) , [LCDFONT](lcdfont.md)

Trig & Math

Trig and Math routines work with numeric variables.

[ACOS](acos.md) , [ASIN](asin.md) , [ATN](atn.md) , [ATN2](atn2.md) , [EXP](exp.md) , [RAD2DEG](rad2deg.md) , [FRAC](frac.md) , [TAN](tan.md) , [TANH](tanh.md) , [COS](cos.md) , [COSH](cosh.md) , [LOG](log.md) , [LOG10](log10.md) , [ROUND](round.md) , [ABS](abs.md) , [INT](int.md) , [MAX](max.md) , [MIN](min.md) , [SQR](sqr.md) , [SGN ](sgn.md), [POWER](power.md) , [SIN](sin.md) , [SINH](sinh.md) , [FIX](fix.md) , [INCR](incr.md) , [DECR](decr.md) , [DEG2RAD](deg2rad.md) , [CHECKFLOAT](checkfloat.md) , [MOD](mod.md) , [QSIN](qsin.md) , [QCOS](qcos.md) , [AND](and.md), [OR](or.md) , [XOR](xor.md) , [NOT](not.md)

Various

This section contains all statements that were hard to put into another group

[CONST](const.md) , [DBG](dbg.md) , [DECLARE FUNCTION](declare_function.md) , [DEBUG](debug.md), [DECLARE SUB](declare_sub.md) , [DEFXXX](defxxx.md) , [DIM](dim.md) , [DTMFOUT](dtmfout.md) , [EXIT](exit.md) , [ENCODER](encoder.md) , [GETADC](getadc.md) , [GETKBD](getkbd.md) , [GETATKBD](getatkbd.md) , [GETRC](getrc.md) , [GOSUB](gosub.md) , [GOTO](goto.md) , [LOCAL](local.md) ,[ON VALUE](on_value.md) , [POPALL](popall.md) , [PS2MOUSEXY](ps2mousexy.md) , [PUSHALL](pushall.md) , [RETURN](return.md) , [RND](rnd.md) , [ROTATE](rotate.md) , [SENDSCAN](sendscan.md) , [SENDSCANKBD](sendscankbd.md) , [SHIFT](shift.md) , [SOUND](sound.md) , [STCHECK](stcheck.md) , [SUB](sub.md) , [SWAP](swap.md) , [VARPTR](varptr.md) , [X10DETECT](x10detect.md) , [X10SEND](x10send.md) , [READMAGCARD](readmagcard.md) , [REM](rem.md) , [BITS](bits.md) , [BYVAL](byval.md) , [CALL](call.md) , [#IF](_if_else_endif.md) , [#ELSE](_if_else_endif.md) , [#ENDIF](_if_else_endif.md) , [READHITAG](readhitag.md) , [SORT](sort.md) , [XTEADECODE](xteadecode.md) , [XTEAENCODE](xteaencode.md) , [BREAK](break.md) , [COMPARE](compare.md) , [NOP](nop.md) , [SIZEOF](sizeof.md) , [WRITEDAC](writedac.md) , [TYPE](type.md)

RAINBOW WS2812

Rainbow or WS2812 LED statements and functions.

[CONFIG RAINBOW](config_rainbow.md) , [RB_ADDCOLOR](rb_addcolor.md), [RB_ANDCOLOR](rb_andcolor.md), [RB_ORCOLOR](rb_orcolor.md), [RB_SUBCOLOR](rb_subcolor.md), [RB_CLEARSTRIPE](rb_clearstripe.md) , [RB_CLEARCOLORS](rb_clearcolors.md) , [RB_FILL](rb_fill.md) , [RB_FILLCOLORS](rb_fillcolors.md) , [RB_FILLSTRIPE](rb_fillstripe.md) , [RB_SELECTCHANNEL](rb_selectchannel.md), [RB_SEND](rb_send.md), [RB_SETCOLOR](rb_setcolor.md) , [RB_SWAPCOLOR](rb_swapcolor.md) , [RB_ROTATELEFT](rb_rotateleft.md), [RB_ROTATERIGHT](rb_rotateright.md), [RB_SHIFTLEFT](rb_shiftleft.md), [RB_SHIFTRIGHT](rb_shiftright.md) , [RB_CHANGEPIN](rb_changepin.md) , [RB_SETTABLECOLOR](rb_settablecolor.md) , [RB_GETCOLOR](rb_getcolor.md) , [RB_LOOKUPCOLOR](rb_lookupcolor.md) , [RB_COLOR](rb_color.md) , [RB_COPY](rb_copy.md)

FT800-FT801-FT810

[CMD8](cmd8.md) , [CMD16](cmd16.md) , [CMD32](cmd32.md) , [RD8](rd8.md) , [RD16](rd16.md) , [RD32](rd32.md) , [WR8](wr8.md) , [WR16](wr16.md) , [WR32](wr32.md)

XMEGA

[READSIG](readsig.md) , [ATXMEGA](atxmega.md)

XTINY

[XTINY](xtiny.md)

MEGAX

[MEGAX](megax.md)

AVRX

[AVRX](avrx.md)

---

## KILL

Action

Delete a file from the Disk

Syntax

KILL sFileName

Remarks

sFileName | A String variable or string expression, which denotes the file to delete  
---|---  
  
This function deletes a file from the disk. A file in use can't be deleted. WildCards in Filename are not supported. Check the DOS-Error in variable gDOSError.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _DeleteFile |   
---|---|---  
Input | X: Pointer to string with filename |   
Output | r25: Errorcode | C-Flag: Set on Error  
  
Partial Example

```vb
'We can use the KILL statement to delete a file.

'A file mask is not supported

Print "Kill (delete) file demo"

```
Kill "test.txt"

---

## KITSRUS Programmer

The K122 is a KIT from KITSRUS. (www.kitsrus.com)

The programmer supports the most popular 20 and 40 pins AVR chips.

```vb
On the Programmer Options tab you must select this programmer and the COM port it is connected to.

On the Monitor Options tab you must specify the upload speed of 9600, Monitor delay of 1 and Prefix delay 1.

```
When you press the Program button the Terminal Emulator screen will pop up:

![BASC0086](basc0086.gif)

A special toolbar is now visible.

You must press the Program enable button to enable the programmer.

When you enable the programmer the right baud rate will be set.

When you are finished you must press the Enable button again to disable it.

This way you can have a micro connected to your COM port that works with a different BAUD rate.

There is an option to select between FLASH and EEPROM.

The prompt will show the current mode which is set to FLASH by default.

The buttons on the toolbar allow you to :

ERASE, PROGRAM, VERIFY, DUMP and set the LOCK BITS.

When DUMP is selected you will be asked for a file name.

When the DUMP is ready you must CLOSE the LOGFILE where the data is stored. This can be done to select the CLOSE LOGFILE option form the menu.

THIS PROGRAMMED IS MARKED FOR REMOVAL. Send a note to support if you use it.

---

## Language Fundamentals

Characters from the BASCOM character set are put together to form labels, keywords, variables and operators.

These in turn are combined to form the statements that make up a program.

This chapter describes the character set and the format of BASCOM program lines. In particular, it discusses:

•| The specific characters in the character set and the special meanings of some characters.  
---|---  
  
•| The format of a line in a BASCOM program.  
---|---  
  
•| Line labels.  
---|---  
  
•| Program line length.  
---|---  
  
Character Set

The BASCOM BASIC character set consists of alphabetic characters, numeric characters, and special characters.

The alphabetic characters in BASCOM are the uppercase letters (A-Z) and lowercase letters (a-z) of the alphabet.

The BASCOM numeric characters are the digits 0-9.

The letters A-H can be used as parts of hexadecimal numbers.

The following characters have special meanings in BASCOM statements and expressions:

Character | Name  
---|---  
ENTER | Terminates input of a line  
| Blank ( or space)  
' | Single quotation mark (apostrophe)  
* | Asterisks (multiplication symbol)  
+ | Plus sign  
, | Comma  
- | Minus sign  
. | Period (decimal point)  
/ | Slash (division symbol) will be handled as \  
: | Colon  
" | Double quotation mark  
; | Semicolon  
< | Less than  
= | Equal sign (assignment symbol or relational operator)  
> | Greater than  
\ | Backslash (integer/word division symbol)  
^ | Exponent  
  
The BASCOM program line

BASCOM program lines have the following syntax:

[[line-identifier]] [[statement]] [[:statement]] ... [[comment]]

Using Line Identifiers

BASCOM support one type of line-identifier; alphanumeric line labels:

An alphabetic line label may be any combination of from 1 to 32 letters and digits, starting with a letter and ending with a colon.

BASCOM keywords are not permitted.

The following are valid alphanumeric line labels:

Alpha:

ScreenSUB:

Test3A:

Case is not significant. The following line labels are equivalent:

alpha:

Alpha:

ALPHA:

Line labels may begin in any column, as long as they are the first characters other than blanks on the line.

Blanks are not allowed between an alphabetic label and the colon following it.

A line can have only one label. When there is a label on the line, no other identifiers may be used on the same line. So the label is the sole identifier on a line.

BASCOM Statements

A BASCOM statement is either "executable" or " non-executable".

An executable statement advances the flow of a programs logic by telling the program what to do next.

Non executable statement perform tasks such as allocating storage for variables, declaring and defining variable types.

The following BASCOM statements are examples of non-executable statements:

•| REM or (starts a comment)  
---|---  
  
•| DIM  
---|---  
  
A "comment" is a non-executable statement used to clarify a programs operation and purpose.

A comment is introduced by the REM statement or a single quote character(').

The following lines are equivalent:

```vb
PRINT " Quantity remaining" : REM Print report label.  
PRINT " Quantity remaining" ' Print report label.

```
More than one BASCOM statement can be placed on a line, but colons(:) must separate statements, as illustrated below.

FOR I = 1 TO 5 : PRINT " Gday, mate." : NEXT I

Comment

Comment is intended to clarify your code. Describe what the code is supposed to do. 

You can use single line comment using the REM statement. By default, comment is shown in green. 

Since REM is a lot of type work, you can also use the ' sign 

When you want to comment multiple lines, you can also use block comment. 

Block comment starts with '(

It ends with ')

Please notice that block comment must be the first non white space on the line. 

Rem some comment  
```vb
Print 'also comment  
'( block  
```
comment  
multiple lines  
') print "ok"  


BASCOM LineLength

If you enter your programs using the built-in editor, you are not limited to any line length, although it is advised to shorten your lines to 80 characters for clarity.

Data Types

Every variable in BASCOM has a data type that determines what can be stored in the variable. The next section summarizes the elementary data types.

Elementary Data Types

Type | Bytes used | Range | Description  
---|---|---|---  
Bit | 1/8 Byte | 0-1 | A bit can hold only the value 0 or 1. A group of 8 bits is called a byte  
Byte | 1 Byte | 0 to 255 | Bytes are stored as unsigned 8-bit binary numbers  
Integer | 2 Bytes | -32,768 to +32,767 | Integers are stored as signed sixteen-bit binary numbers  
Word | 2 Bytes | 0 to 65535 | Words are stored as unsigned sixteen-bit binary numbers  
Dword | 4 Bytes | 0 to 4294967295 | Dwords are stored as unsigned 32-bit binary numbers  
Long | 4 Bytes | -2147483648 to 2147483647 | Longs are stored as signed 32-bit binary numbers  
Single | 4 Bytes | 1.5 x 10^â45 to 3.4 x 10^38 | Singles are stored as signed 32 bit binary numbers  
Double | 8 Bytes | 5.0 x 10^â324 to 1.7 x 10^308 | Doubles are stored as signed 64 bit binary numbers  
String | up to 254 Bytes |   
| Strings are stored as bytes and are terminated with a chr(0) byte. A string dimensioned with a length of 10 bytes will occupy 11 bytes  
  
Variables can be stored internal (default) , external or in EEPROM.

Variables

A variable is a name that refers to an object--a particular number.

A numeric variable, can be assigned only a numeric value (either integer, byte, long, single or bit).

The following list shows some examples of variable assignments:

•| A constant value:  
---|---  
  
A = 5

C = 1.1

•| The value of another numeric variable:  
---|---  
  
abc = def

k = g

•| The value obtained by combining other variables, constants, and operators: Temp = a + 5  
---|---  
  
Temp = C + 5

•| The value obtained by calling a function:  
---|---  
  
Temp = Asc(S)

Constants

A constant is a placeholder for a fixed value : you can assign it with a value only once : CONST Something = 100

Constants can be assigned with a numeric or string value. To assign a string use double quotes : CONST SomeString = "BASCOM"

You can also use expressions with constants : CONST SomeThing = 1 + 2 / (3+4)

When you keep the SHIFT key pressed and hover the mouse cursor over a constant, a tooltip/hint will show the value.

When using numeric constants in [DATA](data_2.md) lines, you need to inform the compiler about the data type. This is done by ending the constant value with a suffix. See the help for DATA.

Variable Names

A BASCOM variable name may contain up to 32 characters.

The characters allowed in a variable name are letters and numbers.

The first character in a variable name must be a letter.

A variable name cannot be a reserved word, but embedded reserved words are allowed.

For example, the following statement is illegal because AND is a reserved word.

AND = 8

However, the following statement is legal:

ToAND = 8

Reserved words include all BASCOM commands, statements, function names, internal registers and operator names.

(see [BASCOM Reserved Words](reserved_words.md) , for a complete list of reserved words).

You can specify a hexadecimal or binary number with the prefix &H or &B.

a = &HA , a = &B1010 and a = 10 are all the same.

Before assigning a variable, you must tell the compiler about it with the [DIM](dim.md) statement.

Dim b1 As Bit, I as Integer, k as Byte , s As String * 10

The STRING type needs an additional parameter to specify the length.

You can also use [DEFINT](defxxx.md), [DEFBIT](defxxx.md), [DEFBYTE](defxxx.md) ,[DEFWORD](defxxx.md) ,[DEFLNG](defxxx.md) or [DEFSNG](defxxx.md).

For example,DEFINT c tells the compiler that all variables that are not dimensioned and that are beginning with the character c are of the Integer type.

BITS and Interrupts

Bits are stored in bytes. A write to a bit/boolean variable is non-atomic. Which means that multiple operations are required to update the bit value in the byte. When interrupts are used that update bits in the same byte, you can have the effect that a change becomes lost.

To prevent this you can disable interrupts and enable them after you have updated the bit variable. Or you can use a byte instead which is recommended since it would use less code. 

Expressions and Operators

This chapter discusses how to combine, modify, compare, or get information about expressions by using the operators available in BASCOM.

Anytime you do a calculation you are using expressions and operators.

This chapter describes how expressions are formed and concludes by describing the following kind of operators:

•| Arithmetic operators, used to perform calculations.  
---|---  
  
•| Relational operators, used to compare numeric or string values.  
---|---  
  
•| Logical operators, used to test conditions or manipulate individual bits.  
---|---  
  
•| Functional operators, used to supplement simple operators.  
---|---  
  
Expressions and Operators

An expression can be a numeric constant, a variable, or a single value obtained by combining constants, variables, and other expressions with operators.

Operators perform mathematical or logical operations on values.

The operators provided by BASCOM can be divided into four categories, as follows:

1\. Arithmetic

2\. Relational

3\. Logical

4\. Functional

Arithmetic

Arithmetic operators are +, - , * , \, / and ^.

•| Integer  
---|---  
  
Integer division is denoted by the backslash (\\).

Example: Z = X \ Y

•| Modulo Arithmetic  
---|---  
  
Modulo arithmetic is denoted by the modulus operator MOD.

Modulo arithmetic provides the remainder, rather than the quotient, of an integer division.

Example: X = 10 \ 4 : remainder = 10 MOD 4

•| Overflow and division by zero  
---|---  
  
Division by zero, produces an error.

At the moment no message is produced, so you have to make sure yourself that this won't happen.

Relational Operators

Relational operators are used to compare two values as shown in the table below.

The result can be used to make a decision regarding program flow.

Operator | Relation Tested | Expression   
---|---|---  
= | Equality | X = Y  
<> | Inequality | X <> Y  
< | Less than | X < Y  
> | Greater than | X > Y  
<= | Less than or equal to | X <= Y  
>= | Greater than or equal to | X >= Y  
  
Logical Operators

Logical operators perform tests on relations, bit manipulations, or Boolean operators.

There four operators in BASCOM are : 

Operator | Meaning  
---|---  
NOT | Logical complement  
AND | Conjunction  
OR | Disjunction  
XOR | Exclusive or  
  
It is possible to use logical operators to test bytes for a particular bit pattern.

For example the AND operator can be used to mask all but one of the bits of a status byte, while OR can be used to merge two bytes to create a particular binary value.

Example

A = 63 And 19  
PRINT A  
A = 10 Or 9  
PRINT A

Output

19

11

Floating point SINGLE (4 BYTE)(ASM code used is supplied by Jack Tidwell)

Single numbers conforming to the IEEE binary floating point standard.

An eight bit exponent and 24 bit mantissa are supported.

Using four bytes the format is shown below:

31 30________23 22______________________________0

s exponent mantissa

The exponent is biased by 128. Above 128 are positive exponents and below are negative. The sign bit is 0 for positive numbers and 1 for negative. The mantissa is stored in hidden bit normalized format so that 24 bits of precision can be obtained.

All mathematical operations are supported by the single.

You can also convert a single to an integer or word or vise versa:

Dim I as Integer, S as Single

S = 100.1 'assign the single

I = S 'will convert the single to an integer

Here is a fragment from the Microsoft knowledge base about FP:

Floating-point mathematics is a complex topic that confuses many programmers. The tutorial below should help you recognize programming situations where floating-point errors are likely to occur and how to avoid them. It should also allow you to recognize cases that are caused by inherent floating-point math limitations as opposed to actual compiler bugs.

Decimal and Binary Number Systems

Normally, we count things in base 10. The base is completely arbitrary. The only reason that people have traditionally used base 10 is that they have 10 fingers, which have made handy counting tools.

The number 532.25 in decimal (base 10) means the following:

(5 * 10^2) + (3 * 10^1) + (2 * 10^0) + (2 * 10^-1) + (5 * 10^-2)

500 + 30 + 2 + 2/10 + 5/100

_________

= 532.25

In the binary number system (base 2), each column represents a power of 2 instead of 10. For example, the number 101.01 means the following:

(1 * 2^2) + (0 * 2^1) + (1 * 2^0) + (0 * 2^-1) + (1 * 2^-2)

4 + 0 + 1 + 0 + 1/4

_________

= 5.25 Decimal

How Integers Are Represented in PCs

\-----------------------------------

Because there is no fractional part to an integer, its machine representation is much simpler than it is for floating-point values. Normal integers on personal computers (PCs) are 2 bytes (16 bits) long with the most significant bit indicating the sign. Long integers are 4 bytes long.

Positive values are straightforward binary numbers. For example:

1 Decimal = 1 Binary

2 Decimal = 10 Binary

22 Decimal = 10110 Binary, etc.

However, negative integers are represented using the two's complement scheme. To get the two's complement representation for a negative number, take the binary representation for the number's absolute value and then flip all the bits and add 1. For example:

4 Decimal = 0000 0000 0000 0100

1111 1111 1111 1011 Flip the Bits

-4 = 1111 1111 1111 1100 Add 1

Note that adding any combination of two's complement numbers together

using ordinary binary arithmetic produces the correct result.

Floating-Point Complications

Every decimal integer can be exactly represented by a binary integer; however, this is not true for fractional numbers. In fact, every number that is irrational in base 10 will also be irrational in any system with a base smaller than 10.

For binary, in particular, only fractional numbers that can be represented in the form p/q, where q is an integer power of 2, can be expressed exactly, with a finite number of bits.

Even common decimal fractions, such as decimal 0.0001, cannot be represented exactly in binary. (0.0001 is a repeating binary fraction with a period of 104 bits!)

This explains why a simple example, such as the following

SUM = 0  
FOR I% = 1 TO 10000  
SUM = SUM + 0.0001  
```vb
NEXT I%  
PRINT SUM ' Theoretically = 1.0.

```
will PRINT 1.000054 as output. The small error in representing 0.0001

in binary propagates to the sum.

For the same reason, you should always be very cautious when making comparisons on real numbers. The following example illustrates a common programming error:

item1# = 69.82#

item2# = 69.20# + 0.62#

IF item1# = item2# then print "Equality!"

This will NOT PRINT "Equality!" because 69.82 cannot be represented exactly in binary, which causes the value that results from the assignment to be SLIGHTLY different (in binary) than the value that is generated from the expression. In practice, you should always code such comparisons in such a way as to allow for some tolerance.

General Floating-Point Concepts

It is very important to realize that any binary floating-point system can represent only a finite number of floating-point values in exact form. All other values must be approximated by the closest represent able value. The IEEE standard specifies the method for rounding values to the "closest" represent able value. BASCOM supports the standard and rounds according to the IEEE rules.

Also, keep in mind that the numbers that can be represented in IEEE are spread out over a very wide range. You can imagine them on a number line. There is a high density of represent able numbers near 1.0 and -1.0 but fewer and fewer as you go towards 0 or infinity.

The goal of the IEEE standard, which is designed for engineering calculations, is to maximize accuracy (to get as close as possible to the actual number). Precision refers to the number of digits that you can represent. The IEEE standard attempts to balance the number of bits dedicated to the exponent with the number of bits used for the fractional part of the number, to keep both accuracy and precision within acceptable limits.

IEEE Details

Floating-point numbers are represented in the following form, where

[exponent] is the binary exponent:

X = Fraction * 2^(exponent - bias)

[Fraction] is the normalized fractional part of the number, normalized because the exponent is adjusted so that the leading bit is always a 1. This way, it does not have to be stored, and you get one more bit of precision. This is why there is an implied bit. You can think of this like scientific notation, where you manipulate the exponent to have one digit to the left of the decimal point, except in binary, you can always manipulate the exponent so that the first bit is a 1, since there are only 1s and 0s.

[bias] is the bias value used to avoid having to store negative exponents.

The bias for single-precision numbers is 127 and 1023 (decimal) for double-precision numbers.

The values equal to all 0's and all 1's (binary) are reserved for representing special cases. There are other special cases as well, that indicate various error conditions.

Single-Precision Examples

2 = 1 * 2^1 = 0100 0000 0000 0000 ... 0000 0000 = 4000 0000 hex

Note the sign bit is zero, and the stored exponent is 128, or

100 0000 0 in binary, which is 127 plus 1. The stored mantissa is (1.)

000 0000 ... 0000 0000, which has an implied leading 1 and binary point, so the actual mantissa is 1.

-2 = -1 * 2^1 = 1100 0000 0000 0000 ... 0000 0000 = C000 0000 hex

Same as +2 except that the sign bit is set. This is true for all IEEE format floating-point numbers.

4 = 1 * 2^2 = 0100 0000 1000 0000 ... 0000 0000 = 4080 0000 hex

Same mantissa, exponent increases by one (biased value is 129, or 100 0000 1 in binary.

6 = 1.5 * 2^2 = 0100 0000 1100 0000 ... 0000 0000 = 40C0 0000 hex

Same exponent, mantissa is larger by half -- it's

(1.) 100 0000 ... 0000 0000, which, since this is a binary fraction, is 1-1/2 (the values of the fractional digits are 1/2, 1/4, 1/8, etc.).

1 = 1 * 2^0 = 0011 1111 1000 0000 ... 0000 0000 = 3F80 0000 hex

Same exponent as other powers of 2, mantissa is one less than 2 at 127, or 011 1111 1 in binary.

.75 = 1.5 * 2^-1 = 0011 1111 0100 0000 ... 0000 0000 = 3F40 0000 hex

The biased exponent is 126, 011 1111 0 in binary, and the mantissa is (1.) 100 0000 ... 0000 0000, which is 1-1/2.

2.5 = 1.25 * 2^1 = 0100 0000 0010 0000 ... 0000 0000 = 4020 0000 hex

Exactly the same as 2 except that the bit which represents 1/4 is set in the mantissa.

0.1 = 1.6 * 2^-4 = 0011 1101 1100 1100 ... 1100 1101 = 3DCC CCCD hex

1/10 is a repeating fraction in binary. The mantissa is just shy of 1.6, and the biased exponent says that 1.6 is to be divided by 16 (it is 011 1101 1 in binary, which is 123 n decimal). The true exponent is 123 - 127 = -4, which means that the factor by which to multiply is 2**-4 = 1/16. Note that the stored mantissa is rounded up in the last bit. This is an attempt to represent the un-representable number as accurately as possible. (The reason that 1/10 and 1/100 are not exactly representable in binary is similar to the way that 1/3 is not exactly representable in decimal.)

0 = 1.0 * 2^-128 = all zeros -- a special case.

Other Common Floating-Point Errors

The following are common floating-point errors:

1\. Round-off error

This error results when all of the bits in a binary number cannot be used in a calculation.

Example: Adding 0.0001 to 0.9900 (Single Precision)

Decimal 0.0001 will be represented as:

(1.)10100011011011100010111 * 2^(-14+Bias) (13 Leading 0s in Binary!)

0.9900 will be represented as:

(1.)11111010111000010100011 * 2^(-1+Bias)

Now to actually add these numbers, the decimal (binary) points must be aligned. For this they must be Unnormalized. Here is the resulting addition:

.000000000000011010001101 * 2^0 <\- Only 11 of 23 Bits retained

+.111111010111000010100011 * 2^0

________________________________

.111111010111011100110000 * 2^0

This is called a round-off error because some computers round when shifting for addition. Others simply truncate. Round-off errors are important to consider whenever you are adding or multiplying two very different values.

2\. Subtracting two almost equal values

.1235

-.1234

_____

.0001

This will be normalized. Note that although the original numbers each had four significant digits, the result has only one significant digit.

3\. Overflow and underflow

This occurs when the result is too large or too small to be represented by the data type.

4\. Quantizing error

This occurs with those numbers that cannot be represented in exact form by the floating-point standard.

Rounding

When a Long is assigned to a single, the number is rounded according to the rules of the IEEE committee.

For explanation: 1.500000 is exact the middle between 1.00000 and 2.000000. If x.500000 is always rounded up, than there is trend for higher values than the average of all numbers. So their rule says, half time to round up and half time to round down, if value behind LSB is exact ..500000000.

The rule is, round this .500000000000 to next even number, that means if LSB is 1 (half time) to round up, so the LSB is going to 0 (=even), if LSB is 0 (other half time) to round down, that means no rounding.

This rounding method is best since the absolute error is 0.

You can override the default IEEE rounding method by specifying the $LIB LONG2FLOAT.LBX library which rounds up to the next number. This is the method used up to 1.11.7.4 of the compiler.

Double

The double is essential the same as a single. Except the double consist of 8 bytes instead of 4. The exponent is 11 bits leaving 52 bits for the mantissa.

Arrays

An array is a set of sequentially indexed elements having the same type. Each element of an array has a unique index number that identifies it. Changes made to an element of an array do not affect the other elements.

The index must be a numeric constant, a byte, an integer, word or long.

The maximum number of elements is 65535. For Xmega with huge memory it is 8MB!

The first element of an array is always one by default. This means that elements are 1-based.

You can change this with CONFIG BASE=0. In this case, the first element will be element 0.

Arrays can be used on each place where a 'normal' variable is expected.

You can add an offset to the index too. This could be used to emulate a 2 dimensional array.

row_index = row : shift row_index, left,4

value = parameter_array(column+row_index)

Example:

```vb
'create an array named a, with 10 elements (1 to 10)  
Dim A(10) As Byte  
'create an integer  
Dim C As Integer  
'now fill the array  
For C = 1 To 10  
'assign array element  
```
A(c)= C  
```vb
' print it  
Print A(c)  
Next  
'you can add an offset to the index too  
```
C = 0  
A(c + 1)= 100  
```vb
Print A(c + 1)  
End

```
Strings

A string is used to store text. A string must be dimensioned with the length specified.

DIM S as STRING * 5

Will create a string that can store a text with a maximum length of 5 bytes.

The space used is 6 bytes because a string is terminated with a null byte.

To assign the string:

Ds = "abcd"

To insert special characters into the string :

s= "AB{027}cd"

The {ascii} will insert the ASCII value into the string.

The number of digits must be 3. 

s = "{27}" will assign "{27}" to the string instead of escape character 27!

Because the null byte (ASCII 0) is used to terminate a string, you can not embed a null byte into a string.

Casting

In BASCOM-AVR when you perform operations on variables they all must be of the same data type.

long = long1 * long2 ' for example

The assigned variables data type determines what kind of math is performed.

```vb
For example when you assign a long, long math will be used.

If you try to store the result of a LONG into a byte, only the LSB of the LONG will be stored into the BYTE.

```
Byte = LONG

When LONG = 256 , it will not fit into a BYTE. The result will be 256 AND 255 = 0.

Of course you are free to use different data types. The correct result is only guaranteed when you are using data types of the same kind or that result always can fit into the target data type.

When you use strings, the same rules apply. But there is one exception:

Dim b as Byte  
  
b = 123 ' ok this is normal  
b = "A" ' b = 65

When the target is a byte and the source variable is a string constant denoted by "", the ASCII value will be stored in the byte. This works also for tests :

```vb
IF b = "A" then ' when b = 65  
  
END IF

```
This is different compared to QB/VB where you can not assign a string to a byte variable.

SINGLE CONVERSION

When you want to convert a SINGLE into a byte, word, integer or long the compiler will automatic convert the values when the source string is of the SINGLE data type.

integer = single

You can also convert a byte, word, integer or long into a SINGLE by assigning this variable to a SINGLE.

single = long

---

## Lawicel BootLoader

The Lawicel Boot loader must be used with the StAVeR. The StAVeR contains a boot loader so you only need a serial interface, no parallel programmer or other programmers.  
  
You can also use Hyper terminal.

When you have selected the Lawicel Boot loader from the Options, Programmer, the following window will appear when you press F4.

![lawicelBootLoader](lawicelbootloader.gif)

As the window suggests, press the reset button on the activity board or StAVeR, and the chip will be programmed. This is visible by a second wind that will be shown during programming.

When the programming succeeds, both windows will be closed.

When an error occurs, you will get an error message and you can clock the Cancel button in order to return to the Editor.

THIS PROGRAMMED IS MARKED FOR REMOVAL. Send a note to support if you use it.

---

## LCASE

Action

Converts a string in to all lower case characters.

Syntax

Target = LCASE(source)

Remarks

Target | The string that is assigned with the lower case string of string target.  
---|---  
Source | The source string.  
  
LCASE supports [$BIGSTRINGS](bigstrings.md)

See also

[UCASE](ucase.md)

ASM

The following ASM routines are called from MCS.LIB : _LCASE

The generated ASM code : (can be different depending on the micro used )

;##### Z = Lcase(s)

Ldi R30,$60

Ldi R31,$00 ; load constant in register

Ldi R26,$6D

Rcall _Lcase

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As String * 12 , Z As String * 12

```
S = "Hello World"

Z = Lcase(s)

Print Z

Z = Ucase(s)

```vb
Print Z

End

```

---

## LEFT

Action

Return the specified number of leftmost characters in a string.

Syntax

var = LEFT(var1 , n)

Remarks

Var | The string that is assigned.  
---|---  
Var1 | The source string.  
n | The number of characters to get from the source string.  
  
LEFT supports [$BIGSTRINGS](bigstrings.md)

See also

[RIGHT](right.md) , [MID](mid.md)

Partial Example

Dim S As String * 15 , Z As String * 15

S ="ABCDEFG"

Z = Left(s , 5)

Print Z 'ABCDE

Z = Right(s , 3) : Print Z

Z = Mid(s , 2 , 3) : Print Z

End

---

## LEN

Action

Returns the length of a string.

Syntax

var = LEN( string )

Remarks

var | A numeric variable that is assigned with the length of string.  
---|---  
string | The string to calculate the length of.  
  
Strings can be maximum 254 bytes long.

When using $BIGSTRINGS, the string can be as long as 65534 bytes. This depends on the available memory.

LEN supports [$BIGSTRINGS](bigstrings.md)

See Also

[VAL](val.md)

Partial Example

Dim S As String * 15 , Z As String * 15

S ="ABCDEFG"

Print Len(s)

---

## LINE

Action

Draws a line on a graphic display.

Syntax

LINE(x0,y0) - (x1,y1), color

Remarks

X0 | Starting horizontal location of the line.  
---|---  
Y0 | Starting vertical location of the line.  
X1 | Horizontal end location of the line  
Y1 | Vertical end location of the line.  
color | The color to use. Use 0 or a non zero value.  
  
See Also

[LINE](line.md) , [CONFIG GRAPHLCD](config_graphlcd.md) , [BOX](box.md) , [BOXFILL](boxfill.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : t6963_240_128.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : T6963C graphic display support demo 240 * 128

'micro : Mega8535

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m8535.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'-----------------------------------------------------------------

' (c) 1995-2025 MCS Electronics

' T6963C graphic display support demo 240 * 128

'-----------------------------------------------------------------

'The connections of the LCD used in this demo

'LCD pin connected to

' 1 GND GND

'2 GND GND

'3 +5V +5V

'4 -9V -9V potmeter

'5 /WR PORTC.0

'6 /RD PORTC.1

'7 /CE PORTC.2

'8 C/D PORTC.3

'9 NC not conneted

'10 RESET PORTC.4

'11-18 D0-D7 PA

'19 FS PORTC.5

'20 NC not connected

'First we define that we use a graphic LCD

' Only 240*64 supported yet

Config Graphlcd = 240 * 128 , Dataport = Porta , Controlport = Portc , Ce = 2 , Cd = 3 , Wr = 0 , Rd = 1 , Reset = 4 , Fs = 5 , Mode = 8

'The dataport is the portname that is connected to the data lines of the LCD

'The controlport is the portname which pins are used to control the lcd

'CE, CD etc. are the pin number of the CONTROLPORT.

' For example CE =2 because it is connected to PORTC.2

'mode 8 gives 240 / 8 = 30 columns , mode=6 gives 240 / 6 = 40 columns

'Dim variables (y not used)

Dim X As Byte , Y As Byte

'Clear the screen will both clear text and graph display

```
Cls

```vb
'Other options are :

' CLS TEXT to clear only the text display

' CLS GRAPH to clear only the graphical part

```
Cursor Off

```vb
Wait 1

'locate works like the normal LCD locate statement

' LOCATE LINE,COLUMN LINE can be 1-8 and column 0-30

```
Locate 1 , 1

'Show some text

Lcd "MCS Electronics"

'And some othe text on line 2

Locate 2 , 1 : Lcd "T6963c support"

Locate 3 , 1 : Lcd "1234567890123456789012345678901234567890"

Locate 16 , 1 : Lcd "write this to the lower line"

Wait 2

Cls Text

```vb
'use the new LINE statement to create a box

'LINE(X0,Y0) - (X1,Y1), on/off

```
Line(0 , 0) -(239 , 127) , 255 ' diagonal line

Line(0 , 127) -(239 , 0) , 255 ' diagonal line

Line(0 , 0) -(240 , 0) , 255 ' horizontal upper line

Line(0 , 127) -(239 , 127) , 255 'horizontal lower line

Line(0 , 0) -(0 , 127) , 255 ' vertical left line

Line(239 , 0) -(239 , 127) , 255 ' vertical right line

```vb
Wait 2

' draw a line using PSET X,Y, ON/OFF

' PSET on.off param is 0 to clear a pixel and any other value to turn it on

For X = 0 To 140

```
Pset X , 20 , 255 ' set the pixel

```vb
Next

For X = 0 To 140

```
Pset X , 127 , 255 ' set the pixel

```vb
Next

Wait 2

'circle time

'circle(X,Y), radius, color

'X,y is the middle of the circle,color must be 255 to show a pixel and 0 to clear a pixel

For X = 1 To 10

```
Circle(20 , 20) , X , 255 ' show circle

Wait 1

Circle(20 , 20) , X , 0 'remove circle

```vb
Wait 1

Next

Wait 2

For X = 1 To 10

```
Circle(20 , 20) , X , 255 ' show circle

```vb
Waitms 200

Next

Wait 2

'Now it is time to show a picture

'SHOWPIC X,Y,label

'The label points to a label that holds the image data

```
Test:

Showpic 0 , 0 , Plaatje

Showpic 0 , 64 , Plaatje ' show 2 since we have a big display

Wait 2

Cls Text ' clear the text

```vb
End

'This label holds the mage data

```
Plaatje:

```vb
'$BGF will put the bitmap into the program at this location

$bgf "mcs.bgf"

'You could insert other picture data here

```

---

## LINEINPUT

Action

Read a Line from an opened File.

Syntax

LINEINPUT #bFileNumber, sLineText

LINE_INPUT #bFileNumber, sLineText

Remarks

BfileNumber | (Byte) File number, which identifies an opened file  
---|---  
SlineText | (String) A string, which is assigned with the next line from the file.  
  
Only valid for files opened in mode INPUT. Line INPUT works only with strings. It is great for working on text files.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileLineInput |   
---|---|---  
Input | r24: filenumber | X: Pointer to String to be written from file  
| r25: Stringlength |   
Output | r25: Errorcode | C-Flag: Set on Error  
  
Example

'Ok we want to check if the file contains the written lines

Ff = Freefile()' get file handle

Open "test.txt" For Input As #ff ' we can use a constant for the file too

```vb
Print Lof(#ff); " length of file"

Print Fileattr(#ff); " file mode" ' should be 1 for input

Do

```
LineInput #ff , S ' read a line

```vb
' line input is used to read a line of text from a file

Print S ' print on terminal emulator

Loop Until Eof(ff)<> 0

'The EOF() function returns a non-zero number when the end of the file is reached

'This way we know that there is no more data we can read

```
Close #ff

---

## LineWidth

Action

Specify the width of lines to be drawn with primitive LINES in 1/16th pixel precision.

Syntax

LineWdth width

Remarks

width | Line width in 1/16 pixel. The initial value is 16, range is 16 to 4095  
---|---  
  
Sets the width of drawn lines. The width is the distance from the center of the line to the outermost drawn pixel, in units

of 1/16 pixel. The valid range is from 16 to 4095 in terms of 1/16th pixel units.

Please note the LineWidth command will affect the LINES, LINE_STRIP, RECTS, EDGE_STRIP_A/B/R/L primitives.

Example

```vb
' Pseudocode

' The second line is drawn with a width of 80, for a 5 pixel radius

```
Begin_G LINES

Vertex2F 16 * 10, 16 * 30 

Vertex2F 16 * 150, 16 * 40

LineWidth 80

Vertex2F 16 * 10, 16 * 80

Vertex2F 16 * 150, 16 * 90

![clip0081](clip0081.png)

---

## LOAD

Action

Load specified TIMER with a reload value.

Syntax

LOAD TIMER , value

Remarks

TIMER | TIMER0 , TIMER1 or TIMER2(or valid timer name)  
---|---  
Value | The variable or value to load.  
  
The TIMER0 does not have a reload mode. But when you want the timer to generate an interrupt after 10 ticks for example, you can use the LOAD statement.

It will do the calculation : (256-value)

So LOAD TIMER0, 10 will load the TIMER0 with a value of 246 so that it will overflow after 10 ticks.

TIMER1 is a 16 bit counter so it will be loaded with the value of 65536-value.

See Also

NONE

Example

NONE

---

## LOADADR

Action

Loads the address of a variable into a register pair.

Syntax

LOADADR var , reg

Remarks

var | A variable which address must be loaded into the register pair X, Y or Z.  
---|---  
reg | The register X, Y or Z.  
  
The LOADADR statement serves as an assembly helper routine.

Example

```vb
Dim S As String * 12

Dim A As Byte

$ASM

```
loadadr S , X ; load address into R26 and R27

ld _temp1, X ; load value of location R26/R27 into R24(_temp1)

$END ASM

---

## LOADLABEL

Action

Assigns a word variable with the address of a label.

Syntax

Var = LOADLABEL(label )

Remarks

var | The variable that is assigned with the address of the label.  
---|---  
lbl | The name of the label  
  
In some cases you might need to know the address of a point in your program. To perform a Cpeek() for example.

You can place a label at that point and use LoadLabel to assign the address of the label to a variable.

When you assign a DWORD variable, the 24 bit address will be loaded into the variable. 

If you use Loadlabel on an EEPROM label (a label used in the $EEPROM data area) , these labels must precede the Loadlabel function.

This would be ok :

$eeprom ' eeprom image

label1:

data 1,2,3,4,5

label2:

data 6,7,8,9,10

```vb
$data ' back to normal mode

dim w as word

```
w=loadlabel(label2)

This code will work since the loadlabel is used after the EEPROM data labels.

---

## LOADWORDADR

Action

Loads the Z-register and sets RAMPZ if available.

Syntax

LOADWORDADR label

Remarks

label | The name of the label which address will be loaded into R30-R31 which form the Z-register.  
---|---  
  
The code that will be generated :

LDI R30,Low(label * 2)

LDI R31,High(label * 2)

LDI R24,1 or CLR R24

STS RAMPZ, R24

As the AVR uses a word address, to find a byte address we multiply the address with 2. RAMPZ forms together with pointer Z an address register. As the LS bit of Z is used to identify the lower or the upper BYTE of the address, it is extended with the RAMPZ to address more then 15 bits. For example the Mega128 has 128KB of space and needs the RAMPZ register set to the right value in order to address the upper or lower 64KB of space.

See also

[LOADLABEL](loadlabel.md), [LOADADR](loadadr.md) , [LOOKUP](lookup.md)

Example

LOADWORDADR label

---

## LOC

Action

Returns the position of last read or written Byte of the file

Syntax

lLastReadWritten = LOC (#bFileNumber)

Remarks

bFileNumber | (Byte) File number, which identifies an opened file  
---|---  
lLastReadWritten | (Long) Variable, assigned with the Position of last read or written Byte (1-based)  
  
This function returns the position of the last read or written Byte. If an error occurs, 0 is returned. Check DOS-Error in variable gbDOSError. If the file position pointer is changed with the command SEEK, this function can not be used till the next read/write operation.

This function differs from VB. In VB the byte position is divided by 128.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileLoc |   
---|---|---  
Input | r24: filenumber | X: Pointer to Long-variable, which gets th result  
Output | r25: Errorcode | C-Flag: Set on Error  
  
Example

' open the file in BINARY mode

Open "test.bin" For Binary As #2

Put #2 , B ' write a byte

Put #2 , W ' write a word

Put #2 , L ' write a long

Ltemp = Loc(#2)+ 1 ' get the position of the next byte

```vb
Print Ltemp ;" LOC" ' store the location of the file pointer

Print Lof(#2);" length of file"

Print Fileattr(#2);" file mode" ' should be 32 for binary

```
Put #2 , Sn ' write a single

Put #2 , Stxt ' write a string

Flush #2 ' flush to disk

Close #2

---

## LOCAL

Action

Dimensions a variable LOCAL to the function or sub program.

Syntax

LOCAL var As Type

Remarks

Var | The name of the variable  
---|---  
Type | The data type of the variable.  
  
There can be only LOCAL variables of the type BYTE, INTEGER, WORD, DWORD, LONG, SINGLE, DOUBLE or STRING.

A LOCAL variable is a temporary variable that is stored on the frame.

When the SUB or FUNCTION is terminated, the memory will be released back to the system.

A Sub/Function is full reentrant which means that it can be called recursively. Because of this, local memory is dynamic and not static as global variables.

BIT variables are not possible because they are GLOBAL to the system.

The AT , ERAM, SRAM, XRAM directives can not be used with a local DIM statement. Also local arrays are not possible.

Notice that a LOCAL variable is not initialized. It will contain a value that will depend on the value of the FRAME data. So you can not assume the variable is 0. If you like it to be 0, you need to assign it.

A normal DIM-med variable is also not initialized to 0. The reason all variables are 0 (and strings are ""), is that the RAM memory is cleared. With the [$NORAMCLEAR](_noramclear.md) option you can turn this behaviour off. 

So to conclude, a LOCAL variable will behave the same as a normal variable with the $NORAMCLEAR option enabled.

While it would be simple to initialize the LOCAL variables to 0, in most/all cases, you will assign a value to it anyway, so it would be a waste of code space.

See also

[DIM](dim.md)

ASM

NONE

Example

```vb
'-----------------------------------------------------------------------------------------

'name : declare.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrate using declare

'micro : Mega48

'suited for demo : yes

'commercial add on needed : no

' Note that the usage of SUBS works different in BASCOM-8051

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

' First the SUB programs must be declared

'Try a SUB without parameters

Declare Sub Test2()

'SUB with variable that can not be changed(A) and

'a variable that can be changed(B1), by the sub program

'When BYVAL is specified, the value is passed to the subprogram

'When BYREF is specified or nothing is specified, the address is passed to

'the subprogram

Declare Sub Test(byval A As Byte , B1 As Byte)

Declare Sub Testarray(byval A As Byte , B1 As Byte)

'All variable types that can be passed

'Notice that BIT variables can not be passed.

'BIT variables are GLOBAL to the application

Declare Sub Testvar(b As Byte , I As Integer , W As Word , L As Long , S As String)

'passing string arrays needs a different syntax because the length of the strings must be passed by the compiler

'the empty () indicated that an array will be passed

Declare Sub Teststr(b As Byte , Dl() As String)

Dim Bb As Byte , I As Integer , W As Word , L As Long , S As String * 10 'dim used variables

Dim Ar(10) As Byte

Dim Sar(10) As String * 8 'strng array

For Bb = 1 To 10

```
Sar(bb) = Str(bb) 'fill the array

Next

Bb = 1

'now call the sub and notice that we always must pass the first address with index 1

Call Teststr(bb , Sar(1))

Call Test2 'call sub

Test2 'or use without CALL

'Note that when calling a sub without the statement CALL, the enclosing parentheses must be left out

Bb = 1

Call Test(1 , Bb) 'call sub with parameters

```vb
Print Bb 'print value that is changed

'now test all the variable types

```
Call Testvar(bb , I , W , L , S )

```vb
Print Bb ; I ; W ; L ; S

'now pass an array

'note that it must be passed by reference

```
Testarray 2 , Ar(1)

```vb
Print "ar(1) = " ; Ar(1)

Print "ar(3) = " ; Ar(3)

$notypecheck ' turn off type checking

```
Testvar Bb , I , I , I , S

```vb
'you can turn off type checking when you want to pass a block of memory

$typecheck 'turn it back on

End

'End your code with the subprograms

'Note that the same variables and names must be used as the declared ones

Sub Test(byval A As Byte , B1 As Byte) 'start sub

Print A ; " " ; B1 'print passed variables

```
B1 = 3 'change value

```vb
'You can change A, but since a copy is passed to the SUB,

'the change will not reflect to the calling variable

End Sub

Sub Test2 'sub without parameters

Print "No parameters"

End Sub

Sub Testvar(b As Byte , I As Integer , W As Word , L As Long , S As String)

```
Local X As Byte

X = 5 'assign local

B = X

I = -1

W = 40000

L = 20000

S = "test"

```vb
End Sub

Sub Testarray(byval A As Byte , B1 As Byte) 'start sub

Print A ; " " ; B1 'print passed variables

```
B1 = 3 'change value of element with index 1

B1(1) = 3 'specify the index which does the same as the line above

B1(3) = 3 'modify other element of array

```vb
'You can change A, but since a copy is passed to the SUB,

'the change will not reflect to the calling variable

End Sub

'notice the empty() to indicate that a string array is passed

Sub Teststr(b As Byte , Dl() As String)

```
Dl(b) = Dl(b) + "add"

End Sub

---

## LOCATE

Action

Moves the LCD cursor to the specified position.

Syntax

LOCATE y , x

Remarks

X | Constant or variable with the position. (1-64*)  
---|---  
Y | Constant or variable with the line (1 - 4*)  
  
* Depending on the used display

See also

[CONFIG LCD](config_lcd.md) , [LCD](lcd_2.md) , [HOME](home.md) , [CLS](cls.md)

Partial Example

LCD "Hello"

Locate 1,10

LCD "*"

---

## LOF

Action

Returns the length of the File in Bytes

Syntax

lFileLength = LOF (#bFileNumber)

Remarks

bFileNumber | (Byte) Filenumber, which identifies an opened file  
---|---  
LFileLength | (Long) Variable, which assigned with the Length of the file (1-based)  
  
This function returns the length of an opened file. If an error occurs, 0 is returned. Check DOS-Error in variable gbDOSError.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileLOF |   
---|---|---  
Input | r24: filenumber | X: Pointer to Long-variable, which gets th result  
Output | r25: Errorcode | C-Flag: Set on Error  
  
Example

' open the file in BINARY mode

Open "test.bin" For Binary As #2

Put #2 , B ' write a byte

Put #2 , W ' write a word

Put #2 , L ' write a long

Ltemp = Loc(#2)+ 1 ' get the position of the next byte

```vb
Print Ltemp ;" LOC" ' store the location of the file pointer

Print Lof(#2);" length of file"

Print Fileattr(#2);" file mode" ' should be 32 for binary

```
Put #2 , Sn ' write a single

Put #2 , Stxt ' write a string

Flush #2 ' flush to disk

Close #2

---

## LOG

Action

Returns the natural logarithm of a floating point variable.

Syntax

Target = LOG(source)

Remarks

Target | The single or double that is assigned with the LOG() of single target.  
---|---  
Source | The source single or doubler to get the LOG of.  
  
See also

[EXP](exp.md) , [LOG10](log10.md)

Example

[Show sample](fp_trig.md)

---

## LOG10

Action

Returns the base 10 logarithm of a floating point variable.

Syntax

Target = LOG10(source)

Remarks

Target | The single or double that is assigned with the base 10 logarithm of single/double target.  
---|---  
Source | The source single or double to get the base 10 LOG of.  
  
See also

[EXP](exp.md) , [LOG](log.md)

Example

[Show sample](fp_trig.md)

---

## LOOKDOWN

Action

Returns the index of a series of data.

Syntax

var = LOOKDOWN( value, label, entries)

Remarks

Var | The returned index value  
---|---  
Value | The value to search for  
Label | The label where the data starts  
entries | The number of entries that must be searched  
  
When you want to look in BYTE series the VALUE variable must be dimensioned as a BYTE. When you want to look in INTEGER or WORD series the VALUE variable must be dimensioned as an INTEGER.

The LookDown function is the counterpart of the LookUp function.

Lookdown will search the data for a value and will return the index when the value is found. It will return â1 when the data is not found.

Lookdown() supports byte, integer, dword and long data types.

See also

[LOOKUPSTR](lookupstr.md) , [LOOKUP](lookup.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : lookdown.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : LOOKDOWN

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim Idx As Integer , Search As Byte , Entries As Byte

'we want to search for the value 3

```
Search = 3

'there are 5 entries in the table

Entries = 5

'lookup and return the index

Idx = Lookdown(search , Label , Entries)

Print Idx

Search = 1

Idx = Lookdown(search , Label , Entries)

Print Idx

Search = 100

Idx = Lookdown(search , Label , Entries)

```vb
Print Idx ' return -1 if not found

'looking for integer or word data requires that the search variable is

'of the type integer !

Dim Isearch As Integer

```
Isearch = 400

Idx = Lookdown(isearch , Label2 , Entries)

```vb
Print Idx ' return 3

End

```
Label:

Data 1 , 2 , 3 , 4 , 5

Label2:

Data 1000% , 200% , 400% , 300%

---

## LOOKUP

Action

Returns a value from a data table based on the index.

Syntax

var = LOOKUP( value, label)

Remarks

Var | The returned value  
---|---  
Value | A value with the index of the table  
Label | The label where the data starts. You may also use a variable that holds the address of a label. This way you can pass data to a sub module. When processors are used with multiple 64KB pages, the page RAMPZ will be set as well.  
  
The maximum index value to use is 65535. The first entry will return a value of 0.

All items in the data table must be of the same data type. So you can not mix bytes and singles for example.

The data type of the return value must match the data type of the items in the table.

So this is wrong :

dim x as single

x=lookup(2,Dta)

dta:

data 1,2,3 'data does not match the used single in lookup

See also

[LOOKUPSTR](lookupstr.md) , [DATA](data_2.md) , [LOOKDOWN](lookdown.md) , [LOADWORDADR](loadwordadr.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim B1 As Byte , I As Integer

```
B1 = Lookup(2 , Dta)

Print B1 ' Prints 3 (zero based)

I = Lookup(0 , Dta2) ' print 1000

```vb
Print I

End

```
Dta:

Data 1 , 2 , 3 , 4 , 5

Dta2:

Data 1000% , 2000%

---

## LOOKUPSTR

Action

Returns a string from a table.

Syntax

var = LOOKUPSTR( index, label )

Remarks

Var | The string returned  
---|---  
Index | A value with the index of the table. The index is zero-based. That is, 0 will return the first element of the table. The maximum value is 65535.  
Label | The label where the data starts. A variable with the address is accepted as well.  
  
See also

[LOOKUP](lookup.md) , [LOOKDOWN](lookdown.md) , [DATA](data_2.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As String * 8 , Idx As Byte

```
Idx = 0 : S = Lookupstr(idx , Sdata)

```vb
Print S 'will print 'This'

End

```
Sdata:

Data "This" , "is" , "a test"

---

## LOW

Action

Retrieves the least significant byte of a variable.

Sets the least significant byte of a variable

Syntax

var = LOW( s )

LOW( s ) = value

Remarks

Var | The variable that is assigned with the LSB of var S.  
---|---  
S | The source variable to get the LSB from when used as a function The target variable to set the LSB of when used in an assignment.  
value | The value to assign to the LSB when used as a statement  
  
You can also assign a byte to retrieve the LSB of a Word or Long.

For example :

B = L , where B is a byte and L is a Long.

In version 2083 the LOW function can also be used to set the LSB of a variable. This for compatibility with BASCOM-8051.

See also

[HIGH](high.md) , [HIGHW](highw.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim I As Integer , Z As Byte

```
I = &H1001

Z = Low(i) ' is 1

End

---

## LOWERLINE

Action

Reset the LCD cursor to the lower line.

Syntax

LOWERLINE

Remarks

NONE

See also

[UPPERLINE](upperline.md) , [THIRDLINE](thirdline.md) , [FOURTHLINE](fourthline.md) , [HOME](home.md)

Partial Example

Lcd "Test"

Lowerline

Lcd "Hello"

End

---

## LTRIM

Action

Returns a copy of a string with leading blanks removed

Syntax

var = LTRIM( org )

Remarks

Var | String that receives the result.  
---|---  
Org | The string to remove the leading spaces from  
  
LTRIM supports [$BIGSTRINGS](bigstrings.md)

See also

[RTRIM](rtrim.md) , [TRIM](trim.md)

ASM

NONE

Partial Example

Dim S As String * 6

S =" AB "

```vb
Print Ltrim(s)

Print Rtrim(s)

Print Trim(s)

End

```

---

## MACRO

Action

This statement allow you to define a Macro.

Syntax

MACRO name

macrodef

END MACRO

Remarks

name | The name of the macro. Each macro need to have a unique name.  
---|---  
macrodef | The code you want to have inserted when you use the macro.  
  
Macro's must be defined before they can be used. When a macro is defined but not used in your code, it will not be compiled. You can use $INCLUDE to include a large number of macro's.

When the compiler encounters the name of a defined macro, it will insert the defined code at that place. While it looks similar to a sub routine, there are differences. A sub routine for example is called and has a RETURN(RET).

See also

[SUB](sub.md) , [GOSUB](gosub.md)

Example

Macro Usb_reset_data_toggle

Ueconx.rstdt = 1

End Macro

Macro Usb_disable_stall_handshake

Ueconx.stallrqc = 1

End Macro

Macro Set_power_down_mode

Smcr = 0

Smcr = Bits(se , Sm1)

sleep

End Macro

Usb_reset_data_toggle ' this will insert UECONRX.RSTD=1

Set_power_down_mode ' this will insert the following code

Smcr = 0

Smcr = Bits(se , Sm1)

sleep

---

## Macro_R

Action

Execute a single command from a macro register.

Syntax

Macro_R m

Remarks

m | Macro register to read. Value 0 means the FT800 will fetch the command from REG_MACRO_0 to execute. Value 1 means the FT800 will fetch the command from REG_MACRO_1 to execute. The content of REG_MACRO_0 or REG_MACRO_1 shall be a valid display list command, otherwise the behavior  is undefined.  
---|---  
  
See Also

[CALL_C](call_c.md) , [JUMP](jump.md), [RETURN_C](return_c.md) , [DISPLAY_E](display_e.md)

---

## MAKEBCD

Action  
  
Convert a variable into its BCD value.

Syntax

var1 = MAKEBCD(var2)

Remarks

var1 | Variable that will be assigned with the converted value.  
---|---  
Var2 | Variable that holds the decimal value.  
  
When you want to use an I2C clock device, which stores its values as BCD values you can use this function to convert variables from decimal to BCD.

For printing the BCD value of a variable, you can use the BCD() function which converts a BCD number into a BCD string.

See also

[MAKEDEC](makedec.md) , [BCD](bcd.md) , [MAKEINT](makeint.md)

Example

Dim A As Byte

A = 65

Lcd A

Lowerline

Lcd Bcd(a)

A = Makebcd(a)

Lcd " " ; A

End

---

## MAKEDEC

Action

Convert a BCD byte or Integer/Word variable to its DECIMAL value.

Syntax

var1 = MAKEDEC(var2)

Remarks

var1 | Variable that will be assigned with the converted value.  
---|---  
var2 | Variable that holds the BCD value.  
  
When you want to use an I2C clock device, which stores its values as BCD values you can use this function to convert variables from BCD to decimal.

See also

[MAKEBCD](makebcd.md) , [MAKEBCD](makebcd.md), [MAKEINT](makeint.md)

Example

Dim A As Byte

A = 65

```vb
Print A

Print Bcd(a)

```
A = Makedec(a)

```vb
Print Spc(3) ; A

End

```

---

## MAKEINT

Action

Compact two bytes into a word or integer.

Syntax

varn = MAKEINT(LSB , MSB)

Remarks

Varn | Variable that will be assigned with the converted value.  
---|---  
LSB | Variable or constant with the LS Byte.  
MSB | Variable or constant with the MS Byte.  
  
The equivalent code is:

varn = (256 * MSB) + LSB

See also

[LOW](low.md) , [HIGH](high.md) , [MAKEBCD](makebcd.md) , [MAKEDEC](makedec.md)

Example

Dim A As Integer , I As Integer

A = 2

I = Makeint(a , 1) 'I = (1 * 256) + 2 = 258

End

---

## MAKEMODBUS

Action

Creates a MODBUS master/client frame.

Syntax

PRINT [#x,] MAKEMODBUS(slave, function, address, varbts )

Remarks

slave | The slave to address. This is a variable or constant with a valid MODBUS slave to address.  
---|---  
function | The function number. This must be a constant. At the moment the following functions are supported : | •| 01 : read coils  
---|---  
  
•| 02 : read discrete inputs  
---|---  
  
•| 03 : read register(s)  
---|---  
  
•| 04 : read input registers  
---|---  
  
•| 06 : write single register  
---|---  
  
•| 16 : write multiple registers  
---|---  
  
address | The starting address of the register  
varbts | For a function that sends data like function 6 and 16, this must be a variable. For function 06 which can only write a single register, this can be a byte or integer or word. For function 16 it may be a long, single or double. For function 6 and 16 the address of the variable is passed to the function. For function 1,2,3 and 4 you may also specify the number of bytes to receive. Or you can use a variable. When you specify a byte, a word will be used anyway since a word (2 bytes) is the minimum in MODBUS protocol. But when sending data, you can send content of a byte. For the MSB the value 0 will be sent in that case. With : CONFIG MODBUS = VAR  you can change the varbts mode. In VAR mode, you have to pass the number of bytes in the variable.   
  
The MAKEMODBUS function need to be used in combination with the PRINT statement. It can only be used with the hardware UART(1-4).

The MODBUS protocol is an industry standard. The protocol can be used with RS-232, RS-485 or TCP/IP or CAN. 

The current BASCOM implementation only works with RS-232 or RS485. 

In MODBUS we use client/master and server/slave. You may see it as a web server and a web browser. The web server is the client/slave that reacts on the master/web browser.

A slave will only respond when it is addressed. All other slaves just keep listening till they are addressed.

An addressed slave will process the data and send a response.

In MODBUS the data is sent with MSB first and LSB last. The special CRC16 checksum is sent LSB first and MSB last.

When multiple registers are sent with function 16, the data is split up into words, and for each word, the MSB-LSB order is used.

For example a LONG is 4 bytes. LSB, NSB1, NSB2, MSB. It would be sent as : NSB1, LSB, MSB, NSB2.

In order to use the MODBUS functionality, you need to include the MODBUS.LBX with the $LIB directive.

See also

[PRINT](print.md) , [CONFIG MODBUS](config_modbus.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : rs485-modbus-master.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo file for MAKEMODBUS

'micro : Mega162

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m162def.dat" ' specify the used micro

$crystal = 8000000

$baud = 19200 ' use baud rate

$hwstack = 42 ' default use 42 for the hardware stack

$swstack = 40 ' default use 40 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$lib "modbus.lbx" ' specify the additional library

Config Print1 = Portb.1 , Mode = Set ' specify RS-485 and direction pin

```
Rs485dir Alias Portb.1 'make an alias

Config Rs485dir = Output 'set direction register to output

Rs485dir = 0 ' set the pin to 0 for listening

Portc.0 = 1 ' a pin is used with a switch

```vb
'The circuit from the help is used. See Using MAX485

' TX RX

' COM0 PD.1 PD.0 rs232 used for debugging

' COM1 PB.3 PB.2 rs485 used for MODBUS halve duplex

' PB.1 data direction rs485

'configure the first UART for RS232

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

'configure the second UAR for RS485/MODBUS. Make sure all slaves/servers use the same settings

Config Com2 = 9600 , Synchrone = 0 , Parity = Even , Stopbits = 1 , Databits = 8 , Clockpol = 0

'use OPEN/CLOSE for using the second UART

```
Open "COM2:" For Binary As #1

```vb
'dimension some variables

Dim B As Byte

Dim W As Word

Dim L As Long

```
W = &H4567 'assign a value

L = &H12345678 'assign a value

```vb
Print "RS-485 MODBUS master"

Do

If Pinc.0 = 0 Then ' test switch

Waitms 500 ' delay

Print "send request to slave/server"

' Send one of the following three messages

' Print #1 , Makemodbus(2 , 3 , 8 , 2); ' slave 2, function 3, start address 8, 2 bytes

' Print #1 , Makemodbus(2 , 6 , 8 , W); ' slave 2, function 6, address 8 , value of w

Print #1 , Makemodbus(2 , 16 , 8 , L); ' slave 2, function 16, address 8 , send a long

End If

If Ischarwaiting(#1) <> 0 Then 'was something returned?

```
B = Waitkey(#1) 'then get it

```vb
Print Hex(b) ; ","; 'print the info

End If

Loop

End

```

---

## MANCHESTERDEC

Action

This functions decodes a Manchester encoded word into a byte.

Syntax

target = ManChesterDec(source)

Remarks

target | The byte variables that is assigned with the decoded Manchester value.  
---|---  
source | A Word variable containing the Manchester encoded value.  
  
Manchester encoding (also known as phase encoding) is a line code in which the encoding of each data bit is either low then high, or high then low, for equal time. It is a self-clocking signal with no DC component. Because each input bit is represented as 01 or 10, the resulting data is twice the size of the input data.

Manchester encoding is used with RF and IR data transmission.

When there is an error in the decoding, register R25 will be set to 255.

See also

[MANCHESTERENC](manchesterenc.md)

Example

```vb
'-----------------------PROJECT------------------------------------------------  
'name ManchesterCoding.BAS  
'copyright © 2018, MCS  
'purpose DEMO MANCHESTER ENCODING and DECODING  
'micro M1280  
'----------------------------------------------------------------  
$regfile = "m1280def.dat" ' specify the uC used  
$crystal = 32000000 ' Oscillator frequency  
$hwstack = 40 ' hardware stack  
$swstack = 40 ' software stack  
$framesize = 40 ' frame space  
  
Dim B As Byte , J As Byte , W As Word  
For J = 0 To 255  
```
W = Manchesterenc(j) ' encode into manchester code whith results into a WORD  
B = Manchesterdec(w) ' decode it back  
```vb
If R25 <> 0 Then ' when an error occurs, register r25 is 255  
Print "ERROR"  
End If  
Print J ; " " ; Hex(w) ; " " ; B  
Next

```

---

## MANCHESTERENC

Action

This functions encodes a byte into a Manchester encoded word.

Syntax

target = ManChesterEnc(source)

Remarks

target | A variable with a minimum data length of 2 such as a word.  
---|---  
source | A byte containing the data to convert.  
  
Manchester encoding (also known as phase encoding) is a line code in which the encoding of each data bit is either low then high, or high then low, for equal time. It is a self-clocking signal with no DC component. Because each input bit is represented as 01 or 10, the resulting data is twice the size of the input data.

Manchester encoding is used with RF and IR data transmission.

See also

[MANCHESTERDEC](manchesterdec.md)

Example

```vb
'-----------------------PROJECT------------------------------------------------  
'name ManchesterCoding.BAS  
'copyright © 2018, MCS  
'purpose DEMO MANCHESTER ENCODING and DECODING  
'micro M1280  
'----------------------------------------------------------------  
$regfile = "m1280def.dat" ' specify the uC used  
$crystal = 32000000 ' Oscillator frequency  
$hwstack = 40 ' hardware stack  
$swstack = 40 ' software stack  
$framesize = 40 ' frame space  
  
Dim B As Byte , J As Byte , W As Word  
For J = 0 To 255  
```
W = Manchesterenc(j) ' encode into manchester code whith results into a WORD  
B = Manchesterdec(w) ' decode it back  
```vb
If R25 <> 0 Then ' when an error occurs, register r25 is 255  
Print "ERROR"  
End If  
Print J ; " " ; Hex(w) ; " " ; B  
Next

```

---

## MAX

Action

Returns the maximum value of a byte or word array.

Syntax

var1 = MAX(var2)

MAX(ar(1), m ,idx)

Remarks

var1 | Variable that will be assigned with the maximum value.  
---|---  
var2 | The first address of the array.  
|   
| The MAX statement can return the index too  
Ar(1) | Starting element to get the maximum value and index of.  
M | Returns the maximum value of the array.  
Idx | Return the index of the array that contains the maximum value. Returns 0 if there is no maximum value.  
  
The MIN() and MAX() functions work on BYTE and WORD arrays only.

See also

[MIN](min.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : minmax.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : show the MIN and MAX functions

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

' These functions only works on BYTE and WORD arrays at the moment !!!!!

'Dim some variables

Dim Wb As Byte , B As Byte

Dim W(10) As Word ' or use a BYTE array

'fill the word array with values from 1 to 10

For B = 1 To 10

```
W(b) = B

```vb
Next

Print "Max number " ; Max(w(1))

Print "Min number " ; Min(w(1))

Dim Idx As Word , M1 As Word

```
Min(w(1) , M1 , Idx)

Print "Min number " ; M1 ; " index " ; Idx

Max(w(1) , M1 , Idx)

```vb
Print "Max number " ; M1 ; " index " ; Idx

End

```

---

## MCS Bootloader

The MCS Boot loader is intended to be used with the [$LOADER](loader.md) sample for normal AVR and XMega. For Xtiny, MegaX and AVRX check the [$ROMSTART](_romstart.md) topic.

It uses the X-modem Checksum protocol to upload the binary file. It works very quick.

The Boot loader sample can upload both normal flash programs and EEPROM images.

The Boot loader sends a byte with value of 123 to the AVR Boot loader. This boot loader program then enter the boot loader or will jump to the reset vector (0000) to execute the normal flash program.

When it receives 124 instead of 123, it will upload the EEPROM.

When you select a BIN file the flash will be uploaded. When you select an EEP file, the EEPROM will be uploaded.

The Boot loader has some specific options.

![mcsbootloader](mcsbootloader.jpg)

BOOTSIZE

You can choose the boot size which is 1024 for the BASCOM $LOADER example.

Since this space is used from the normal flash memory, it means your application has 1024 less words for the main application. (A word is 2 byte, so 2KB less)

The XMEGA has a separate boot space so for Xmega you can set the value to 0.

RESET

The boot loader is started when the chip is reset. Thus you need to reset the chip after you have pressed F4(program). But when you have connected the DTR line to the chip reset (with a MAX232 buffer) you can reset the chip automatically. You do need to set the 'Reset via DTR' option then. You can also chose to use the RTS line. When your program does not use the boot vector or needs a special sequence to activate the loader, you can chose the soft reset. To send ASCII characters you can embed them between brackets {}. For example {065} will be sent as the character A or byte with value 65.

CLOSE

By choosing 'Close programmer window when ready' the window will be closed when the loader returns 0.

In all other cases it will remain opened so you can look at a possible cause.

EEP

If an EEP (EEPROM image file) exists, the loader can send this file instead of the flash binary file. If you enable this option, you will be asked if you want to send the EEP instead of the BIN file.

After you have pressed F4 to following window will appear :

![MCS-bootloader](mcs-bootloader.jpg)

As you can see the loader sends a byte with value of 123.

You need to reset the chip, and then you will see that the loader returned 123 which means it received the value.

It will start the upload and you see a progress bar. After the loader is ready, you see a finish code of 0.

A finish code of 0 means that all wend well.

Other finish codes will not close the window even if this option is enabled.

You need to manual close the window then.

ERROR CODES

-6001 - Bad format in file name

-6002 - file not found

-6003 - file not found in folder

-6004 - folder not found

-6005 - canceled

-6006 - time out

-6007 - protocol error

-6008 - too many errors

-6009 - block sequence error

-6016 - session aborted 

The most likely error is -6006 when the bootloader is not present or does not respond timely after the initial handshake. Increase the $timeout in the boot loader in that case.

---

## MCS EDBG Programmer

The MCS EDBG programmer supports the Microchip EDBG programmers. We named it MCS EDBG Programmer since we implemented the EDBG protocol in BASCOM-AVR.

So what is an EDBG programmer? EDBG is a protocol for programming and debugging. 

The ones that BASCOM supports must work in USB HID device mode.

Originally the SNAP programmer was used for testing but Microchip made an update to the firmware using a different protocol which is not supported.

You can still use the SNAP programmer but you need to replace the firmware. This means doing the recovery mode procedure, then using AS7 to load the firmware for AVR. 

But it does not run out of the box and for this reason we do not recommend it for beginners. The SNAP programmer is however cheap and supports all AVR programmer modes.

Programmers can be obtained from Microchip. It does not require an additional windows driver since it is a so called HID device which is always supported.

You need the AVR UPDI license in order to use this programmer in BASCOM. Without UPDI license you can not code for the UPDI processors anyway.

The programmer should supports all Microchip EDBG UPDI programmers that identify as an Atmel device.

We tested with SNAP programmer V1, JTAGICE3, AVR128DB48-CNANO KIT and ATTINY817 Xplained. The explained series have an integrated programmer. 

The new curiosity : AVR64DU32 Curiosity Nano is a cheap test board from Microchip that also has an integrated programmer. You can separate some tracks and use it to program other processors as well.

Details can be found in the documentation from Microchip.

The goal of the EDBG programmer support was to support UPDI mode. Some programmers support ISP and PDI mode. But BASCOM does not support these modes yet. 

The ISP mode is in beta. It works for the ISP curiosity series. But no extensive tests were done. 

The PDI mode is in beta as well. It is tested on the xmega128A3. The DAT files are not adapted and thus it will not work correct on processors with a different memory configuration. 

The curiosity programmer only supports UPDI mode. SNAP supports all modes but does not work out of the box.

The great thing about EDBG programmers/hardware is that the protocol supports hardware debugging. BASCOM will support this too in a future version. 

The programmer interface looks familiar:

![mcs_snap_main](mcs_snap_main.png)

The FLASH TAB will show the content of the FLASH buffer. The content is loaded automatically when a BIN file exists of your project.

The EEPROM TAB will show the content of the EEPROM buffer. This is loaded automatically when an EEP file exists of your project.

The USERROW TAB will show the content of the USERROW buffer. This is loaded automatically when a USR file exists of your project.

The LOCK and FUSE Bits TAB is intended to program the various fuses.

The VOLTAGE TAB can be used to change the target voltage. But only when your programmer supports this. 

The INFO window on the bottom will show if a programmer is found. In this case it is the SNAP ICD. 

The yellow led will lit when there is a connection with a programmer.

The Session led will lt when there is a session active.

The Prog led wil lit when programming is active. 

When using automatic programming the session is created and ended automatically. 

When using manual programming you have the option (in Options, Programmer) to keep the session active. This to improve speed. On the other hand the programmer uses USB and the speed is great. 

Each time you program the flash memory the write count is increased. The serial number is used and stored in the file named updiserials.prg. The MCS UPDI programmer uses the same file to keep track of writing.

  


Menu Options

Option | Description  
---|---  
File |   
  
Exit | Close programmer.  
  
|   
  
Buffer |   
  
Clear | Clear buffer. Will put a value of 255 (FF hex) into each memory location. When the FLASH-TAB has the focus, the FLASH buffer will be cleared. When the EEPROM-TAB has the focus, the EEPROM buffer will be cleared. When the UserRow TAB has the focus the UserRow buffer will be cleared. 255 is the value of an empty memory location.  
Load from File | This will show an open file dialog so you can select a binary file (BIN) or a HEX file in Intel HEX format.  The file is loaded into the buffer. You can also manual edit the memory cells.  
Save to File | Will save the current buffer to a BIN (binary) or HEX (hexadecimal Intel HEX) file.  
Reload | Reloads the buffer from the file image. All programmers will always use the binary image to load files by default.  
  
|   
  
Microprocessor |   
  
Identify | Will attempt to read the signature of the processor. When the signature is unknown(no DAT file available) or there is no chip or other error, you will get an error. Otherwise the processor name will be shown.   
It is important that you include $REGFILE with the used processor in your code. For example :  
$regfile = "AVRX64da64.dat"  
Write buffer into processor memory | This will write the active buffer(FLASH, EEPROM or UserRow) into the processor.  
Read processor memory into buffer | When the chip lock bit is not set you can read the FLASH , EEPROM or UserRow memory into the buffer.  
Blank check | Checks if the chip FLASH , EEPROM or UserRow is empty.   
Erase microprocessor | Erases the processor FLASH. It depends on the fusebits if the EEPROM is erased too. Normally the EEPROM is erased too but some processors have a fuse bit to preserve EEPROM when erasing the chip. A processor MUST be erased before it can be programmed.  
Otherwise depending on the value of the memory cell, the cell can not be programmed.   
Erase EEPROM | Erases the EEPROM of the processor. The FLASH memory is not erased. When programming the EEPROM, all pages are automatically erased before programming.  
Unlock Microprocessor | Unlocks the processor. This is a special ERASE option. When the processor is locked with its fuse bytes, you can not program the processor. You can only unlock/erase it. This will also erase the fuse bytes!  
Verify microprocessor memory with buffer | Checks if the buffer matches the processor FLASH , EEPROM or UserRow.  
Auto program | This will erase, and program the FLASH and EEPROM. UPDI MODE When config FUSES is used in the code with the options set to ON, the lock and fuse bytes will be programmed too. When there is no EEPROM image, the EEPROM will not be programmed. For automatic fuse programming consider this : Config Fuses = On , Lock = Off , Fuse0 = &H00 , Fuse1 = &H64 , Fuse2 = &H00 , Fuse5 = &HD9 , Fuse6 = &H07 , Fuse7 = &H00 , Fuse8 = &H08 In this case automatic fuse programming is ON and all mentioned fuses will be programmed. Since LOCK is OFF , there will be no locks set. While developing you best set the fuse options to OFF :  Config Fuses = Off , Lock = Off , Fuse0 = &H00 , Fuse1 = &H64 , Fuse2 = &H00 , Fuse5 = &HD9 , Fuse6 = &H07 , Fuse7 = &H00 , Fuse8 = &H08 Remember, after locking a processor you need the UNLOCK option to be able to reprogram the processor. ISP and PDI MODE $PROG directive is used for ISP and PDI programming.   
  
The Lock and Fuse bits TAB

![mcs_snap_fuse1](mcs_snap_fuse1.png)

By default the lock and fuse bytes are not loaded. You need to click the REFRESH button to load the values.

![snap_locn_fuse](snap_locn_fuse.png)

When you alter the value of a fuse, depending on the kind of fuse you alter, the WRITE FUSES button, WRITE LOCK BITS or WRITE USER ROW button becomes enabled.

Clicking the button will update the fuse value(s). And the Lock and Fuse bits are read again. Reading all values can take some time.

The WRITE CONFIG button will write the current Lock and Fuse bit value to the editor. That is : the value as read from the processor. This is NOT the value as you alter it.

The idea is that you first test the settings. When all works, you use the WRITE CONFIG button which will write a line like this to the current editor position :

Config Fuses=Off,Lock=OFF,Fuse0=&H00,Fuse1=&H40,Fuse2=&H02,Fuse4=&H00,Fuse6=&H07,Fuse7=&H00,Fuse8=&H04,UROW0=&H00,UROW1=&H00,UROW2=&H00,UROW3=&H00,UROW4=&H00,UROW5=&H00,UROW6=&H00,UROW7=&H00,UROW8=&H00,UROW9=&H00,UROW10=&H00,UROW11=&H00,UROW12=&H00,UROW13=&H44,UROW14=&H00,UROW15=&H00,UROW16=&H00,UROW17=&H00,UROW18=&H00,UROW19=&H00,UROW20=&H00,UROW21=&H00,UROW22=&H00,UROW23=&H00,UROW24=&H00,UROW25=&H00,UROW26=&H00,UROW27=&H00,UROW28=&H00,UROW29=&H00,UROW30=&H00,UROW31=&H00,UROW32=&H00,UROW33=&H00,UROW34=&H00,UROW35=&H00,UROW36=&H00,UROW37=&H00,UROW38=&H00,UROW39=&H00,UROW40=&H00,UROW41=&H00,UROW42=&H00,UROW43=&H00,UROW44=&H00,UROW45=&H00,UROW46=&H00,UROW47=&H00,UROW48=&H00,UROW49=&H00,UROW50=&H00,UROW51=&H00,UROW52=&H00,UROW53=&H00,UROW54=&H00,UROW55=&H00,UROW56=&H00,UROW57=&H00,UROW58=&H00,UROW59=&H00,UROW60=&H00,UROW61=&H00,UROW62=&H00,UROW63=&H00

The CONFIG FUSES line only contains values that differ from &HFF meaning that one of the bits is set. 

By default FUSES and LOCK are always set to OFF. This means that the programmer will not process the fuses and locks. 

When your project is done and you want to program more processors you can change the FUSES=OFF into FUSES=ON. Then recompile so this info is written into the project PRG file. And now when you auto program the processor, the fuses are also programmed. 

The same applies for the locks : when you want to lock the processor, you change LOCK=OFF into LOCK=ON, then recompile. When you program the processor, the lock byte(s) is also programmed. 

When the lock byte is set, only an UNLOCK allows to reprogram the processor. UNLOCK will erase the processor. So all content (EEPROM too) will be erased. 

Some processors have a large UserRow memory. For this reason you can also program the UserRow using the UserRow TAB. 

USERROW

![mcs_edbg_userrow](mcs_edbg_userrow.png)

It works just the same as the EEPROM TAB. 

When you create a binary .USR file the content is loaded automatically into the buffer.

Use the [$USER](user.md) directive in combination with DATA lines to create the binary .USR file.

Voltages

![mcs_edbg_voltages](mcs_edbg_voltages.png)

The voltages TAB can read the USB voltage and the target voltage. When the programmer supports it you can also set the target voltages. 

Use the 1V8, 3V3 and 5V preset buttons to set the voltage. Click the SET button to actual set the voltage. 

![curiosity_programmer](curiosity_programmer.png)

PIN | DESCRIPTION  
---|---  
NC | Not connected  
ID | ID line for extension  
CDC RX | USB CDC RX line  
CDC TX | USB CDC TX line  
DBG1 | Debug clock line  
DBG2 | Debug GPIO0/SW0  
VBUS | VBUS voltage for external use  
VOFF | Voltage Off input. Disables the target regulator and target voltage when pulled low. Make it low to activate.  
DBG3 | Reset Line  
DBG0 | Debug data line. Connect to UPDI of the target processor  
GND | Common ground.  
VTG | Target Voltage  
  
For programming you connect GND to GND of the target. Connect VTG to the target processor when your target circuit does not need much power. Do not connect when your target has it's own power.

And connect DBG0 to the UPDI pin of the target processor. Optional you can connect DBG3 to the reset pin of the processor. Most processors have a fuse that must be programmer first in order to select reset for the pin. Otherwise it is just a normal pin. 

The image shown is the programmer part of the curiosity board. You need to separate the PCB before you can use it to program other processors. Instruction on how to cut tracks you can find in the documentation of the curiosity board. By default the programmer/debugger is connected to the on board target processor. When you cut tracks or board you need to make wired connections in order to program in again. 

The ISP mode was tested with both Xplained boards : Xplained 168PB and Xplained 328PB.

The ISP mode has a fixed clock frequency for most boards we tried. In AS7 you will also not find a way to change the clock. 

SNAP programmer info

![SNAP-connector](snap-connector.png)

```vb
For all supported mode you need to connect GND(ground) to pin 3 and VTG(vcc) to pin 2. 

For UPDI you also need to connect the DAT to pin 4.

For ISP you need to connect MISO to pin 4, CLOCK to pin 5, reset to pin 6 and MOSI to pin 7.

For PDI you need to connect DAT to pin 4 and RESET to pin 6. While the table shows CLK for pin 6, it is actually connected to the RESET pin of the ISP connector.

```
![avr-stk600-isp](avr-stk600-isp.png)

![notice](notice.jpg)There is no option to select ISP, UPDI or ISP mode. The mode depends on the DAT file value from the [$REGFILE](regfile.md) directive in your code.

See Also

[$PROGRAMMER](programmer.md)

---

## MCS Universal Interface Programmer

The MCS Universal Interface programmer allows you to customize the pins that are used for the ISP interface. The file prog.settings stores the various interfaces.

The content :

;how to use this file to add support for other programmers

;first create a section like [newprog]

; then enter the entries:

; BASE= $hexaddress

; MOSI= address in form of BASE[+offset] , bit [,inverted]

; CLOCK= same as MOSI

; RESET=same as MOSI

; MISO=same as MOSI

; The bit is a numer that must be written to set the bit

; for example 128 to set bit 7

; Optional is ,INVERTED to specify that inverse logic is used

; When 128 is specified for the bit, NOT 128 will be written(127)

[FUTURELEC]

;tested and ok

BASE=$378

MOSI=BASE+2,1,inverted

CLOCK=BASE,1

RESET=BASE,2

MISO=BASE+1,64

[sample]

;tested and ok

BASE=$378

MOSI=BASE,1

CLOCK=BASE,8

RESET=BASE,4

MISO=BASE+1,128,INVERTED

[stk200]

;tested and ok

BASE=$378

MOSI=BASE,32

CLOCK=BASE,16

RESET=BASE,128

MISO=BASE+1,64

Four programmers are supported : Futurelec, Sample and STK200/STK300 and WinAVR/ SP12.

To add your own programmer open the file with notepad and add a new section name. For the example I will use stk200 that is already in the file.

[stk200]

The LPT base address must be specified. For LPT1 this is in most cases $378. $ means hexadecimal.

The pins that are needed are MOSI, CLOCK, RESET and MISO.

Add the pin name MOSI =

After the pin name add the address of the register. For the STK200 the data lines are used so BASE must be specified. After the address of the register, specify the bit number value to set the pin high. Pin 0 will be 1, pin 1 would be 2, pin 2 would be 4 etc. D5 is used for the stk so we specify 32.

When the value is set by writing a logic 0, also specify, INVERTED.

After you have specified all pins, save the file and restart BASCOM.

Select the Universal Programmer Interface and select the entry you created.

After you have selected an entry save your settings and exit BASCOM. At the next startup of BASCOM, the settings will be used.

The following picture shows the LPT connector and the relation of the pins to the LPT registers.

![lptcon](lptcon.gif)

Always add your entry to the bottom of the file and email the settings to support@mcselec.com so it can be added to BASCOM.

---

## MCSBYTE

The numeric<>string conversion routines are optimized when used for byte, integer,word and longs.

When do you use a conversion routine ?

\- When you use STR() , VAL() or HEX().

\- When you print a numeric variable

\- When you use INPUT on numeric variables.

To support all data types the built in routines are efficient in terms of code size.

But when you use only conversion routines on bytes there is a overhead.

The mcsbyte.lib library is an optimized version that only support bytes.

Use it by including : $LIB "mcsbyte.lbx" in your code.

Note that LBX is a compiled LIB file. In order to change the routines you need the commercial edition with the source code(lib files). After a change you should compile the library with the [library manager](tools_lib_manager.md).

See also

[mcsbyteint.lib](mcsbyteint.md)

---

## MCSBYTEINT

The numeric<>string conversion routines are optimized when used for byte, integer,word and longs.

When do you use a conversion routine ?

-When you use STR() , VAL() or HEX().

-When you print a numeric variable

-When you use INPUT on numeric variables.

To support all data types the built in routines are efficient in terms of code size.

But when you use only conversion routines on bytes there is a overhead.

The mcsbyteint.lib library is an optimized version that only support bytes, integers and words.

Use it by including : $LIB "mcsbyteint.lbx" in your code.

Note that LBX is a compiled LIB file. In order to change the routines you need the commercial edition with the source code(lib files). After a change you should compile the library with the library manager.

See also

[mcsbyte.lib](mcsbyte.md)

---

## MEMCOPY

Action

Copies a block of memory

Syntax

bts = MEMCOPY(source, target , bytes [, option])

Remarks

bts | The total number of bytes copied. This must be an integer or word variable.  
---|---  
source | The first address of the source variable that will be copied.  
target | The first address of the target variable that will be copied to.  
bytes | The number of bytes to copy from "source" to "target" The range is from 1-65535. ![notice](notice.jpg)There is not check for 0 bytes to copy. When using a variable make sure that it is not zero, since the effect will be that &HFFFF bytes will be copied.  
option | An optional numeric constant with one of the following values : 1 - only the source address will be increased after each copied byte 2 - only the target address will be increased after each copied byte 3 - both the source and target address will be increased after each copied byte  
  
By default, option 3 is used as this will copy a block of memory from one memory location to another location. But it also possible to fill an entire array of memory block with the value of 1 memory location. For example to clear a whole block or preset it with a value.

And with option 2, you can for example get a number of samples from a register like PINB and store it into an array.

MEMCOPY checks the size of the target variable and it will not overwrite data if the number of bytes is greater than the size of the target data. For example : 

Dim tar(4) as byte, sar(8) as byte

MEMCOPY sar(1), tar(1),8 

Even while 8 bytes are specified, the data size for tar() is 4 and thus only 4 bytes will be copied.

When you use MEMCOPY Inside a sub routine/function with passed parameters, there is no way to check the target size. 

In this case, there is no check on the target size and the number of specified bytes will be moved, no matter the target data size.

This is potential unsafe when you specify too many bytes since other memory could be overwritten.

MEMCOPY could be used to clear an array quickly.

See also

[MEMFILL](memfill.md)

ASM

NONE

Example

```vb
'-----------------------------------------------------------------------

'name : MEMCOPY.BAS

'copyright : (c) 1995-2025, MCS Electronics

'purpose : show memory copy function

'suited for demo : yes

'commercial addon needed : no

'use in simulator : possible

'----------------------------------------------------------------------

$regfile = "m88def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 16 ' default use 10 for the SW stack

$framesize = 40

Dim Ars(10) As Byte 'source bytes

Dim Art(10) As Byte 'target bytes

Dim J As Byte 'index

For J = 1 To 10 'fill array

```
Ars(j) = J

Next

J = Memcopy(ars(1) , Art(1) , 4) 'copy 4 bytes

```vb
Print J ; " bytes copied"

For J = 1 To 10

Print Art(j)

Next

```
J = Memcopy(ars(1) , Art(1) , 10 , 2) 'assign them all with element 1

```vb
Print J ; " bytes copied"

For J = 1 To 10

Print Art(j)

Next

Dim W As Word , L As Long

```
W = 65511

J = Memcopy(w , L , 2) 'copy 2 bytes from word to long

End

---

## MEMFILL

Action

Fills a block of memory with a given value

Syntax

MEMFILL source, bytes, value

Remarks

source | The first address of the source variable that will be filled. This can be a normal numeric variable or an array like ar(1)  
---|---  
bytes | The number of bytes to fill.  The range is from 1-65535. ![notice](notice.jpg)There is not check for 0 bytes to copy. When using a variable make sure that it is not zero, since the effect will be that &HFFFF bytes will be filled.  
value | This is a byte or numeric constant with the ASCII value to use for the memory filling. To clear an array, use 0.  
  
MEMFILL intended use is to clear an array or to fill an array quickly.

To clear an array use a value of 0. 

See also

[MEMCOPY](memcopy.md)

ASM

CALLS _MEM_FILL in mcs.lib

Example

```vb
$regfile = "m1280def.dat"  
$crystal = 8000000  
$hwstack = 64  
$swstack = 64  
$framesize = 64  
$baud = 19200  
  
Config Base = 0 'array start at 0  
  
Dim Ar(100) As Byte , X As Byte  
  
Print "MEMFILL test"  
  
'fill array/memory with ASCII A  
```
Memfill Ar(1) , 10 , 65 'skip the first entry so it remains 0  
  
```vb
Do  
Print X ; "->" ; Ar(x)  
```
Incr X  
```vb
Loop Until X = 10  
  
End  


```

---

## Memory usage

SRAM

Every variable uses memory. Variables are stored in memory. This memory is also called SRAM (static ram). 

The available memory depends on the chip. When you double click on the chip pinout, you can view the parameters of the used chip.

A special kind of memory are the registers in the AVR. Registers 0-31 have addresses 0-31.

Almost all registers are used by the compiler or might be used in the future.

Which registers are used depends on the program statements you use.

This brings us back to the SRAM.

No SRAM is used by the compiler other than the space needed for the software stack ([$SWSTACK](_swstack.md)) and frame 

([$FRAMESIZE](_framesize.md))

Some statements might use some SRAM. When this is the case it is mentioned in the help topic of that statement.

For example, [CONFIG CLOCK](config_clock.md) in user mode requires variables to hold the time. Variables like _sec , _min , _hour, _day , _month , _year.

Each 8 bits used occupy one byte. When you dimension 1 bit, you will also use 1 byte. 

Each byte variable occupies one byte.

Each integer/word variable occupies two bytes.

Each Long, Dword or Single variable occupies four bytes.

Each double variable occupies 8 bytes.

Each string variable occupies at least 2 bytes.

A string with a length of 10 occupies 11 bytes.

![notice](notice.jpg)Strings need an additional byte (Null termination) to indicate the end of the string. That's why a string of 10 bytes occupies 11 bytes.

![notice](notice.jpg)With dimension of a bit you will occupy one byte.

Use bits or byte variables wherever you can to save memory. (not allowed for negative values)

See also [DIM](dim.md)

The software stack is used to store the addresses of LOCAL variables and for variables that are passed to SUB routines.

Each LOCAL variable and passed variable to a SUB/FUNCTION, requires two bytes to store the address (because it is a 16-Bit address = 2 bytes).

So when you have a SUB routine in your program that passes 10 variables, you need 10 * 2 = 20 bytes. 

When you use 2 LOCAL variables in the SUB program that receives the 10 variables, you need additional 2 * 2 = 4 bytes.

See also [DECLARE SUB](declare_sub.md), [DECLARE FUNCTION](declare_function.md)

The software stack ([$SWSTACK](_swstack.md)) size can be calculated by taking the maximum number of parameters in a SUB routine, adding the number of LOCAL variables and multiplying the result by 2. To be safe, add 4 more bytes for internally used LOCAL variables.

LOCAL variables are stored in a place that is named the Frame ([$FRAMESIZE](_framesize.md))

When you have a LOCAL STRING with a size of 40 bytes, and a LOCAL LONG, you need 41 + 4 bytes = 45 bytes of frame space.

When you use conversion routines such as [STR](str.md), [VAL](val.md), [HEX](hex.md), [INPUT](input.md) etc. that convert from numeric to string and vice versa, you also need a frame. Note that the use of the [INPUT](input.md) statement with a numeric variable, or the use of the [PRINT](print.md) or [LCD](lcd_1.md) statement with a numeric variable, will also force you to reserve 24 bytes of frame space. This because these routines use the internal numeric<>string conversion routines. 

![notice](notice.jpg)In fact, the compiler creates a buffer of 24 bytes that serves as scratchpad for temporary variables, and conversion buffer space. So the frame space should be 24 at minimum ([$FRAMESIZE](_framesize.md) = 24). This 24 Byte start at the beginning of the Frame which act as the conversion buffer within the frame

For an ATXMEGA or ATMEGA you have usually enough SRAM so you can start with higher values of Stack and Frame.

With an ATTINY13 and 64Byte SRAM it is a challenge but also start with all stack defined and lower the Stack Values when your application program grows.

•| Avoid to use SUB or FUNCTIONS (If you want to save SRAM space)  
---|---  
  
•| If you use Functions like PRINT, LCD, INPUT and the FP num <> FORMAT(), String conversion you need to define the 24 Byte conversion buffer (at least 24Byte for Software Stack + FRAME together).  
---|---  
  
![memusage1](memusage1.png)

In this case just 9 Bytes are left for global variables !

See also: [$HWSTACK](_hwstack.md), [$SWSTACK](_swstack.md), [$FRAMESIZE](_framesize.md)

XRAM

Some processors have an external memory interface. For example the ATMEGA128 has such an interface.

The additional memory is named XRAM memory (extended or external memory).

When you add 32 KB RAM, the first address will be 0.

But because the XRAM can only start after the internal SRAM, the lower memory locations of the XRAM will not be available for use. The processor will automatically use the SRAM if an address is accessed that is in range of the SRAM memory.

Thus adding 32KB of XRAM, will result in a total of 32 KB RAM.

With ATXMEGA you can add XRAM with the EBI (External Bus Interface). There is no problem to add for example 

16 MByte of external SDRAM.

See [CONFIG XRAM](configxram.md)

ERAM

Most AVR chips have internal EEPROM on board.

This EEPROM can be used to store and retrieve data.

In BASCOM, this data space is called ERAM.

An important difference is that an ERAM variable can only be written to a maximum of 100.000 times. So only assign an ERAM variable when it is required, and never use it in a loop or the ERAM will become unusable.

Always use the Brown out detection of the processor to prevent EEPROM corruption.

See also [DIM](dim.md)

For ATXMEGA see also [CONFIG EEPROM](config_eeprom.md)

Constant code usage

Constants are stored in a constant table.

Each used constant in your program will end up in the constant table.

```vb
For example:

Print "ABCD"  
Print "ABCD"

```
This example will only store one constant (ABCD).

```vb
Print "ABCD"  
Print "ABC"

```
In this example, two constants will be stored because the strings differ.

Stack

See also: [$HWSTACK](_hwstack.md), [$SWSTACK](_swstack.md), [$FRAMESIZE](_framesize.md)

The Stack is a part of SRAM (Static RAM). In SRAM the compiler stores user dimensioned variables, as well as internal variables, but SRAM holds also Hardware Stack, Software Stack and Frame. The Variables always start at the lowest SRAM Address. After Reset all SRAM Bytes are 0 (and strings are "") so the SRAM memory is cleared after reset. With the $noramclear option you can turn this behavior off which means the SRAM is not cleared after reset.

The available SRAM depends on the Chip.

With ATTINY13 for example you have 64Byte of SRAM and you will find this information beside the user manual in the *.DAT file. You can also double click the chip in Chip Pinout to view the chip parameters.

The following you find in the attiny13.dat file:  SRAM = 64 ; SRAM size

Global Variables start with the lowest SRAM Address and the Hardware Stack start with the highest SRAM Address.

![memusage2](memusage2.png)

Example for using with Bascom-AVR Simulator:

```vb
$regfile = "attiny13.dat"  
$crystal = 4000000  
$hwstack = 30  
$swstack = 0  
$framesize = 24  
  
Dim B As Byte  
```
B = 5  
  
  
Pcmsk = &B00000001 'PIN Change Int  
```vb
ON PCINT0 pin_change_isr  
Set Gimsk.5  
Enable Interrupts  
  
Do  
```
!NOP  
```vb
Loop  
  
End 'end program  
  
```
pin_change_isr:  
B = 7  
Return

With an ATTINY13 the SRAM is just 64Byte and it is easy to see which SRAM Bytes will be overwritten with Bascom AVR Simulator Memory Window.

Click on M to display the memory window.

![memusage3](memusage3.png)

![memusage4](memusage4.png)

Picture: SRAM of ATTINY13 when executing the above ATTINY13 example in Bascom Simulator

You can see the Hardware Stack (32 Byte) , Frame (24 Byte) and the Variable B.

For this example you do not really need a Frame so it could be also $framesize = 0 for this example.

With ATXMEGA128A1 there is 8K Byte of SRAM available and you can find in the DAT file  (SRAM = 8192 ; SRAM size )

![notice](notice.jpg)The Values of Stack should be ALWAYS defined at the beginning of any BASCOM-AVR Program in the main project file. The best place is right after the [$REGFILE](regfile.md) statement.

Example:

```vb
$hwstack = 32 ' default use 32 for the hardware stack  
$swstack = 32 ' default use 32 for the SW stack  
$framesize = 40 ' default use 40 for the frame space  


```
The following example show what can happen when you define NO Stacks or Frame or when you define not enough Stack or Frame. 

In this example we use: $hwstack = 64, $swstack = 0, $framesize = 8

As we know now Software Stack and FRAME together must be as absolute minimum 24 Byte (for the conversion buffer) so we force the overwriting of Hardware Stack which causes malfunction.

(Reminder: Donât start with the lowest values for Stack and Frame)

![](embim1.png)

Picture : SRAM for example with$hwstack = 64, $swstack = 0, $framesize = 8 

You can now imagine what could happen:

•| Because of overwritten return address in Hardware Stack the micro is jumping to somewhere else and malfunction if forced.  
---|---  
  
•| Functions like PRINT overwrite addresses of LOCAL Variables and here also will the micro jump to somewhere else and malfunction is forced.  
---|---  
  
![memusage6](memusage6.png)

Picture: Simulator Memory Windows for example with $hwstack = 64, $swstack = 0, $framesize = 8 

Now an example for passing an Array to a SUB:

![memusage11](memusage11.png)

With this example we see the complete SRAM.

The SRAM start with the dimed variables. In this case it start with the variable I followed by the Array Ar of 16 Byte and in the end the variable B. 

Because it is easier with the memory window of Bascom Simulator I choose multiple of 16 for Stack and Framesize.

We have here 2 Addresses stored in Software Stack. One address for the Array and one address for the variable B.

So passing an Array to a SUB just need 2 Bytes for the address in Stack which is the same size as for one Byte variable (here variable B).

![memusage7](memusage7.png)

Picture: Simulator Memory Window for example passing an Array to a SUB

With this example you also see that especially with ATTINY and smaller ATMEGA it is not that complicated to see if other SRAM bytes will be overwritten by something and causes malfunction.

You have with the Simulator window the âbig pictureâ of SRAM and STACK together.

As already written it is easier to use multiple of 16 for Hardware Stack, Software Stack and FRAME as a starting point because one line in Simulator Memory window is 16 Bytes.

How to see which Variables are stored on which SRAM Byte ?

You can find out the stored variable with the Bascom-AVR Simulator Memory Window by clicking on that byte.

Click on SRAM Bytes show the OCCUPIED BY in the footer of that window.

Only the first Byte of an Array will show the Name of the Array !

![memusage8](memusage8.png)

Picture: How to see which Variables are stored on which SRAM Byte

You can also find this information in the Compiler output report:

In this case under VARIABLES

![memusage9](memusage9.png)

Picture: How to see which Variables are stored on which SRAM Address

The following small example is good for examining the Bascom-AVR internal variables like _sec, _min or _hour in Bascom-AVR Simulator Memory Window.

```vb
Config Clock = User for example create the internal variables for seconds (_sec), minutes (_min) ,hour (_hour) etcâ¦. You can see this variables by clicking on the SRAM Byte and watch the footer of that Bascom-AVR Simulator Memory Window footer.

$regfile = "m88def.dat"  
$hwstack = 48  
$swstack = 80  
$framesize = 80  
  
Config Clock = User  
  
End 'end program

```
![memusage10](memusage10.png)

Picture: Internal Variables in the Bascom-AVR Simulator Memory Window

See also: [$HWSTACK](_hwstack.md), [$SWSTACK](_swstack.md), [$FRAMESIZE](_framesize.md)

---

## MID

Action

The MID function returns part of a string (a sub string).

The MID statement replaces part of a string variable with another string.

Syntax

var = MID(var1 ,st [, l] )

MID(var ,st [, l] ) = var1

Remarks

var | The string that is assigned.  
---|---  
Var1 | The source string.  
st | The starting position.  
l | The number of characters to get/set.  
  
Both MID statement and MID function support [$BIGSTRINGS](bigstrings.md).

In version 2085 the code has been rewritten to be more efficient and safe. The safety comes with a small penalty.

When you provide an offset the old code would simply add this offset to the string address. This will work out fine except when the string is smaller than specified.

See also

[LEFT](left.md) , [RIGHT](right.md)

Example

Dim S As String * 15 , Z As String * 15

S ="ABCDEFG"

Z = Left(s , 5)

Print Z 'ABCDE

Z = Right(s , 3) : Print Z

Z = Mid(s , 2 , 3) : Print Z

End

---

## MIN

Action

Returns the minimum value of a byte or word array.

Syntax

var1 = MIN(var2)

MIN(ar(1), m , idx)

Remarks

var1 | Variable that will be assigned with the minimum value.  
---|---  
var2 | The first address of the array.  
|   
| The MIN statement can return the index too  
Ar(1) | Starting element to get the minimum value and index of  
M | Returns the minimum value of the array  
Idx | Return the index of the array that contains the minimum value. Returns 0 if there is no minimum value.  
  
The MIN() ans MAX() functions work on BYTE and WORD arrays only.

See also

[MAX](max.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : minmax.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : show the MIN and MAX functions

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

' These functions only works on BYTE and WORD arrays at the moment !!!!!

'Dim some variables

Dim Wb As Byte , B As Byte

Dim W(10) As Word ' or use a BYTE array

'fill the word array with values from 1 to 10

For B = 1 To 10

```
W(b) = B

```vb
Next

Print "Max number " ; Max(w(1))

Print "Min number " ; Min(w(1))

Dim Idx As Word , M1 As Word

```
Min(w(1) , M1 , Idx)

Print "Min number " ; M1 ; " index " ; Idx

Max(w(1) , M1 , Idx)

```vb
Print "Max number " ; M1 ; " index " ; Idx

End

```

---

## Mixing ASM and BASIC

BASCOM allows you to mix BASIC with assembly.

This can be very useful in some situations when you need full control of the generated code.

In order to use ASM you must start the line with the character !

Optional you can create a block of ASM using $ASM end $END ASM

Use CTRL + SPACE to get a list of ASM mnemonics.

```vb
For example :

Dim a As Byte At &H60 ' A is stored at location &H60

```
!Ldi R27 , $00 ' Load R27 with MSB of address

!Ldi R26 , $60 ' Load R26 with LSB of address

!Ld R1, X ' load memory location $60 into R1

!SWAP R1 ' swap nibbles

As you can see the SWAP mnemonic is preceded by a ! sign. Without it, it would be the BASIC SWAP statement.

Another option is to use the assembler block directives:

$ASM

Ldi R27 , $00 ' Load R27 with MSB of address

Ldi R26 , $60 ' Load R26 with LSB of address

Ld R1, X ' load memory location $60 into R1

SWAP R1 ' swap nibbles

$END ASM

A special assembler helper function is provided to load the address into the register X or Z. Y can may not be used because it is used as the soft stack pointer.

Dim A As Byte ' reserve space

LOADADR a, X ' load address of variable named A into register pair X

This has the same effect as :

Ldi R26, $60 ' for example !

Ldi R27, $00 ' for example !

Some registers are used by BASCOM

R4 and R5 are used to point to the stack frame or the temp data storage

R6 is used to store some bit variables:

R6 bit 0 = flag for integer/word conversion

R6 bit 1 = temp bit space used for swapping bits

R6 bit 2 = error bit (ERR variable)

R6 bit 3 = show/noshow flag when using INPUT statement

R8 and R9 are used as a data pointer for the READ statement.

All other registers are used depending on the used statements.

To Load the address of a variable you must enclose them in brackets.

Dim B As Bit

Lds R16, {B} 'will replace {B} with the address of variable B

To refer to the bit number you must precede the variable name by BIT.

Sbrs R16 , BIT.B 'notice the point!

Since this was the first dimensioned bit the bit number is 7. Bits are stored in bytes and the first dimensioned bit goes in the MS (most significant) bit.

To load an address of a label you must use :

LDI ZL, Low(lbl * 1)

LDI ZH, High(lbl * 1)

Where ZL = R30 and may be R24, R26, R28 or R30

And ZH = R31 and may be R25, R27, R29 or R31.

These are so called register pairs that form a pointer.

When you want to use the LPM instruction to retrieve data you must multiply the address with 2 since the AVR object code consist of words.

LDI ZL, Low(lbl * 2)

LDI ZH, High(lbl * 2)

LPM ; get data into R0

Lbl:

Atmel mnemonics must be used to program in assembly.

You can download the pdf from www.atmel.com that shows how the different mnemonics are used.

Some points of attention :

* All instructions that use a constant as a parameter only work on the upper 16 registers (r16-r31)

So LDI R15,12 WILL NOT WORK

* The instruction SBR register, K

will work with K from 0-255. So you can set multiple bits!

The instruction SBI port, K will work with K from 0-7 and will set only ONE bit in a IO-port register.

The same applies to the CBR and CBI instructions.

You can use constants too:

.equ myval = (10+2)/4

ldi r24,myval+2 '5

ldi r24,asc("A")+1 ; load with 66

Or in BASIC with CONST :

CONST Myval = (10+2) / 4

Ldi r24,myval

How to make your own libraries and call them from BASIC?

The files for this sample can be found as libdemo.bas in the SAMPLES dir and as mylib.lib in the LIB dir.

First determine the used parameters and their type.

Also consider if they are passed by reference or by value

For example the sub test has two parameters:

x which is passed by value (copy of the variable)

y which is passed by reference(address of the variable)

In both cases the address of the variable is put on the soft stack which is indexed by the Y pointer.

The first parameter (or a copy) is put on the soft stack first

To refer to the address you must use:

ldd r26 , y + 0

ldd r27 , y + 1

This loads the address into pointer X

The second parameter will also be put on the soft stack so :

The reference for the x variable will be changed :

To refer to the address of x you must use:

ldd r26 , y + 2

ldd r27 , y + 3

To refer to the last parameter y you must use

ldd r26 , y + 0

ldd r27 , y + 1

Write the sub routine as you are used too but include the name within brackets []

[test]

test:

ldd r26,y+2 ; load address of x

ldd r27,y+3

ld r24,x ; get value into r24

inc r24 ; value + 1

st x,r24 ; put back

ldd r26,y+0 ; address of y

ldd r27,y+1

st x,r24 ; store

ret ; ready

[end]

To write a function goes the same way.

A function returns a result so a function has one additional parameter.

It is generated automatic and it has the name of the function.

This way you can assign the result to the function name

```vb
For example:

Declare Function Test(byval x as byte , y as byte) as byte

```
A virtual variable will be created with the name of the function in this case test.

It will be pushed on the soft stack with the Y-pointer.

To reference to the result or name of the function (test) the address will be:

y + 0 and y + 1

The first variable x will bring that to y + 2 and y + 3

And the third variable will cause that 3 parameters are saved on the soft stack

To reference to test you must use :

ldd r26 , y + 4

ldd r27 , y + 5

To reference variable x

ldd r26 , y + 2

ldd r27 , y + 3

And to reference variable y

ldd r26 , y + 0

ldd r27 , y + 1

When you use exit sub or exit function you also need to provide an additional label. It starts with sub_ and must be completed with the function / sub routine name. In our example:

sub_test:

LOCALS

When you use local variables thing become more complicated.

Each local variable address will be put on the soft stack too

When you use 1 local variable its address will become

ldd r26, y+0

ldd r27 , y + 1

All other parameters must be increased with 2 so the reference to y variable changes from

ldd r26 , y + 0 to ldd r26 , y + 2

ldd r27 , y + 1 to ldd r27 , y + 3

And of course also for the other variables.

When you have more local variables just add 2 for each.

Finally you save the file as a .lib file

Use the library manager to compile it into the lbx format.

The declare sub / function must be in the program where you use the sub / function.

The following is a copy of the libdemo.bas file :

```vb
' define the used library

$lib "mylib.lib"

'also define the used routines

$external Test

'this is needed so the parameters will be placed correct on the stack

Declare Sub Test(byval X As Byte , Y As Byte)

'reserve some space

Dim Z As Byte

'call our own sub routine

```
Call Test(1 , Z)

```vb
'z will be 2 in the used example

End

```
When you use ports in your library you must use .equ to specify the address:

.equ EEDR=$1d

In R24, EEDR

This way the library manager knows the address of the port during compile time.

As an alternative precede the mnemonic with a * so the code will not be compiled into the lib. The address of the register will be resolved at run time in that case.

This chapter is not intended to teach you ASM programming. But when you find a topic is missing to interface BASCOM with ASM send me an email.

Translation

In version 1.11.7.5 of the compiler some mnemonics are translated when there is a need for.

For example, SBIC will work only on normal PORT registers. This because the address may not be greater then 5 bits as 3 bits are used for the pin number(0-7).

SBIC worked well in the old AVR chips(AT90Sxxxx) but in the Mega128 where PORTG is on a high address, it will not work.

You always needs a normal register when you want to manipulate the bits of an external register.

For example :

LDS r23, PORTG ; get value of PORTG register

SBR r23,128 ; set bit 7

STS PORTG, R23

The mnemonics that are translated by the compiler are : IN, OUT, SBIC, SBIS, SBI and CBI.

The compiler will use register R23 for this. So make sure it is not used.

Special instructions

ADR Label ; will create a word with the address of the label name

ADR2 Label ; will create a word with the address of the label name, multiplied by 2 to get the byte address 

; since word addresses are used. This is convenient when loading the Z-pointer to use (E)LPM.

.align ; This directive will align the code to a 256 byte page so that the address LSB becomes 0. 

; When storing data at an address where the LSB is zero, you can test for an overflow of the MSB only.

---

## MKDIR

Action

This statement creates a folder or directory in the current directory.

Syntax

MKDIR directory

Remarks

MaKeDIRectory creates a folder or directory in the current directory.

The directory may not have a device name like COM1, LPT1, etc.

The directory may also not have a name like ".." or "\" since these names are reserved.

You can not create a directory using a path.

MKDIR "test" ' ok

MKDIR "test\abc" ' NOT OK

MKDIR ".." ' NOT OK

MKDIR "\" ' NOT OK

MKDIR "test" : CHDIR "test" : MKDIR "abc" ' this would create test\abc

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILELEN](filelen.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [WRITE](write.md) , [INPUT](input.md) , [DIR](dir.md), [RMDIR](rmdir.md) , [CHDIR](chdir.md) , [NAME](name.md)

Example

MKDIR "test"

---

## MMCSD_HC.LIB

The MMCSD_HC.LIB is an MMC SD-HC card driver library.

See the AVR-DOS topic for an example.

There is an optional constant you can set in your code :

CONST _CS_EXTENDED_PORT=1

You need to set this constant when using a normal AVR chip with the CS pin connected to an extended port. We recommend to use a normal port which allows the CBI/SBI instructions but some times it is required to use an extended port like PORTF on an MEGA2560. Since the extended port needs a register to read-alter-write a bit, the register R23 need to be saved in the lib. When you define the constant and give it a value of 1, the register is preserved.

You can always set this directive, it will only create unneeded code when using normal ports. 

In version 2086 the LIB has been modified and this constant is no longer required or used.

Using MMC/SD card on a SPI bus with multiple devices

The MMC specification requires that clock pulses are sent to the MMC card with the CS line disabled !!!

It means that when another device is active, the clock pulses can confuse or even corrupt the card.

The solution is to use either a bus driver with tri-state , or to use a dedicated pin for the clock lines.

With XMega there are multiple SPI buses possible. 

With normal AVR you can use HW SPI for the MMC, and use SHIFTIN/SHIFTOUT for the other SPI devices.

---

## MOD

Action

Calculates the remainder of a division.

Syntax

var1 = var2 MOD var3

Remarks

var1 | Variable that will be assigned with the modules of var2 and var3.  
---|---  
var2 | A numeric variable to take the modules from  
var3  | The modulus  
  
The MOD operation is similar to the division operation(/). But while a division returns the number of times a number can be divided, the MOD returns the remainder.

For example : 21 MOD 3 will result in 0 since 7x3=21. There will be no remainder.

But 22 MOD 3 will result in 1 since 22-(7x3)=1

In BASCOM, the variable you assign determines which kind of math will be used. When you have 2 word variables you want to get the modulus from, you have to assign a word variable too.

When you assign a byte, byte math will be used.

Floating Point

When using singles or doubles, the MOD uses this equivalent code :

Dim A as single, B as single, c as single, d as single

a = 13 : b = 2.7 'sample

c = a MOD b

d = a - FIX(a / b) * b

See also

[Language Fundamentals](language_fundamentals.md)

Example

```vb
Dim L As Long , L2 As Long  
For L = 1 To 1000  
```
L2 = L Mod 100  
```vb
If L2 = 0 Then ' multiple of 100  
Print L  
End If  
Next  


```

---

## MODBUS Slave/Server

The MODBUS protocol is used a lot in the industry. With the MODBUS add-on, you can create a slave or server. 

This add-on is a MODBUS server-RTU that implements function 03,06 and 16.(decimal) 

We use the term master and slave to indicate that there is at least one master, and that there is at least one slave device that will respond. 

A slave could be a master too. Another term is client/server. The server is the MODBUS device that will respond to the client. It is the same as master/slave and thus slave=server and master=client. 

Like a web server, the server does not initiate the communication. It simply waits for data and when it is addressed, it will respond.

When it is not addressed, it should not respond. When it is addressed, it should process the data and send a response. 

A client sends the following data : server address, function, data, checksum

The server address is a byte , the function code is a byte too. The data depends on the function and the checksum is a 16 bit CRC checksum. 

MODBUS uses the term registers for the data. A register is 16 bit width. You can pass words or integers with a single register. 

In order to send a long, single, double or string, you need to send multiple registers.

There are a lot of functions defined in the MODBUS protocol. The add-on implements the functions that are most suited for an own MODBUS server device.

These functions are :

•| 03 : read (multiple) register(s)  
---|---  
  
•| 06 : write a single register  
---|---  
  
•| 16 : write multiple registers  
---|---  
  
If needed you can add other functions yourself. The implemented functions should be sufficient however.

Constants

There are a few constants that you might need to change. 

Registersize : this constant defines how many registers can be processed. For example if a client asks to return 10 registers with function 03, you should set this constant to 10.

The reason for the constant is that RAM space is limited. And each register need storage space (2 bytes for each register) thus we do not want to take more bytes then needed.

Mdbg : this can be used for debugging. The add-on uses a Mega162 since it has 2 UARTS. One UART can be used for debugging. You need to set mdbg to a non-zero value to enable debugging to the serial port.

RS232-RS485

The protocol can be used with RS-232 and RS-485 and TCP/IP, etc. The add-on can be used with RS-232 and RS-485.

RS-485 half duplex needs a data direction pin. It is defined in the source like this :

Rs485dir Alias Portb.1

Config Rs485dir = Output

Rs485dir = 0

'Config Print1 = Portb.1 , Mode = Set

You can remark or remove the mark depending on the mode you need.

For testing, RS-232 is most simple.

TIMER

A timer is used to detect the start of a frame. With RTU (binary data) a silence of 3.5 characters is needed between frames. A frame is a complete MODBUS message.

A timer is used to detect such a silence. The statement : GENRELOAD , is used to generate the proper timer divisor and timer reload values. GENRELOAD will only work on TIMER0 and TIMER1. You pass the names of the constants which are free to chose, and in the sample are named _RL and _TS, and these constant values will be calculated and assigned to constants by the compiler. 

The TM_FRAME constant is the time of 4 characters. When the timer reaches this value it will overflow and execute the ISR_TMR0 interrupt. The interrupt routine will set the start state since now the server can expect an address.

In the TM_FRAME calculation the baud rate value is used. In the add on this is 9600. When you use a different value, you need to change the constant here as well.

Server Address

The server address need to be set. The MBSLAVE variable need to be set by you. Optional, you could change the variable into a constant. 

But when you use a DIP switch for example to set the address, it is better to use a variable.

Event mode

The MODBUS handeling is coded into a state machine and executed as a task. You can call the Modbustask() in your code yourself in the main program loop, or you can have it called in the interrupt of the buffered serial input routine. 

The sample uses the last option :

Config Serialin1 = Buffered , Size = 50 , Bytematch = All

Notice that BYTEMATCH = ALL is used so the Serial1bytereceived routine is called for every received byte. If the state is right, the modbustask code is executed and otherwise, the data is read to remove it from the buffer. Since there can be multiple slaves, the data will keep coming and we may only handle the data when we are addressed.

Functions

Each function that is requested will call a sub routine. 

Function 03 (read registers) : Sub Modbus03(addr3 As Word , Idx3 As Byte , Wval3 As Word) 

addr3 contains the address that was passed by the client. 

Idx3 contains an index in case multiple registers are read. It is 1 for the first register, 2 for the second, etc.

With these 2 values you can fill the wval3 value. 

In the sample, a select case is used to send different values. 

You should NOT change the addr3 and idx3 values ! There variables are passed by reference and changes will corrupt the data.

Notice that the function is called for each register. When the client want to read 2 word registers, the sub routine is called twice.

Function 06(write register) Sub Modbus06(addr3 As Word , Wval3 As Word) 

Addr3 contains the address that was passed by the client.

wval3 contains a word value passed by the client.

You can use the address to change some variable in your code.

Function 16 (write multiple registers) Sub Modbus16w(addr3 As Word , Idx As Byte , Bw As Word) 

Addr3 contains the address send by the client.

Idx contain the index to a word register.

Bw contains the value that was send.

Notice that the sub routine is called for each register. You can use the address and index to alter the proper variable in your code.

For functions that are not implemented, an error response will be sent.

---

## Move to new PC

When you want to move BASCOM to a new PC. You have a number of options.

1 - Run the installer with admin rights from CD-ROM on your new PC. The setup will copy the license file automatically.

2 - Download the latest version of the setup.exe from <https://register.mcselec.com > , extract the setup.exe , and run setup.exe with admin rights

For the register link above, you need access(an account). This account is not the same as for the shop/forum.

You need to create an account if you don't have one. 

This procedure is explained in the help topic '[Updates](updates.md)'

After the installation, copy the license file bscavrL.DLL to the bascom-avr application directory of the new PC.

Or let setup.exe do this for you. When you put the license file in the same directory as setup.exe, setup will copy/install the file for you.

In general it is always better to install the latest version.

Support is only offered on the latest available version.

---

## MyAVR/MK2/AVR910 programmer

This programmer is an ISP programmer from MYAVR which supports the AVR910/911 protocol.

It has an USB interface with serial port interface. You need to select the proper port and a baud rate of 19200 baud.

---

## NAME

Action

This AVR-DOS statement renames a file or directory name.

Syntax

NAME old AS new

Remarks

old | The name of the file or folder that you want to rename. This file must exist in the current folder.  
---|---  
new | The new name of the file. The new file may not already exist. The current folder will be used.  
  
Both old and new must be valid file names and of the string data type. Constants are not allowed.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILELEN](filelen.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [WRITE](write.md) , [INPUT](input.md) , [DIR](dir.md), [MKDIR](mkdir.md), [RMDIR](rmdir.md), [CHDIR](chdir.md)

Example

Old = "file1.txt"

New = "fileNew.txt"

NAME old AS new

---

## NBITS

Action

Set all except the specified bits to 1.

Syntax

Var = NBITS( b1 [,bn])

Remarks

Var | The BYTE/PORT variable that is assigned with the constant.  
---|---  
B1 , bn | A list of bit numbers that NOT must be set to 1.  
  
While it is simple to assign a value to a byte, and there is special Boolean notation &B for assigning bits, the Bits() and NBits() function makes it simple to assign a few bits.

B = &B01111101 : how many zeroâs are there?

This would make it more readable: B = NBits(1, 7)

You can read from the code that bit 1 and bit 7 are NOT set to 1.

It does not save code space as the effect is the same.

The NBITS() function will set all bits to 1 except for the specified bits.

It can only be used on bytes and port registers.

Valid bits are in range from 0 to 7.

See Also

[BITS](bits.md)

Example

```vb
'--------------------------------------------------------------------------------

'name : bits-nbits.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo for Bits() AND Nbits()

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'use in simulator : possible

'--------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim B As Byte

'while you can use &B notation for setting bits, like B = &B1000_0111

'there is also an alternative by specifying the bits to set

```
B = Bits(0 , 1 , 2 , 7) 'set only bit 0,1,2 and 7

```vb
Print B

'and while bits() will set all bits specified to 1, there is also Nbits()

'the N is for NOT. Nbits(1,2) means, set all bits except 1 and 2

```
B = Nbits(7) 'do not set bit 7

```vb
Print B

End

```

---

## New CF-Card Drivers

New CF-Card drivers can be made relatively simple.

Have a look at the supplied drivers.

There are always a few files needed :

•| A config file in the format : CONFIG_XXX.bas  
---|---  
  
•| FlashCardDrive_XXX.LIB  
---|---  
  
•| FlashCardDrive_XXX.lbx is derived from the LIB file  
---|---  
  
XXX stands for the name of your driver.

At the AVR-DOS web you can find more drivers.

See also: [AVR-DOS File System](avr_dos_file_system.md)

---

## Newbie problems

When you are using the AVR like ATTINY, ATMEGA, ATXMEGA without knowledge of the architecture you can experience some problems as a Newbie.

Regarding XMEGA see also [ATXMEGA](atxmega.md)

![notice](notice.jpg) As a newbie always use stack and framesize (until you know what you do) !

```vb
$hwstack = 24  
$swstack = 10  
$framesize = 30

```
![notice](notice.jpg) When you encounter problems always try to increase the values behind the stack's and framesize and test the program again.

If you want to learn more about hwstack, swstack and framesize start with [Memory usage](memory_usage.md)

![notice](notice.jpg) Do not include too much in Interrupt Service Routines (ISR). Keep the ISR as short as possible !

Avoid something like print function in ISR (temporarily for debugging this is OK).

See also [Language Fundamentals](language_fundamentals.md)

FAQ:

Question: What can I use as the first "Hello World" Bascom-AVR program ?

Answer: Following a "Hello World" example:

  
```vb
$regfile = "m16def.dat" ' specify the used AVR  
$crystal = 8000000 ' used crystal frequency  
$hwstack = 32 ' default use 32 for the hardware stack  
$swstack = 10 ' default use 10 for the SW stack  
$framesize = 40 ' default use 40 for the frame space  
  
$baud = 19200 ' use baud rate 19200 baud  
  
Do  
Print "Hello World" ' Print Hello World  
Waitms 1000 ' Wait 1000ms = 1 second  
Loop  
  
End ' end program

```
With ATTINY and ATMEGA you need to check if the fuse bits are set correct for the 8MHz (for this example). Some chips will be shipped by the manufacturer (Atmel) with 1MHz frequency fuse bit settings.

If you want to change the UART Interface (like stopbits) use this here in addition to $baud.

(Dummy is used because the baudrate is already configured with $baud = 19200 )

Config Com1 = Dummy, Synchrone = 0, Parity = None, Stopbits = 1, Databits = 8, Clockpol = 0 

Q: How can I program (flash) the AVR with Bascom ?

A: You can use an external programmer. See [Supported Programmers](supported_programmers.md) (For ATTINY you need to use an external hardware programmer)

You can also use the MCS bootloader [MCS Bootloader](mcsbootloader.md) (ATMEGA or ATXMEGA)

See also Application Note: 143

[http://www.mcselec.com/index.php?option=com_content&task=view&id=159&Itemid=57](<http://www.mcselec.com/index.php?option=com_content&task=view&id=159&Itemid=57>)

Instead of using the BASCOM-AVR build in programmer you can also use our stand alone Bootloader application (for Windows):

[http://www.mcselec.com/index.php?option=com_docman&task=doc_download&gid=153&Itemid=54](<http://www.mcselec.com/index.php?option=com_docman&task=doc_download&gid=153&Itemid=54>)

Q: I'm using an Arduino hardware with Bascom-AVR. How can I program it ?

A: See [ARDUINO](arduino.md)

Q: I can not set a pin high or low ? I can not read the input on a pin ?

A: The AVR has 3 registers for each port. A port normally consists of 8 pins. A port is named with a letter from A-F (ATMEGA) and even more with ATXMEGA. All parts have PORTB. When you want to set a single pin high or low you can use the SET and RESET statements. But before you use them the AVR chip must know in which direction you are going to use the pins.

Therefore there is a register named DDRx for each port. In our sample it is named DDRB. 

When you write a 0 to the bit position of the pin you can use the pin as an input. 

When you write a 1 you can use it as output. 

You can also use CONFIG PORTX.Y = INPUT|OUTPUT

After the direction bit is set you must use either the PORTx register to set a logic level or the PINx register to READ a pin level.

Yes the third register is the PINx register. In our sample, PINB.

```vb
For example we like to use PORTB.7 as an OUTPUT pin:

CONFIG PORTB.7=OUTPUT ' will write a '1' to DDRB.7  
SET PORTB.7 ' will set the MS bit to +5V  
RESET PORTB.7 ' will set MS bit to 0 V

```
When using a PIN in INPUT mode, you can also activate an internal pull up resistor. 

Pull up means that the pin is connected with an internal resistor to VCC.

To enable the pull up resistor, you need to write a '1' to the PORT register.

Example to read PORTB.0 pin :

CONFIG PORTB.0=INPUT ' clears DDRB.0  
PORTB.0=1 ' activate pull up  
Print PINB.0  ' will read LS bit and send it to the RS-232

You may also read from PORTx but it will return the value that was last written to it and not the input of the pin.

To read or write whole bytes use :

PORTB = 0 ' write 0 to register making all pins low  
```vb
PRINT PINB ' print input on pins

Config a Pin as output:

Config Porte.0 = Output

```
which is the same as:

DDRE = &B00000001

or can be written as:

```vb
set DDRE.0

Set Output:

Set porte.0

```
which is the same as:

porte.0 = 1

```vb
Reset Output:

Reset porte.0

```
which is the same as:

porte.0 = 0

```vb
Config a Pin as Input:

Config Pine.0 = Input

```
which is the same as:

DDRE.0 = 0

or can be written as:

DDRE = &B00000000

Read Input:

Variabel = PINE.0

To check one pin for status in an if .... statement:

```vb
If Pine.0 = 1 Then  
' do someting....  
End If

```
Q: I want to write a special character but they are not printed correct ?

A: Well this is not a newbie problem but I put it here so you could find it.

Some ASCII characters above 127 are interpreted wrong depending on country settings. To print the right value use : PRINT "Test{123}?"

The {xxx} will be replaced with the correct ASCII character.

You must use 3 digits otherwise the compiler will think you want to print {12} for example. This should be {012}

Q: My application was working but with a new micro it is slow and print funny ?

A: Most new microâs have an internal oscillator that is enabled by default. As it runs on 1 or 2 or 4 or 8 or 32 MHz, this might be slower or faster then your external or internal crystal. This results in slow operation.

As the baud rate is derived from the clock, it will also result in wrong baud rates.

Solution : change frequency with $crystal so the internal clock will be used.

Or change the fuse bits (or change config with XMEGA) so correct clock source like external xtal will be used.

Q: Some bits on Port C are not working ?

A: Some chips have a JTAG interface. Disable it with the proper fuse bit . Or use DISABLE JTAG in your code.

Q: Can I use an ATTINY or ATMEGA as TWI/I2C Slave ?

A: Yes, there is a commercial add on Bascom library available

Here the link: [I2CSLAVE Library (Download version) ](<http://www.mcselec.com/index.php?page=shop.product_details&flypage=shop.flypage&product_id=34&category_id=6&option=com_phpshop&Itemid=1> "I2CSLAVE Library \(Download version\) ")

See also: [CONFIG TWISLAVE](config_twislave.md)

Q: What is Overlay ?

A: See [DIM](dim.md)

Q: Is there a way to use a buffer with software UART ?

A: No, this is not supported.

Q: I have an ATTINY without UART or I need an additional UART on ATMEGA. Is there a "Software UART" in Bascom-AVR ?

A: See [Using the UART](uart.md) and scroll down to SOFTWARE UART

Q: How can I start with ATXMETGA and Bascom-AVR ?

A: See [ATXMEGA](atxmega.md)

Q: How to declare a subroutine or function ?

A: See [DECLARE SUB](declare_sub.md) or [DECLARE FUNCTION](declare_function.md)

Q: I have a number like 1234.888999 but I just want to have one digit after decimal point (1234.8). How can I do that ?

A: See [CONFIG SINGLE](configsingle.md)

Q: How can I set or reset single bits in byte/integer/long variables ?

A: There are several ways to write or read a single bit:

1\. You can use [NBITS](nbits.md) or [BITS](bits.md) to set or reset one or more bits

2\. You can use it following way:

Example on how to set/reset single bits in a variable.

Dim my_long_var As Long  
My_long_var.0 = 1

You can also use SET or RESET  
  
```vb
Set My_long_var.31

Reset My_long_var.31  


```
You even can use a variable as index 

  
Dim Idx As Byte  
Idx = 3  
```vb
Reset My_long_var.idx

For a long variable Idx can be from 0......31

For an integer Idx can be from 0....15

For a byte Idx can be from 0......7

```
3\. You can use BITWAIT to wait until a bit is set (1) or reset (0).

Example:

Dim A As Bit  
Bitwait A , Set ' wait until bit a is set  
```vb
'the above will never continue because it is not set i software  
'it could be set in an ISR routine  
  
```
Bitwait Pinb.7 , Reset ' wait until bit 7 of Port B is 0.

4\. You can use [TOGGLE](toggle.md) to invert the state of a bit

```vb
Dim my_long_var As Long  
Toggle My_long_var.31  


```
Q: Can I create BIT ARRAYS larger then a LONG variable ?

A: Yes, here is a way to do it:

```vb
$regfile = "m162def.dat" ' specify the used micro  
$crystal = 8000000 ' used crystal frequency  
$baud = 19200 ' use baud rate  
$hwstack = 32 ' default use 32 for the hardware stack  
$swstack = 10 ' default use 10 for the SW stack  
$framesize = 40 ' default use 40 for the frame space  
  
Dim Byte_arr(32) As Byte  
Dim Idx As Byte  
  
```
Byte_arr(1).8 = 1  
Print "Byte_arr(2) = " ; Bin(byte_arr(2))  
  
Byte_arr(1).15 = 1  
Print "Byte_arr(2) = " ; Bin(byte_arr(2))  
  
Byte_arr(1).29 = 1  
Print "Byte_arr(4) = " ; Bin(byte_arr(4))  
  
Idx = 63  
Byte_arr(1).idx = 1  
Print "Byte_arr(8) = " ; Bin(byte_arr(8))  
  
Idx = 255  
Byte_arr(1).idx = 1  
```vb
Print "Byte_arr(32) = " ; Bin(byte_arr(32))  
  
'(  
```
Bascom Simulator Output =  
  
Byte_arr(2) = 00000001  
Byte_arr(2) = 10000001  
Byte_arr(4) = 00100000  
Byte_arr(8) = 10000000  
Byte_arr(32) = 10000000  
  
```vb
')  
  
End

```
Q: Can I pass a BIT variable to SUB routines or user FUNCTION ?

A: You can not pass BIT variables to SUB routines or user FUNCTION

Use a BYTE for that.

Here is one of many workarounds for that:

```vb
$regfile = "m162def.dat" ' specify the used micro  
$crystal = 8000000 ' used crystal frequency  
$baud = 19200 ' use baud rate  
$hwstack = 32 ' default use 32 for the hardware stack  
$swstack = 10 ' default use 10 for the SW stack  
$framesize = 40 ' default use 40 for the frame space  
  
Config Submode = New  
  
Dim C As Byte

  
Sub Test(byref B As Byte)  
```
Local C As Byte  
C = B And &B00000001  
  
```vb
If C = 1 Then   
Print "B = 1"  
Else  
Print "B = 0"  
End If  
End Sub  
  
'Main program  
  
Set C.0  
```
Call Test(c)  
  
Reset C.0  
Call Test(c)  
  
End ' end program

Q: Can I dimension a LOCAL variable in a function or sub routine as BIT ?

A: You can not. BIT variables are not possible because they are GLOBAL to the system.

Q: I still have a problem. What to do ?

A: Here is the link to the Bascom-AVR forum: [http://www.mcselec.com/index2.php?option=com_forum&Itemid=59](<http://www.mcselec.com/index2.php?option=com_forum&Itemid=59>)

![notice](notice.jpg) At first please try to search the forum (often you can find users with the same problem) . The search page is here:

[http://www.mcselec.com/index2.php?option=com_forum&Itemid=59&page=search](<http://www.mcselec.com/index2.php?option=com_forum&Itemid=59&page=search>)

If the forum can not help you, here is the Email address for support: [support@mcselec.com](<mailto:support@mcselec.com>)

PLEASE provide as much as possible information in your post or Email:

\- Include the Bascom-AVR version number and your serial number in the Email to support 

![notice](notice.jpg) Do not post your serial number in the Forum !!! ![notice](notice.jpg)

\- Always test with the latest available version, support is only available for the latest version

\- Include a small sample that will demonstrate the error.

\- Make sure you include all required files for compilation or for showing the problem.

\- Be clear if the problem exist in the simulator or the hardware and what kind of hardware you use

---

## NOP

Action

This statement does noting.

Syntax

NOP

Remarks

The NOP statement will create 1 NOP assembly instruction. A NOP takes 1 machine cycle and can be used to create a small delay.

For example, at a processor clock of 1 MHz, one NOP will take exact 1 uS to execute.

You can use the ASM NOP by using : ! NOP in your code, but since using NOP is popular amongst many programmers, we introduced it as a BASCOM BASIC statement as well.

See also

[BREAK](break.md)

Example

NOP

---

## NOT

Action

This logical operator returns the inversed value.

Syntax

target =  NOT source2

Remarks

The NOT operator inverts the input bit. When the bit is '0' it will return a '1'. And when the bit is '1' it will return a '0'

A | R  
---|---  
0 | 1  
1 | 0  
  
The truth table above shows the possible values. A represent the input. R is the Return or output value.

While you can use NOT on bits, you can also perform the same operation on bytes, integers, etc. In such a case, all bits of the variables will be inverted.

Example :

Dim A as Byte, B as Byte, R as byte

A=&B1100_0001

R=NOT A

R=&B0011_1110

See also

[AND](and.md) , [XOR](xor.md), [OR](or.md)

Example

```vb
'--------------------------------------------------------------------------------  
'name : boolean.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demo: AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
'suited for demo : yes  
'commercial add on needed : no  
'use in simulator : possible  
'--------------------------------------------------------------------------------  
'This very same program example can be used in the Help-files for  
' AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
  
  
$baud = 19200  
$crystal = 8000000  
$regfile = "m88def.dat"  
  
$hwstack = 40  
$swstack = 20  
$framesize = 20  
  
Dim A As Byte , B1 As Byte , C As Byte  
Dim Aa As Bit , I As Integer  
  
```
A = 5 : B1 = 3 ' assign values  
C = A And B1 ' and a with b  
Print "A And B1 = " ; C ' print it: result = 1  
  
  
C = A Or B1  
Print "A Or B1 = " ; C ' print it: result = 7  
  
C = A Xor B1  
Print "A Xor B1 = " ; C ' print it: result = 6  
  
A = 1  
C = Not A  
Print "c = Not A " ; C ' print it: result = 254  
C = C Mod 10  
```vb
Print "C Mod 10 = " ; C ' print it: result = 4  
  
  
If Portb.1 = 1 Then 'test a bit from a PORT (which is not the same as testing the input state)  
Print "Bit set"  
Else  
Print "Bit not set"  
End If 'result = Bit not set  
  
Config Pinb.0 = Input : Portb.0 = 1 'configure as input pin  
Do  
Loop Until Pinb.0 = 0 ' repeat this loop until the logic level becomes 0  
  
```
Aa = 1 'use this or ..  
```vb
Set Aa 'use the set statement  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit set (aa=1)  
  
```
Aa = 0 'now try 0  
```vb
Reset Aa 'or use reset  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit not set(aa=0)  
  
```
C = 8 'assign variable to &B0000_1000  
```vb
Set C 'use the set statement without specifying the bit  
Print C 'print it: result = 9 ; bit0 has been set  
  
```
B1 = 255 'assign variable  
```vb
Reset B1.0 'reset bit 0 of a byte variable  
Print B1 'print it: result = 254 = &B11111110  
  
```
B1 = 8 'assign variable to &B00001000  
```vb
Set B1.7 'set it  
Print B1 'print it: result = 9 = &B00001001  
End

```

---

## ON INTERRUPT

Action

Execute subroutine when the specified interrupt occurs.

Syntax

ON interrupt label [NOSAVE|SAVE|SAVEALL]

Remarks

Interrupt | INT0, INT1, INT2, INT3, INT4,INT5, TIMER0 ,TIMER1, TIMER2, ADC , EEPROM , CAPTURE1, COMPARE1A, COMPARE1B,COMPARE1. Or you can use the AVR name convention: OC2 , OVF2, ICP1, OC1A, OC1B, OVF1, OVF0, SPI, URXC, UDRE, UTXC, ADCC, ERDY and ACI. The available interrupts depend on the processor.   
---|---  
Label | The label to jump to if the interrupt occurs.  When using a label, you need to use a RETURN to resume the main program. The label may also be a sub routine. When using a sub routine, the sub routine needs to end with END SUB like any normal sub routine. This sub routine may not have parameters.  So either a label must be uses like : ISR_INT0: Or you define a sub routine : Declare Sub MyISR_Int0() ON INT0 MyISR_Int0 SAVEALL  
NOSAVE | When you specify NOSAVE, no registers are saved and restored in the interrupt routine. So when you use this option make sure to save and restore all used registers. When you omit NOSAVE all used registers will be saved. These are SREG , R31 to R16 and R11 to R0 with exception of R6,R8 and R9 . R12 â R15 are not saved. When you use floating point math in the ISR(not recommended) you must save and restore R12-R15 yourself in the ISR. My_Isr: Push R12 ' save registers Push R13 Push R14 Push R15 Single = single + 1 ' we use FP Pop R15 ' restore registers Pop R14 Pop R13 Pop R12 RETURN ![notice](notice.jpg)When the AVR has extended IO-space (for example ATMega48, 88 or 168, see datasheet at the end: Registersummary), the compiler uses R23 for a number of operations. So Push and Pop R23 as well when using the NOSAVE-option when using these AVR's with extended IO-space.  
SAVE | This is the default and is the same as when no parameter is provided. The most common used registers, SREG, and RAMPZ are saved and restored. Saved : SREG , R31 to R16 and R11 to R0 with exception of R6,R8 and R9. If RAMPZ exists, it will be saved as well.  
SAVEALL | This will save all registers that SAVE will save, but it will also save R12-R15. You should use this option when using floating point math in the ISR.  
  
When using a label you must return from the interrupt routine with the [RETURN](return.md) statement.

The first RETURN statement that is encountered that is outside a condition will generate a RETI instruction. You may have only one such RETURN statement in your interrupt routine because the compiler restores the registers and generates a RETI instruction when it encounters a RETURN statement in the ISR. All other RETURN statements are converted to a RET instruction.

While the label is supported because the old GW-BASIC supported it, it is best to use a Sub routine which you can end with End Sub.

The possible interrupt names can be looked up in the selected microprocessor register file. 2313def.dat for example shows that for the compare interrupt the name is COMPARE1. (look at the bottom of the file)

Using the editor, type ON (SPACE) and press CTRL+SPACE key to get a pop up list with possible interrupt sources.

What are interrupts good for?

An interrupt will halt your program and will jump to a specific part of your program. You can make a DO .. LOOP and poll the status of a pin for example to execute some code when the input on a pin changes.

But with an interrupt you can perform other tasks and when then pin input changes a special part of your program will be executed. When you use INPUT "Name ", v for example to get a user name via the RS-232 interface it will wait until a RETURN is received(a byte with value 13, not the RETURN statement !).

When you have an interrupt routine and the interrupt occurs it will branch to the interrupt code and will execute the interrupt code. When it is finished it will return to the Input statement, waiting until a RETURN is entered(a byte with the return value 13).

Maybe a better example is writing a clock program. You could update a variable in your program that updates a second counter. But a better way is to use a TIMER interrupt and update a seconds variable in the TIMER interrupt handler.

There are multiple interrupt sources and it depends on the used chip/processor which are available.

To allow the use of interrupts you must set the global interrupt switch with an ENABLE INTERRUPTS statement. This only allows that interrupts can be used. You must also set the individual interrupt switches on!

ENABLE TIMER0 for example allows the TIMER0 interrupt to occur.

With the DISABLE statement you turn off the switches.

When the processor must handle an interrupt it will branch to an address at the start of flash memory. These addresses can be found in the DAT files.

The compiler normally generates a RETI instruction at these addresses so that in the event that an interrupt occurs, it will return immediately.

When you use the ON ... LABEL statement, the compiler will generate code that jumps to the specified label. The SREG and other registers are saved at the LABEL location and when the RETURN is found the compiler restores the registers and generates the RETI so that the program will continue where it was at the time the interrupt occurred.

When an interrupt is serviced no other interrupts can occur because the processor(not the compiler) will disable all interrupts by clearing the master interrupt enable bit. When the interrupt is serviced the interrupt is also cleared so that it can occur again when the conditions are met that sets the interrupt.

It is not possible to give interrupts a priority. The interrupt with the lowest address has the highest interrupt!

Finally some tips :

* when you use a timer interrupt that occurs each 10 uS for example, be sure that the interrupt code can execute in 10 uS. Otherwise you would loose time.

* it is best to set just a simple flag in the interrupt routine and to determine it's status in the main program. This allows you to use the NOSAVE option that saves stack space and program space. You only have to Save and Restore R24 and SREG in that case.

* Since you can not PUSH a hardware register, you need to load it first:

PUSH R24 ; since we are going to use R24 we better save it

IN r24, SREG ; get content of SREG into R24

PUSH R24 ; we can save a register

;here goes your asm code

POP R24 ;get content of SREG

OUT SREG, R24 ; save into SREG

POP R24 ; get r24 back

* When you call user functions or sub routines which passes variables from your interrupt, you need to enable frame protection. Use [$frameprotect](frameprotect.md)=1 to activate this protection.

![notice](notice.jpg)Unlike the ON VALUE statement, the ON INTERRUPT does not accept GOTO or GOSUB. The GOSUB/GOSUB tells the compiler that ON VALUE is used rather than ON INTERRUPT. Since interrupt sources are constants with an address, the compiler is happy to accept ON INT0 GOSUB which will do something entirely different than you expect.

See Also

[On VALUE](on_value.md) , [ENABLE](enable.md), [DISABLE](disable.md)

Partial Example using label

```vb
Enable Interrupts

Enable Int0 'enable the interrupt

On Int0 Label2 Nosave 'jump to label2 on INT0

Do'endless loop

```
nop

```vb
Loop

End

```
Label2:

```vb
Dim A As Byte

If A > 1 Then

Return 'generates a RET because it is inside a condition

End If

Return 'generates a RETI because it is the first RETURN

Return 'generates a RET because it is the second RETURN

```
Partial Example using Sub

```vb
Declare Sub Label2()

Dim A As Byte

Enable Interrupts

Enable Int0 'enable the interrupt

On Int0 Label2 Nosave 'jump to label2 on INT0

Do'endless loop

```
nop

```vb
Loop

End

Sub Label2()

If A > 1 Then

exit sub

Else

gosub test 

End If

exit sub

```
Test:

```vb
print "test"

Return

End Sub 'generates a RETI

```
As you can see, using a Sub is more flexible because you can include local routines using a label/return.

---

## ON VALUE

Action

Branch to one of several specified labels, depending on the value of a variable.

Syntax

ON var GOTO|GOSUB label1 [, label2 ] [,CHECK]

Remarks

Var | The numeric variable to test. This can also be a SFR such as PORTB.  
---|---  
label1, label2 | The labels to jump to depending on the value of var.  
CHECK | An optional check for the number of provided labels. When used, the maximum number of labels is 255.  The check will insert code to jump over the address jump block. This will limit the number of entries.   
  
Note that the index value is zero based. So when var is 0, the first specified label is jumped/branched.

It is important that each possible value has an associated label.

You must specify if you jump to the label or that you call the the label.

Use GOTO to jump to the label. Program flow will continue at that label.

Use GOSUB to call the label. The label must have a matching RETURN. Optional you can call a sub routine but it may not have parameters.

When there are not enough labels, the stack will get corrupted. For example :

ON value GOTO label1, label2

When the variable value has a value of two (2), there is no associated label.

You can use the optional CHECK so the compiler will check the value against the number of provided labels. When there are not enough labels for the value, there will be no GOTO or GOSUB and the next line will be executed.

See Also

[ON INTERRUPT](on_interrupt.md) , [GOTO](goto.md) , [GOSUB](gosub.md)

ASM

The following code will be generated for a non-MEGA micro with ON value GOTO.

Ldi R26,$60 ; load address of variable

Ldi R27,$00 ; load constant in register

Ld R24,X

Clr R25

Ldi R30, Low(ON_1_ * 1) ; load Z with address of the label

Ldi R31, High(ON_1_ * 1)

Add zl,r24 ; add value to Z

Adc zh,r25

Ijmp ; jump to address stored in Z

ON_1_:

Rjmp lbl1 ; jump table

Rjmp lbl2

Rjmp lbl3

The following code will be generated for a non-MEGA micro with ON value GOSUB.

;##### On X Gosub L1 , L2

Ldi R30,Low(ON_1_EXIT * 1)

Ldi R31,High(ON_1_EXIT * 1)

Push R30 ;push return address

Push R31

Ldi R30,Low(ON_1_ * 1) ;load table address

Ldi R31,High(ON_1_ * 1)

Ldi R26,$60

Ld R24,X

Clr R25

Add zl,r24 ; add to address of jump table

Adc zh,r25

Ijmp ; jump !!!

ON_1_:

Rjmp L1

Rjmp L2

ON_1_EXIT:

As you can see a jump is used to call the routine. Therefore the return address is first saved on the stack.

Example 1

```vb
'-----------------------------------------------------------------------------------------

'name : ongosub.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : ON .. GOSUB/GOTO

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte

Input "Enter value 0-2 " , A 'ask for input

```
Rem Note That The Starting Value Begins With 0

```vb
On A Gosub L0 , L1 , L2

Print "Returned"

If Portb < 2 Then 'you can also use the portvalue

On Portb Goto G0 , G1

End If

```
End_prog:

End

L0:

```vb
Print "0 entered"

Return

```
L1:

```vb
Print "1 entered"

Return

```
L2:

```vb
Print "2 entered"

Return

```
G0:

```vb
Print "P1 = 0"

Goto End_prog

```
G1:

```vb
Print "P1 = 1"

Goto End_prog

```
Example 2

This sample use call/sub instead of labels

```vb
'-----------------------------------------------------------------------------------------

'name : ongosub.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : ON .. GOSUB/GOTO

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Declare Sub  L0()

Declare Sub  L1()

Declare Sub  L2()

Dim A As Byte

Input "Enter value 0-2 " , A 'ask for input

```
Rem Note That The Starting Value Begins With 0

```vb
On A Gosub L0 , L1 , L2

Print "Returned"

If Portb < 2 Then 'you can also use the portvalue

On Portb Goto G0 , G1

End If

```
End_prog:

```vb
End

Sub L0()

Print "0 entered"

End Sub

Sub L1()

Print "1 entered"

End Sub

Sub L2()

Print "2 entered"

End Sub

```
G0:

```vb
Print "P1 = 0"

Goto End_prog

```
G1:

```vb
Print "P1 = 1"

Goto End_prog

```

---

## OPEN

Action

Opens a device.

Syntax

OPEN "device" for MODE As #channel

OPEN file FOR MODE as #channel

Remarks

Device | The default device is COM1 and you don't need to open a channel to use INPUT/OUTPUT on this device. With the implementation of the software UART, the compiler must know to which pin/device you will send/receive the data. So that is why the OPEN statement must be used. It tells the compiler about the pin you use for the serial input or output and the baud rate you want to use. COMB.0:9600,8,N,2 will use PORT B.0 at 9600 baud with 2 stop bits. The format for COM1 and COM2 is : COM1: or COM2: There is no speed/baud rate parameter since the default baud rate will be used which is specified with $BAUD or $BAUD1 The format for the software UART is: COMpin:speed,8,N,stopbits[,INVERTED] Where pin is the name of the PORT-pin. Speed must be specified and stop bits can be 1 or 2. 7 bit data or 8 bit data may be used. For parity N, O or E can be used. An optional parameter ,INVERTED can be specified to use inverted RS-232. Open "COMD.1:9600,8,N,1,INVERTED" For Output As #1 , will use pin PORTD.1 for output with 9600 baud, 1 stop bit and with inverted RS-232. For the AVR-DOS file system, Device can also be a string or filename constant like "readme.txt" or sFileName For the Xmega, you can also open SPIC, SPID, SPIE and SPIF for SPI communication. Or for TWI you can use TWIC, TWID, TWIE or TWIF.  
---|---  
MODE | You can use BINARY or RANDOM for COM1 and COM2, but for the software UART pins, you must specify INPUT or OUTPUT. For the AVR-DOS file system, MODE may be INPUT, OUTPUT, APPEND or BINARY.  
Channel | The number of the channel to open. Must be a positive constant >0. For the AVR-DOS file system, the channel may be a positive constant or a numeric variable. Note that the AVD-DOS file system uses real file handles. The software UART does not use real file handles. For the Xmega UART, you may use a variable that starts with BUART. This need to be a numeric variable like a byte. Using a variable allows you to use the UART dynamic.  
  
UART

The statements that support the device are [PRINT](print.md) , [INPUT](input.md) , [INPUTHEX](inputhex.md) , [INKEY](inkey.md) and [WAITKEY](waitkey.md)

Every opened device must be closed using the CLOSE #channel statement. Of course, you must use the same channel number.

In DOS the #number is a DOS file number that is passed to low level routines. In BASCOM the channel number is only used to identify the channel but there are no file handles. So opening a channel, will not use a channel. Closing a channel is not needed for UARTS. When you do so, it is ignored. If you OPEN the channel again, you will get an error message.

So use OPEN in the begin of your program, and if you use CLOSE, use it at the end of your program.

What is the difference?

In VB you can close the channel in a subroutine like this:

OPEN "com1:" for binary as #1

Call test

Close #1

```vb
End

Sub test

Print #1, "test"

End Sub

```
This will work since the file number is a real variable in the OS.

In BASCOM it will not work : the CLOSE must come after the last I/O statement:

OPEN "com1:" for binary as #1

Call test

```vb
End

Sub test

Print #1, "test"

End Sub

```
Close #1

The INPUT statement in combination with the software UART, will not echo characters back because there is no default associated pin for this.

AVR-DOS

The AVR-DOS file system uses real file handles. This means that the CLOSE statement can be used at any place in your program just as with VB.

There are a few file modes, all inherited from VB/QB. They work exactly the same.

File mode | Description  
---|---  
OUTPUT | Use OUTPUT to create a file, and to write ASCII data to the file. A readme.txt file on your PC is an example of an ASCII file. ASCII files have a trailing CR+LF for each line you print. The PRINT statement is used in combination with OUTPUT mode.  
INPUT | This mode is intended to OPEN an ASCII file and to read data only. You can not write data in this mode. The file need to exist, and must contain ASCII data. LINEINPUT can be used to read data from the file.  
APPEND | APPEND mode is used on ASCII files and will not erase the file, but will append data to the end of the file. This is useful when you want to log data to a file. Opening in OUTPUT mode would erase the file if it existed. When a file does not exist yet, it will be created. This is not the case in QB/VB.  
BINARY | In BINARY mode you have full read and write access to all data in the file. You can open a text file to get binary access, or you can open a binary file such as an image file. GET and PUT can be used with binary files.  
  
![notice](notice.jpg)The following information from the author is for advanced users only. 

GET/PUT is not supposed to work with INPUT/OUTPUT due to the rules in VB/QBASIC.

In the file CONFIG_AVR-DOS.bas (nearly at the of the file) you will find the constants 

' permission Masks for file access routine regarding to the file open mode

Const cFileWrite_Mode = &B00101010 ' Binary, Append, Output

Const cFileRead_Mode = &B00100001 ' Binary, Input

Const cFileSeekSet_Mode = &B00100000 ' Binary

Const cFileInputLine = &B00100001 ' Binary, Input

Const cFilePut_Mode = &B00100000 ' Binary

Const cFileGet_Mode = &B00100000 â Binary

Where you can control, which routines can used in each file open mode. There you can see, that in standard usage GET and PUT is only allowed in BINARY.

Some time ago I wrote the Bootloader with AVR-DOS and I had the problem to keep Flash usage as low as possible. In the Bootloader I had to work with GET to read in the bytes, because the content is no ASCII text. On the other side, if you open a file in INPUT mode, you need less code. So I tested to open the File in input mode and allow to use GET in Input Mode.

I changed:

Const cFileGet_Mode = &B00100001

So GET can work in INPUT too in the BOOTLOADER.

If you switch in the constants cFileGet_Mode the last 0 to a 1, you can use GET in INPUT Open mode to. With the bootloader.bas I changed the Config_AVR-DOS.bas too. With this changed Config_AVR-DOS.bas GET can used in INPUT, with the standard CONFIG_AVR-DOS not.

This change makes no problem in code, but I think this is only something for experienced AVR-DOS user.

Whether he can use GET in INPUT mode depends only on this last bit in the constant cFileGET_Mode in the file Config_AVR-DOS.bas. This bit controls, what can be used in INPUT mode.

Xmega-SPI

The Xmega has 4 SPI interfaces. The channel is used to communicate with the different devices. 

And just as with the Xmega UART, you can use the SPI dynamic. When the channel variable starts with BSPI, you can pass a variable channel. 

An example you will find at [CONFIG SPIx](config_spix.md)

You can OPEN a SPI device only in BINARY mode.

Xmega-TWI

The Xmega has 4 TWI interfaces. The channel is used to communicate with the different devices. 

You can OPEN a TWI device only in BINARY mode. Only constants are allowed for the channel.

See also

[CLOSE](close.md) , [CRYSTAL](crystal_2.md), [PRINT](print.md), [LINE INPUT](line_input.md) , [LOC](loc.md) , [LOF](lof.md) , [EOF](eof.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : open.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates software UART

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 10000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim B As Byte

'Optional you can fine tune the calculated bit delay

'Why would you want to do that?

'Because chips that have an internal oscillator may not

'run at the speed specified. This depends on the voltage, temp etc.

'You can either change $CRYSTAL or you can use

'BAUD #1,9610

'In this example file we use the DT006 from www.simmstick.com

'This allows easy testing with the existing serial port

'The MAX232 is fitted for this example.

'Because we use the hardware UART pins we MAY NOT use the hardware UART

'The hardware UART is used when you use PRINT, INPUT or other related statements

'We will use the software UART.

Waitms 100

'open channel for output

```
Open "comd.1:19200,8,n,1" For Output As #1

```vb
Print #1 , "serial output"

'Now open a pin for input

```
Open "comd.0:19200,8,n,1" For Input As #2

```vb
'since there is no relation between the input and output pin

'there is NO ECHO while keys are typed

Print #1 , "Number"

'get a number

Input #2 , B

'print the number

Print #1 , B

'now loop until ESC is pressed

'With INKEY() we can check if there is data available

'To use it with the software UART you must provide the channel

Do

'store in byte

```
B = Inkey(#2)

```vb
'when the value > 0 we got something

If B > 0 Then

Print #1 , Chr(b) 'print the character

End If

Loop Until B = 27

```
Close #2

Close #1

```vb
'OPTIONAL you may use the HARDWARE UART

'The software UART will not work on the hardware UART pins

'so you must choose other pins

'use normal hardware UART for printing

'Print B

'When you dont want to use a level inverter such as the MAX-232

'You can specify ,INVERTED :

'Open "comd.0:300,8,n,1,inverted" For Input As #2

'Now the logic is inverted and there is no need for a level converter

'But the distance of the wires must be shorter with this

End

```
Example XMEGA TWI

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' xm128-TWI.bas  
' This sample demonstrates the Xmega128A1 TWI  
'-----------------------------------------------------------------  
  
$regfile = "xm128a1def.dat"  
$crystal = 32000000  
$hwstack = 64  
$swstack = 40  
$framesize = 40  
  
Dim S As String * 20  
  
'first enable the osc of your choice  
Config Osc = Enabled , 32mhzosc = Enabled  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1  
  
Dim N As String * 16 , B As Byte  
Config Com1 = 19200 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
Config Input1 = Cr , Echo = Crlf ' CR is used for input, we echo back CR and LF  
  
```
Open "COM1:" For Binary As #1  
```vb
' ^^^^ change from COM1-COM8  
  
Print #1 , "Xmega revision:" ; Mcu_revid ' make sure it is 7 or higher !!! lower revs have many flaws  
  
```
Const Usechannel = 1  
  
  
```vb
Dim B1 As Byte , B2 As Byte  
Dim W As Word At B1 Overlay  
  
  
  
  
  
```
Open "twic" For Binary As #4 ' or use TWID,TWIE oR TWIF  
```vb
Config Twi = 100000 'CONFIG TWI will ENABLE the TWI master interface  
'you can also use TWIC, TWID, TWIE of TWIF  
  

#if Usechannel = 1  
```
I2cinit #4  

#else  
I2cinit  

```vb
#endif  
  
  
Do  
```
I2cstart  
Waitms 20  
I2cwbyte &H70 ' slave address write  
Waitms 20  
I2cwbyte &B10101010 ' write command  
Waitms 20  
I2cwbyte 2  
Waitms 20  
I2cstop  
```vb
Print "Error : " ; Err ' show error status  
  
'waitms 50  
Print "start"  
```
I2cstart  
Print "Error : " ; Err ' show error  
I2cwbyte &H71  
Print "Error : " ; Err ' show error  
I2crbyte B1 , Ack  
Print "Error : " ; Err ' show error  
I2crbyte B2 , Nack  
Print "Error : " ; Err ' show error  
I2cstop  
```vb
Print "received A/D : " ; W ; "-" ; B1 ; "-" ; B2  
Waitms 500 'wait a bit  
Loop  
  
  
  
Dim J As Byte , C As Byte , K As Byte  
Dim Twi_start As Byte ' you MUST dim this variable since it is used by the lib  
  
'determine if we have an i2c slave on the bus  
For J = 0 To 200 Step 2  
Print J  

#if Usechannel = 1  
```
I2cstart #4  

#else  
I2cstart  

#endif  
  
I2cwbyte J  
```vb
If Err = 0 Then ' no errors  
Print "FOUND : " ; Hex(j)  
'write some value to the pcf8574A  

#if Usechannel = 1  
```
I2cwbyte &B1100_0101 , #4  

#else  
I2cwbyte &B1100_0101  

```vb
#endif  
Print Err  
Exit For  
End If  

#if Usechannel = 1  
```
I2cstop #4  

#else  
I2cstop  

```vb
#endif  
Next  

#if Usechannel = 1  
```
I2cstop #4  

#else  
I2cstop  

```vb
#endif  
  

#if Usechannel = 1  
```
I2cstart #4  
I2cwbyte &H71 , #4 'read address  
I2crbyte J , Ack , #4  
Print Bin(j) ; " err:" ; Err  
I2crbyte J , Ack , #4  
Print Bin(j) ; " err:" ; Err  
I2crbyte J , Nack , #4  
Print Bin(j) ; " err:" ; Err  
I2cstop #4  

#else  
I2cstart  
I2cwbyte &H71 'read address  
I2crbyte J , Ack  
Print Bin(j) ; " err:" ; Err  
I2crbyte J , Ack  
Print Bin(j) ; " err:" ; Err  
I2crbyte J , Nack  
Print Bin(j) ; " err:" ; Err  
I2cstop  

```vb
#endif  
  
'try a transaction  

#if Usechannel = 1  
```
I2csend &H70 , 255 , #4 ' all 1  
Waitms 1000  
I2csend &H70 , 0 , #4 'all 0  

#else  
I2csend &H70 , 255  
Waitms 1000  
I2csend &H70 , 0  

```vb
#endif  
Print Err  
  
  
'read transaction  
Dim Var As Byte  
```
Var = &B11111111  

#if Usechannel = 1  
I2creceive &H70 , Var , 1 , 1 , #4 ' send and receive  
Print Bin(var) ; "-" ; Err  
I2creceive &H70 , Var , 0 , 1 , #4 ' just receive  
```vb
Print Bin(var) ; "-" ; Err  

#else  
```
I2creceive &H70 , Var , 1 , 1 ' send and receive  
Print Bin(var) ; "-" ; Err  
I2creceive &H70 , Var , 0 , 1 ' just receive  
```vb
Print Bin(var) ; "-" ; Err  

#endif  
  
End

```

---

## OR

Action

This logical operator returns the OR of two numeric variables.

Syntax

target = source1 OR source2

Remarks

The OR operator works on two bits. It returns a '1' if one of both inputs is '1'. 

A | B | R  
---|---|---  
0 | 0 | 0  
0 | 1 | 1  
1 | 0 | 1  
1 | 1 | 1  
  
The truth table above shows all possible values. A and B represent the 2 inputs. R is the Return or output value. As you can see, you will get a '1' when either or both inputs is '1'

It is like having 2 switches in parallel. Both switches will create a closed circuit.

While you can use OR on bits, you can also perform the same operation on bytes, integers, etc. In such a case, all bits of the variables will be OR-ed.

Example :

Dim A as Byte, B as Byte, R as byte

A=&B1100_0001

B=&B1001_0000

R=A OR B

R=&B1001_0001

See also

[AND](and.md) , [XOR](xor.md), [NOT](not.md)

Example

```vb
'--------------------------------------------------------------------------------  
'name : boolean.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demo: AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
'suited for demo : yes  
'commercial add on needed : no  
'use in simulator : possible  
'--------------------------------------------------------------------------------  
'This very same program example can be used in the Help-files for  
' AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
  
  
$baud = 19200  
$crystal = 8000000  
$regfile = "m88def.dat"  
  
$hwstack = 40  
$swstack = 20  
$framesize = 20  
  
Dim A As Byte , B1 As Byte , C As Byte  
Dim Aa As Bit , I As Integer  
  
```
A = 5 : B1 = 3 ' assign values  
C = A And B1 ' and a with b  
Print "A And B1 = " ; C ' print it: result = 1  
  
  
C = A Or B1  
Print "A Or B1 = " ; C ' print it: result = 7  
  
C = A Xor B1  
Print "A Xor B1 = " ; C ' print it: result = 6  
  
A = 1  
C = Not A  
Print "c = Not A " ; C ' print it: result = 254  
C = C Mod 10  
```vb
Print "C Mod 10 = " ; C ' print it: result = 4  
  
  
If Portb.1 = 1 Then 'test a bit from a PORT (which is not the same as testing the input state)  
Print "Bit set"  
Else  
Print "Bit not set"  
End If 'result = Bit not set  
  
Config Pinb.0 = Input : Portb.0 = 1 'configure as input pin  
Do  
Loop Until Pinb.0 = 0 ' repeat this loop until the logic level becomes 0  
  
```
Aa = 1 'use this or ..  
```vb
Set Aa 'use the set statement  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit set (aa=1)  
  
```
Aa = 0 'now try 0  
```vb
Reset Aa 'or use reset  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit not set(aa=0)  
  
```
C = 8 'assign variable to &B0000_1000  
```vb
Set C 'use the set statement without specifying the bit  
Print C 'print it: result = 9 ; bit0 has been set  
  
```
B1 = 255 'assign variable  
```vb
Reset B1.0 'reset bit 0 of a byte variable  
Print B1 'print it: result = 254 = &B11111110  
  
```
B1 = 8 'assign variable to &B00001000  
```vb
Set B1.7 'set it  
Print B1 'print it: result = 9 = &B00001001  
End

```

---

## OUT

Action

Sends a byte to a hardware port or internal or external memory address.

Syntax

OUT address, value

Remarks

Address | The address where to send the byte to in the range of 0-FFFF hex. For Xmega which supports huge memory, the address is in range from 0-&HFFFFFF.  
---|---  
Value | The variable or value to output.  
  
The OUT statement can write a value to any AVR memory location.

It is advised to use Words for the address. An integer might have a negative value and will write of course to a word address. So it will be 32767 higher as supposed. This because an integer has it's most significant bit set when it is negative.

![notice](notice.jpg) To write to XRAM locations you must enable the External RAM access in the [Compiler Chip Options](options_compiler_chip.md).

You do not need to use OUT when setting a port variable. Port variables and other registers of the micro can be set like this : PORTB = value , where PORTB is the name of the register.

![notice](notice.jpg)Take special care when using register variables. The address-part of the OUT statement, expects a numeric variable or constant. When you use a hardware register like for example PORTB, what will happen is that the value of PORTB will be used. Just as when you use a variable, it will use the variable value. 

So when the goal is to just write to a hardware register, you need to use the normal assignment : PORTB=3

See also

[INP](inp.md) , [PEEK](peek.md) , [POKE](poke.md) , [SETREG](setreg.md), [GETREG](getreg.md)

Example

Out &H8000 , 1 'send 1 to the databus(d0-d7) at hex address 8000

End

---

## PCF8533

COLOR LCD

Color displays were always relatively expensive. The mobile phone market changed that. And [Display3000.com](<http://www.display3000.com>) , sorted out how to connect these small nice colorfully displays.

You can buy brand new Color displays from Display3000. MCS Electronics offers the same displays.

There are two different chip sets used. One chip set is from EPSON and the other from Philips. For this reason there are two different libraries. When you select the wrong one it will not work, but you will not damage anything.

LCD-EPSON.LBX need to be used with the EPSON chip set.

LCD-PCF8833.LBX need to be used with the Philips chip set.

Config Graphlcd = Color , Controlport = Portc , Cs = 1 , Rs = 0 , Scl = 3 , Sda = 2

Controlport | The port that is used to control the pins. PORTA, PORTB, etc.  
---|---  
CS | The chip select pin of the display screen. Specify the pin number. 1 will mean PORTC.1  
RS | The RESET pin of the display  
SCL | The clock pin of the display  
SDA | The data pin of the display  
  
As the color display does not have a built in font, you need to generate the fonts yourself.

You can use the [Fonteditor](font_editor.md) for this task.

A number of statements accept a color parameter. See the samples below in bold.

LINE | Line(0 , 0) -(130 , 130) , Blue  
---|---  
LCDAT | Lcdat 100 , 0 , "12345678" , Blue , Yellow  
CIRCLE | Circle(30 , 30) , 10 , Blue  
PSET | 32 , 110 , Black  
BOX | Box(10 , 30) -(60 , 100) , Red  
  
See Also

[LCD Graphic converter](lcdrgb_8converter.md)

Example

```vb
' ------------------------------------------------------------------------------

' The support for this display has been made possible by Peter KÃ¼sters from (c) Display3000

' You can buy the displays from Display3000 or MCS Electronics

' ------------------------------------------------------------------------------'

'

$lib "lcd-pcf8833.lbx" 'special color display support

$regfile = "m88def.dat" 'ATMega 8, change if using different processors

$crystal = 8000000 '8 MHz

'First we define that we use a graphic LCD

Config Graphlcd = Color , Controlport = Portc , Cs = 1 , Rs = 0 , Scl = 3 , Sda = 2

'here we define the colors

```
Const Blue = &B00000011 'predefined contants are making programming easier

Const Yellow = &B11111100

Const Red = &B11100000

Const Green = &B00011100

Const Black = &B00000000

Const White = &B11111111

Const Brightgreen = &B00111110

Const Darkgreen = &B00010100

Const Darkred = &B10100000

Const Darkblue = &B00000010

Const Brightblue = &B00011111

Const Orange = &B11111000

'clear the display

Cls

'create a cross

Line(0 , 0) -(130 , 130) , Blue

Line(130 , 0) -(0 , 130) , Red

```vb
Waitms 1000

'show an RLE encoded picture

```
Showpic 0 , 0 , Plaatje

Showpic 40 , 40 , Plaatje

```vb
Waitms 1000

'select a font

```
Setfont Color16x16

'and show some text

Lcdat 100 , 0 , "12345678" , Blue , Yellow

Waitms 1000

Circle(30 , 30) , 10 , Blue

```vb
Waitms 1000

'make a box

```
Box(10 , 30) -(60 , 100) , Red

'set some pixels

Pset 32 , 110 , Black

Pset 38 , 110 , Black

Pset 35 , 112 , Black

End

Plaatje:

```vb
$bgf "a.bgc"

$include "color.font"

$include "color16x16.font"

```

---

## PEEK

Action

Returns the content of a register.

Syntax

var = PEEK( address )

Remarks

Var | Numeric variable that is assigned with the content of the memory location address  
---|---  
Address | Numeric variable or constant with the address location.(0-31)  
  
Peek() will read the content of a register.

Inp() can read any memory location

See also

[POKE](poke.md) , [CPEEK](cpeek.md) , [INP](inp.md) , [OUT](out.md) , [SETREG](setreg.md), [GETREG](getreg.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : peek.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates PEEk, POKE, CPEEK, INP and OUT

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m162def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim I As Integer , B1 As Byte

'dump internal memory

For I = 0 To 31 'only 32 registers in AVR

```
B1 = Peek(i) 'get byte from internal memory

```vb
Print Hex(b1) ; " ";

'Poke I , 1 'write a value into memory

Next

Print 'new line

'be careful when writing into internal memory !!

'now dump a part ofthe code-memory(program)

For I = 0 To 255

```
B1 = Cpeek(i) 'get byte from internal memory

```vb
Print Hex(b1) ; " ";

Next

'note that you can not write into codememory!!

```
Out &H8000 , 1 'write 1 into XRAM at address 8000

B1 = Inp(&H8000) 'return value from XRAM

```vb
Print B1

End

```

---

## PG302 programmer

The PG302 is a serial programmer. It works and looks exactly as the original PG302 software.

![BASC0082](basc0082.gif)

Select the programmer from The Option Programmer menu or right click on the ![BASC0083](basc0083.gif)button to show the [Option Programmer](options_programmer.md) menu

THIS PROGRAMMED IS MARKED FOR REMOVAL. Send a note to support if you use it.

---

## PointSize

Action

Specify the radius of points.

Syntax

PointSize size

Remarks

size | Point radius in 1/16 pixel. range 16 to 8191, the initial value is 16   
---|---  
  
Sets the size of drawn points. The width is the distance from the center of the point to the outermost drawn pixel, in

units of 1/16 pixels. The valid range is from 16 to 8191 with respect to 1/16th pixel unit.

Example

```vb
' Pseudocode

' The second point is drawn with a width of 160, for a 10 pixel radius

```
Begin_G FTPOINTS

Vertex2II 40, 30, 0, 0

PointSize 160

Vertex2II 120, 90, 0, 0

![clip0082](clip0082.png)

---

## POKE

Action

Write a byte to an internal register.

Syntax

POKE address , value

Remarks

Address | Numeric variable with the address of the memory location to set. (0-31)  
---|---  
Value | Value to assign. (0-255)  
  
See also

[PEEK](peek.md) , [CPEEK](cpeek.md) , [INP](inp.md) , [OUT](out.md), [SETREG](setreg.md), [GETREG](getreg.md)

Example

Poke 1 , 1 'write 1 to R1

End

---

## POPALL

Action

Restores all registers that might be used by BASCOM.

Syntax

POPALL

Remarks

When you are writing your own ASM routines and mix them with BASIC you are unable to tell which registers are used by BASCOM because it depends on the used statements and interrupt routines that can run on the background.

That is why Pushall saves all used registers and POPALL restores all registers.

The SREG register is also saved/restored. The SREG register contains the processor flags and it is important to save these.

If the micro has a RAMPZ register, the RAMPZ register is saved/restored also. RAMPZ is used to address multiple pages in flash and SRAM memory.

See also

[PUSHALL](pushall.md)

---

## POWER

Action

Returns the power of a single or double variable and its argument

Syntax

var = POWER( source, raise )

Remarks

Var | A numeric variable that is assigned with the power of variable source ^ raise.  
---|---  
Source | The single or double variable to get the power of.  
  
The POWER function works for positive floating point variables only.

When you use a ^ b , the sign will be preserved.

While Excel does not allow raising a negative single, QB does allow it.

The Power functions uses less code compared with the code that is generated when you use ^ for floating point values.

It is important that you use single variables for both single and raise. Constants are not accepted.

In version 1.11.9.2 the power function is improved so that it returns the same result as Excel. Previously it returned the same number as QB/VB. For example : -2 ^ 2 would be returned as -4, but -2 ^ 3 would be returned as -8 which is wring since -2 ^ 3 = -2 x -2 x -2=4 x -2 = -8. Minus times a minutes makes a positive number. So it depends on the sign of the base and if the number of raise if even or odd. 

The exception handling was also improved. 

Base | Raise | Result  
---|---|---  
0 | 0 | NAN  
NAN | x | NAN  
x | NAN | NAN  
Infinity | x | NAN  
x | Infinity | NAN  
0 | x<0 | Infinity  
0 | x>0 | 0  
x | 0 | 1  
x<0 | x<>int(x) | NAN  
  
See Also

[EXP](exp.md) ,[LOG](log.md), [LOG10](log10.md) , [SQR](sqr.md)

Example

[Show sample](fp_trig.md)

Example for Double Exceptions

```vb
$regfile = "m128def.dat"  
$crystal = 4000000

  
Dim D1 As Double , D2 As Double , D3 As Double  
Dim dInf as Double, dNAN as Double

```
d1 = -1: dNAN = log(d1)  
d1 = 1: d2 = 0: dInf = D1 / D2

```vb
Print "POWER() - Test"  
Print "=============="

```
D1 = 0: D2 = 0: GoSub ShowPowerTest

D1 = dNAN: D2 = 3: GoSub ShowPowerTest

D1 = 3: D2 = dNAN: GoSub ShowPowerTest

D1 = dInf: D2 = 4: GoSub ShowPowerTest

D1 = 4: D2 = dInf: GoSub ShowPowerTest

D1 = 0: D2 = -2: GoSub ShowPowerTest

D1 = 0: D2 = 3: GoSub ShowPowerTest

D1 = 5: D2 = 0: GoSub ShowPowerTest

D1 = -2: D2 = -3.5: GoSub ShowPowerTest

D1 = -2: D2 = 3.5: GoSub ShowPowerTest

D1 = -2: D2 = -3: GoSub ShowPowerTest

D1 = -2: D2 = -4: GoSub ShowPowerTest

D1 = -2: D2 = -5: GoSub ShowPowerTest

D1 = -2: D2 = 3: GoSub ShowPowerTest

D1 = -2: D2 = 4: GoSub ShowPowerTest

D1 = -2: D2 = 5: GoSub ShowPowerTest

  
end

  
ShowPowerTest:

D3 = POWER(D1, D2)

```vb
Print "POWER( " ; D1 ; " , " ; D2 ; ") = " ; D3

Return  
  
  
```
\--------------------------Simulator Output -------------------  
POWER() - Test

==============

POWER( 0 , 0) = NAN

POWER( NAN , 3) = NAN

POWER( 3 , NAN) = NAN

POWER( Infinity , 4) = NAN

POWER( 4 , Infinity) = NAN

POWER( 0 , -2) = Infinity

POWER( 0 , 3) = 0

POWER( 5 , 0) = 1

POWER( -2 , -3.5) = NAN

POWER( -2 , 3.5) = NAN

POWER( -2 , -3) = -125E-3

POWER( -2 , -4) = 62.5E-3

POWER( -2 , -5) = -31.25E-3

POWER( -2 , 3) = -8

POWER( -2 , 4) = 16

POWER( -2 , 5) = -32

---

## POWER MODE

Action

Put the micro processor in one of the supported power reserving modes. 

Syntax

POWER mode

Remarks

The mode depends on the micro processor.

Some valid options are :

\- IDLE

\- POWERDOWN

\- STANDBY

\- ADCNOISE

\- POWERSAVE

So for standby you would use : POWER STANDBY

It is also possible to use POWERDOWN, IDLE or POWERSAVE. These modes were/are supported by most processors. It is recommended to use the new POWER command because it allows to use more modes.

POWER has nothing to do with the [POWER](power.md)() function.

![notice](notice.jpg)THIS STATEMENT IS NOT RECOMMENDED. Please use [CONFIG POWERMODE ](config_powermode.md)instead.

See also

[IDLE](idle.md), [POWERDOWN](powerdown.md) , [POWERSAVE](powersave.md)

Example

POWER IDLE

---

## Power Up

At power up all ports are in Tri-state and can serve as input pins.

When you want to use the ports (pins) as output, you must set the data direction first with the statement : CONFIG PORTB = OUTPUT

Individual bits can also be set to be used as input or output.

For example : DDRB = &B00001111 , will set a value of 15 to the data direction register of PORTB.

PORTB.0 to PORTB.3 (the lower 4 bits) can be used as outputs because they are set high. The upper four bits (PORTB.4 to PORTB.7), can be used for input because they are set low.

You can also set the direction of a port pin with the statement :

CONFIG PINB.0 = OUTPUT | INPUT

The internal RAM is cleared at power up or when a reset occurs. Use $NORAMCLEAR to disable this feature.

You may use [$INITMICRO](_initmicro.md) to set a port level and direction immediately on startup.

---

## POWERDOWN

Action

Put processor into power down mode.

Syntax

POWERDOWN

Remarks

In the power down mode, the external oscillator is stopped. The user can use the WATCHDOG to power up the processor when the watchdog timeout expires. Other possibilities to wake up the processor is to give an external reset or to generate an external level triggered interrupt.

![notice](notice.jpg)You should use the new [CONFIG POWERMODE ](config_powermode.md)statement.

See also

[IDLE](idle.md) , [POWERSAVE](powersave.md) , [POWER mode](power_mode.md)

Example

Powerdown

---

## POWERSAVE

Action

Put processor into power save mode.

Syntax

POWERSAVE

Remarks

The POWERSAVE mode is only available in the 8535, Mega8, Mega163.

Most new chips have many options for Power down/Idle. It is advised to consult the data sheet to see if a better mode is available.

![notice](notice.jpg)You should use the new [CONFIG POWERMODE ](config_powermode.md)statement.

See also

[IDLE](idle.md), [POWERDOWN](powerdown.md) , [POWER mode](power_mode.md)

Example

Powersave

---

## PRINT

Action

Send output to the UART.

Writes a string to a file.

Writes data to a device.

Syntax

PRINT [#channel , ] var ; " constant"

Remarks

Var | The variable or constant to print.  
---|---  
  
You can use a semicolon (;) to print multiple variables or constants after each other.

When you end a line with a semicolon, no linefeed and carriage return will be added.

The PRINT routine can be used when you have a RS-232 interface on your processor.

The RS-232 interface can be connected to a serial communication port of your computer.

This way you can use a terminal emulator as an output device.

You can also use the build in terminal emulator.

When using RS-485 you can use CONFIG PRINT to set up a pin for the direction.

When printing arrays, you can only print one element at the time. When you need to print the content of a complete array, you need to use [PRINTBIN](printbin.md).

PRINT will automatic convert numeric variables into the string representation.

This means that when you have a byte variable named B with the value of 123, the numeric variable is converted into a string "123" and then printed.

In this case, print will print 3 characters or bytes. When you want to print the byte you can use the chr() function : print chr(b);

This will send just one byte to the UART.

You can connect the processors UART (TX/RX pins) to a MAX232, an FTDI232RL, a Bluetooth module or a GPS modem. Always check the logic level vcc of the UART and the device you connect to. Connecting 5V devices to a 3v3 device might damage the 3v3 device. 

A serial port can be used to update firmware with a so called boot loader. 

AVR-DOS

The AVR-DOS file system also supports PRINT. But in that case, only strings can be written to disk.

When you need to print to the second hardware UART, or to a software UART, you need to specify a channel : PRINT #1, "test"

The channel must be opened first before you can print to it. Look at [OPEN](open.md) and [CLOSE](close.md) for more details about the optional channel. For the first hardware UART, there is no need to use channels. The default for PRINT without a channel specifier, is the first UART.

So : PRINT " test" will always use the first hardware UART.

Xmega-SPI

When sending data to the SPI interface, you need to activate the SS pin. Some chips might need an active low, others might need an active high. This will depends on the slave chip.

When you use the SS=AUTO option, the level of SS will be changed automatic. Thus SS is made low, then the data bytes are sent, and finally , SS is made high again. 

For SPI, no CRLF will be sent. Thus a trailing ; is not needed. 

SPI Number of Bytes

The compiler will send 1 byte for variable which was dimensioned as a BYTE.

It will send 2 bytes for a WORD/INTEGER, 4 bytes for a LONG/SINGLE and 8 bytes for a DOUBLE.

As with all routines in BASCOM, the least significant Byte will be send first.

When you send a numeric constant, the binary value will be sent : 123 will be send a 1 byte with the value of 123.

If you send an array element, one element will be send.

With an optional parameter you can provide how many bytes must be sent. You must use a comma (,) to specify this parameter. This because the semi colon (;) is used to send multiple variables. 

![notice](notice.jpg)The delimiter for sending multiple variables is a semi colon (;) while INPUT uses the comma (,) to separate multiple variables.

Sample

```vb
Dim Tmparray(5) As Byte, Spi_send_byte As Byte, W as Word 

Config Spid = Hard, Master = Yes, Mode = 0, Clockdiv = Clk32, Data_order = Msb , Ss = Auto

```
Open "SPID" For Binary As #12 

```vb
Print #12, Spi_send_byte; W ' send ONE BYTE and 2 bytes of W

Print #12, Tmparray(1) , 2 ' send 2 bytes of tmparray, starting at element 1

Print #12, Tmparray(1) ' send 1 byte

Print #12, Tmparray(3) , 2 ' send 2 bytes starting at index 3

Print #12, 123; 1000; Tmparray(1), B' send byte with value 123, 2 bytes with value 1000, and 'b' bytes of array

```
See also

[INPUT](input.md)[,OPEN](open.md) , [CLOSE](close.md) , [SPC](spc.md) , [PRINTBIN](printbin.md) , [HEX](hex.md), [BIN](bin.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : print.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: PRINT, HEX

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte , B1 As Byte , C As Integer , S As String * 4

```
A = 1

```vb
Print "print variable a " ; A

Print ' new line

Print "Text to print." ' constant to print

```
B1 = 10

Print Hex(b1) ' print in hexa notation

C = &HA000 ' assign value to c%

```vb
Print Hex(c) ' print in hex notation

Print C ' print in decimal notation

```
C = -32000

```vb
Print C

Print Hex(c)

```
Rem Note That Integers Range From -32767 To 32768

Print "You can also use multiple" _

; "lines using _"

```vb
Print "use it for long lines"

'From version 1.11.6.4 :

```
A = &B1010_0111

Print Bin(a)

S = "1001"

A = Binval(s)

```vb
Print A '9 dec

End

```

---

## PRINTBIN

Action

Print binary content of a variable to the serial port.

Syntax

PRINTBIN var [ ; varn] [;varn [,bytes]]

PRINTBIN #channel, var [; varn] [;varn [,bytes]]

Remarks

Var | The variable which value is send to the serial port.  
---|---  
varn | Optional variables to send.  
bytes | The number of bytes to send  
  
The channel is optional and intended to be used with the [OPEN](open.md) statement.

PRINTBIN is equivalent to PRINT CHR(byteVar);

Notice that the PRINT line is ending with ; to suppress the CR+LF to be send.

When you use a Long for example, 4 bytes are printed.

Multiple variables may be sent. They must be separated by the ; sign.

Just like PRINT the ; is used to separate the data. While INPUT/INPUTBIN uses a comma (,) to separate the data.

The number of bytes to send can be specified by an additional numeric constant. This is convenient when sending the content of an array.

Printbin ar(1) ; 3 ' will send 3 bytes from array ar(1) starting at index element 1.

Printbin ar(1) ; 2 ; ar(2) ; 4 ' will send 2 bytes from array ar1() starting at index 1, then 4 bytes from array ar() starting at index 2.

When you use Printbin ar(1) the whole array will be printed assuming that CONFIG BASE=1.

When you need to print the content of a big array(array with more then 255 elements) or with a data size that exceeds 255 bytes, you need to use the CONFIG PRINTBIN option.

Variable number of bytes

Since version 2082 you can use a variable to specify the number of bytes to send. In order to keep the syntax compatible with older compilers, you must use a comma followed by the number of bytes. The number of bytes can be either a numeric constant or a numerical integer value.

Printbin Z , 1 ; Ar(1 , 1) , Q

In this example we sent 1 byte of variable Z , followed by Q bytes from variable ar(). The number will depend on the value of the variable Q.

Another example:

Dim Array(10) As Byte, Bytes_to_send As Byte

Bytes_to_send = 8

Printbin Array(1) , Bytes_to_send ' this will send 8 bytes

Bytes_to_send = 6

Printbin Array(1) , Bytes_to_send ' this will send 6 bytes, you should use comma if number of bytes is specified with variable

RS-485

When the [CONFIG PRINT](configprint.md) option is used for RS-485, the direction pin will be used by PRINTBIN as well.

When RS-485 is used, the following will happen :

\- the direction pin is toggled

\- all variables are transmitted

\- a check if performed to ensure the last byte is transmitted

\- the direction pin is toggled again

See also

[INPUTBIN](inputbin.md) , [CONFIG PRINTBIN](config_printbin.md) , [CONFIG PRINT](configprint.md), [CONFIG INPUTBIN](config_inputbin.md)

Example

```vb
Dim A(10) As Byte, C As Byte

For C = 1 To 10

```
A(c)= c ' fill array

Next

Printbin A(1) 'print content of a(1). Note that the whole array will be sent!

End

---

## PROGGY

PROGGY is a popular USB programmer written by Red_Mamba.

You need to install it and make sure that the registry key :

HKEY_CURRENT_USER\Software\Red_Mamba\Atmel programator exists with the parameter : InstallPath

InstallPath should point to the executable which name is atme.exe

When you install PROGGY, it will be handled for you. When you have an older version, you need to update.

BASCOM will call the programmer with the following options : -p -s -e

The -e will cause the programmer to exit after the programming.

THIS PROGRAMMED IS MARKED FOR REMOVAL. Send a note to support if you use it.

---

## Program Development Order

•| Start BASCOM  
---|---  
  
•| Open a file or create a new one  
---|---  
  
•| ! Important ! Check the chip settings, baud rate and frequency settings for the target system  
---|---  
  
•| Save the file  
---|---  
  
•| Compile the file (this will also save the file !!!)  
---|---  
  
•| If an error occurs fix it and recompile (F7)  
---|---  
  
•| Run the simulator(F2)  
---|---  
  
•| Program the chip(F4)  
---|---

---

## PS2MOUSE_EMULATOR

The PS2 Mouse emulator library is an optional addon library you can purchase.

The library allows you to emulate an AT PS/2 mouse.

The following statements become available:

[CONFIG PS2EMU](config_ps2emu.md)

[PS2MOUSEXY](ps2mousexy.md)

[SENDSCAN](sendscan.md)

---

## PS2MOUSEXY

Action

Sends mouse movement and button information to the PC.

Syntax

PS2MOUSEXY X , Y, button

Remarks

X | The X-movement relative to the current position. The range is â255 to 255.  
---|---  
Y | The Y-movement relative to the current position. The range is â255 to 255.  
Button | A variable or constant that represents the button state. 0 â no buttons pressed 1- left button pressed 2- right button pressed 4- middle button pressed You can combine these values by adding them. For example, 6 would emulate that the right and middle buttons are pressed. To send a mouse click, you need to send two ps2mouseXY statements. The first must indicate that the button is pressed, and the second must release the button. Ps2mouseXY 0,0,1 ' left mouse pressed PsmouseXY 0,0,0 ' left mouse released  
  
The SENDSCAN statement could also be used.

See also

[SENDSCAN](sendscan.md), [CONFIG PS2EMU](config_ps2emu.md)

---

## PULSEIN

Action

Returns the number of units between two occurrences of an edge of a pulse.

Syntax

PULSEIN var , PINX , PIN , STATE

Remarks

var | A word variable that is assigned with the result.  
---|---  
PINX | A PIN register like PIND  
PIN | The pin number(0-7) to get the pulse time of.  
STATE | May be 0 or 1. 0 means sample 0 to 1 transition. 1 means sample 1 to 0 transition.  
  
ERR variable will be set to 1 in case of a time out. A time out will occur after 65535 unit counts. With 10 uS units this will be after 655.35 mS.

You can add a [bitwait](bitwait.md) statement to be sure that the PULSEIN statement will wait for the start condition. But when using the BITWAIT statement and the start condition will never occur, your program will stay in a loop.

The PULSIN statement will wait for the specified edge.

When state 0 is used, the routine will wait until the level on the specified input pin is 0. Then a counter is started and stopped until the input level gets 1.

No hardware timer is used. A 16 bit counter is used. It will increase in 10 uS units. But this depends on the XTAL. You can change the library routine to adjust the units.

PULSEIN.LIB

The full version includes a lib named pulsein.lib. It overloads the pulsein statement. This special lib allows to set a custom timeout and delay.

You need to add the following to your code :

const cPulseIn_Timeout = 0 'This is the default timeout value. When you increase the value you will get a shorter time out period.

```vb
dim bPulseIn_Delay as byte : bPulseIn_Delay = 10 'For 10 uS units , the default is 1

$lib "pulsein.lib" 'include the lib to overload the function

```
See also

[PULSEOUT](pulseout.md)

ASM

The following ASM routine is called from mcs.lib

_pulse_in (calls _adjust_pin)

```vb
On entry ZL points to the PINx register , R16 holds the state, R24 holds the pin number to sample.

On return XL + XH hold the 16 bit value.

```
Example

Dim w As Word

pulsein w , PIND , 1 , 0 'detect time from 0 to 1

```vb
print w

End

```

---

## PULSEIN

The full version includes a lib named pulsein.lib. It overloads the [PULSEIN](pulsein.md) statement. This special lib allows to set a custom timeout and delay.

You need to add the following to your code :

const cPulseIn_Timeout = 0 'This is the default timeout value. When you increase the value you will get a shorter time out period.

```vb
dim bPulseIn_Delay as byte : bPulseIn_Delay = 10 'For 10 uS units , the default is 1

$lib "pulsein.lib" 'include the lib to overload the function

```
The library is compatible with the default lib.

---

## PULSEOUT

Action

Generates a pulse on a pin of a PORT of specified period in 1uS units for 4 MHz.

Syntax

PULSEOUT PORT , PIN , PERIOD

Remarks

PORT | Name of the PORT. PORTB for example  
---|---  
PIN | Variable or constant with the pin number (0-7).  
PERIOD | Number of periods the pulse will last. The periods are in uS when an XTAL of 4 MHz is used.  
  
The pulse is generated by toggling the pin twice, thus the initial state of the pin determines the polarity.

The PIN must be configured as an output pin before this statement can be used.

See also

[PULSEIN](pulsein.md)

Example

```vb
Dim A As Byte

Config Portb = Output 'PORTB all output pins

```
Portb = 0 'all pins 0

```vb
Do

For A = 0 To 7

```
Pulseout Portb , A , 60000 'generate pulse

```vb
Waitms 250 'wait a bit

Next

Loop 'loop for ever

```

---

## PUSHALL

Action

Saves all registers that might be used by BASCOM.

Syntax

PUSHALL

Remarks

When you are writing your own ASM routines and mix them with BASIC you are unable to tell which registers are used by BASCOM because it depends on the used statements and interrupt routines that can run on the background.

That is why Pushall saves all used registers. Use POPALL to restore the registers.

The saved registers are : R0-R5, R7,R10,R11 and R16-R31

The SREG register is also saved. The SREG register contains the processor flags and it is important to save these.

If the micro has a RAMPZ register, the RAMPZ register is saved too. RAMPZ is used to address multiple pages in flash and SRAM memory.

In order to save SREG a register is required. R24 was used for that till version 2086. In version 2087 R25 is used. This because R24 is used to pass data and the value would be altered by the operation. Of course an additional push/pop could be used but this take time.

So when it is essential that after PUSHALL statement all registers have the same value, you must save R25 yourself using this code :

!push R25

PUSHAL

!pop R25

See also

[POPALL](popall.md)

---

## PUT

Action

Writes a byte to the hardware or software UART.

Writes data to a file opened in BINARY mode.

Syntax

PUT #channel, var

PUT #channel, var ,[pos] [,length]

Remarks

PUT in combination with the software/hardware UART is provided for compatibility with BASCOM-8051. It writes one byte

PUT in combination with the AVR-DOS file system is very flexible and versatile. It works on files opened in BINARY mode and you can write all data types.

#channel | A channel number, which identifies an opened file. This can be a hard coded constant or a variable.  
---|---  
Var | The variable or variable array that will be written to the file  
Pos | This is an optional parameter that may be used to specify the position where the data must be written. This must be a long variable.  
Length | This is an optional parameter that may be used to specify how many bytes must be written to the file.  
  
By default you only need to provide the variable name. When the variable is a byte, 1 byte will be written. When the variable is a word or integer, 2 bytes will be written. When the variable is a long or single, 4 bytes will be written. When the variable is a string, the number of bytes that will be written is equal to the dimensioned size of the string. DIM S as string * 10 , would write 10 bytes.

Note that when you specify the length for a string, the maximum length is 255. The maximum length for a non-string array is 65535.

Example

PUT #1, var

PUT #1, var , , 2 ' write 2 bytes at default position

PUT #1, var ,PS, 2 ' write 2 bytes at location storied in variable PS

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md), [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md), [AVR-DOS File system](avr_dos_file_system.md)

ASM

current position | Goto new position first  
---|---  
Byte: |   
_FilePutRange_1 Input: r24: File number X: Pointer to variable T-Flag cleared | _FilePutRange_1 Input: r24: File number X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
Word/Integer: |   
_FilePutRange_2 Input: r24: File number X: Pointer to variable T-Flag cleared | _FilePutRange_2 Input: r24: File number X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
Long/Single: |   
_FilePutRange_4 Input: r24: File number X: Pointer to variable T-Flag cleared | _FilePutRange_4 Input: r24: File number X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
String (<= 255 Bytes) with fixed length |   
_FilePutRange_Bytes Input: r24: File number r20: Count of Bytes X: Pointer to variable T-Flag cleared | _FilePutRange_Bytes Input: r24: File number r20: Count of bytes X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
Array (> 255 Bytes) with fixed length |   
_FilePutRange Input: r24: File number r20/21: Count of Bytes X: Pointer to variable T-Flag cleared | _FilePutRange Input: r24: File number r20/21: Count of bytes X: Pointer to variable r16-19 (A): New position (1-based) T-Flag Set  
  
Output from all kind of usage:

r25: Error Code

C-Flag on Error

Example

```vb
'for the binary file demo we need some variables of different types  
Dim B As Byte, W As Word, L As Long, Sn As Single, Ltemp As Long  
Dim Stxt As String* 10  
```
B = 1 : W = 50000 : L = 12345678 : Sn = 123.45 : Stxt ="test"  
  
'open the file in BINARY mode  
Open "test.biN" For Binary As#2  
Put#2 , B ' write a byte  
Put#2 , W ' write a word  
Put#2 , L ' write a long  
Ltemp =Loc(#2)+ 1 ' get the position of the next byte  
```vb
Print Ltemp ;" LOC"' store the location of the file pointer  
Print Seek(#2);" = LOC+1"  
  
Print Lof(#2);" length of file"  
Print Fileattr(#2);" file mode"' should be 32 for binary  
```
Put#2 , Sn ' write a single  
Put#2 , Stxt ' write a string  
  
Flush#2 ' flush to disk  
Close#2  
  
'now open the file again and write only the single  
Open "test.bin" For Binary As #2  
L = 1 'specify the file position  
B =Seek(#2 , L) ' reset is the same as using SEEK #2,L  
Get#2 , B ' get the byte  
Get#2 , W ' get the word  
Get#2 , L ' get the long  
Get#2 , Sn ' get the single  
Get#2 , Stxt ' get the string  
Close#2

---

## QCOS

Action

Returns the Co Sinus of an integer

Syntax

var = QCOS( source )

Remarks

Var | A numeric integer variable that is assigned with sinus of variable source.  
---|---  
source | The integer variable to get the Co Sinus of.  
  
Integer SIN and COS use a lookup table to determine the Sinus or Co sinus. Qsin and Qcos are used by some of the FT800 routines.

See Also

[SIN](qsin.md)

Example

NONE

---

## QSIN

Action

Returns the sinus of an integer

Syntax

var = QSIN( source )

Remarks

Var | A numeric integer variable that is assigned with sinus of variable source.  
---|---  
source | The integer variable to get the sinus of.  
  
Integer SIN and COS use a lookup table to determine the Sinus or Co sinus. Qsin and Qcos are used by some of the FT800 routines.

![qsin](qsin.png)

The sinus of angle α is shown above. At 0 degrees the value on the y-ax is 0 and at 90 degrees, the value is at its maximum on the Y-ax. In the first quadrant of the circle (1) sinus will have a positive number as a result. In quadrant 2 of the circle, the sinus goes from the maximum value down to 0 and the result is a positive number as well.

In quadrant 3 and 4 of the circle, we will get a negative number as a result since the result is below the x-ax.

The QSIN works with integers which have a range from -32768 to 32767. This means that for the quadrant 1 and 2 we can use a value between 0 and 32767. In degrees we would use a value between 0 and 180. This means that each degree has a value of 182 (32767/180). 

The negative values are reserved for quadrant 3 and 4. 

Instead of integers you can also use a word variable.

The following simple sample will show the input and output values.

```vb
Dim Iii As Integer , I2 As Integer , W As Word

For W= 0 To 65535 Step 182

```
Iii = W ' for usage as an integer

I2 = Qsin(iii) ' get the value of W/III

```vb
Print W; " " ; Iii ; " " ; I2

Next

```
This will give the output :

W III QSIN 

0 0 0

182 182 571

364 364 1143

546 546 1713

728 728 2284

910 910 2854

1092 1092 3423

1274 1274 3992

1456 1456 4558

1638 1638 5124

1820 1820 5687

\--snip--

15470 15470 32640

15652 15652 32685

15834 15834 32720

16016 16016 32745

16198 16198 32760

16380 16380 32766

16562 16562 32761

16744 16744 32746

16926 16926 32721

17108 17108 32687

17290 17290 32643

17472 17472 32588

17654 17654 32523

17836 17836 32448

18018 18018 32364

18200 18200 32270

18382 18382 32166

18564 18564 32053

18746 18746 31929

18928 18928 31796

19110 19110 31653

19292 19292 31500

19474 19474 31339

19656 19656 31166

19838 19838 30986

20020 20020 30794

20202 20202 30595

20384 20384 30386

20566 20566 30167

20748 20748 29939

20930 20930 29702

21112 21112 29456

21294 21294 29202

21476 21476 28938

21658 21658 28666

21840 21840 28384

22022 22022 28095

22204 22204 27796

22386 22386 27489

22568 22568 27173

22750 22750 26850

\--snip--

32214 32214 1738

32396 32396 1168

32578 32578 596

32760 32760 25

32942 -32594 -546

33124 -32412 -1118

33306 -32230 -1688

33488 -32048 -2259

33670 -31866 -2829

33852 -31684 -3398

\--snip --

48230 -17306 -32638

48412 -17124 -32683

48594 -16942 -32719

48776 -16760 -32744

48958 -16578 -32760

49140 -16396 -32766

49322 -16214 -32761

49504 -16032 -32747

49686 -15850 -32723

49868 -15668 -32688

50050 -15486 -32645

50232 -15304 -32590

50414 -15122 -32526

50596 -14940 -32452

50778 -14758 -32368

50960 -14576 -32275

51142 -14394 -32171

51324 -14212 -32058

51506 -14030 -31934

51688 -13848 -31802

51870 -13666 -31659

52052 -13484 -31507

52234 -13302 -31346

52416 -13120 -31174

52598 -12938 -30994

52780 -12756 -30803

52962 -12574 -30604

53144 -12392 -30395

\--snip--

63154 -2382 -7417

63336 -2200 -6859

63518 -2018 -6299

63700 -1836 -5737

63882 -1654 -5173

64064 -1472 -4608

64246 -1290 -4042

64428 -1108 -3473

64610 -926 -2904

64792 -744 -2334

64974 -562 -1764

65156 -380 -1193

65338 -198 -621

65520 -16 -50

![qsin_excel](qsin_excel.png)

When we feed the output in Excel we can create the graph above, showing a perfect sinus.

See Also

[QCOS](qcos.md)

Example

NONE

---

## QUOTE

Action

The Quote function will return a string surrounded by quotes.

Syntax

var = QUOTE( Source )

Remarks

Var | A string variable that is assigned with the quoted string of variable source.  
---|---  
Source | The string or string constant to be quoted.  
  
The Quote() function can be used in HTML web server pages. 

QUOTE supports [$BIGSTRINGS](bigstrings.md)

See also

NONE

Example

Dim S as String * 20

S = "test"

S = Quote(s)

```vb
Print S ' would print "test"

End

```

---

## RAD2DEG

Action

Converts a value from radians to degrees.

Syntax

var = RAD2DEG( Source )

Remarks

Var | A numeric variable that is assigned with the angle of variable source.  
---|---  
Source | The single or double variable to get the angle of.  
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[DEG2RAD](deg2rad.md)

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates DEG2RAD function

'-------------------------------------------------------------------------------

Dim S As Single

```
S = 90

S = Deg2Rad(s)

Print S

S = Rad2deg(s)

```vb
Print S

End

```

---

## RD16

Action

This function returns a WORD from the FT800 processor.

Syntax

var = RD16(address)

Remarks

NONE

See also

[RD8](rd8.md), [RD32](rd32.md) , [CMD32](cmd32.md), [WR32](wr32.md)

Example

```vb
Sub Dlswap()  
'------------------------------------------------------------------------------------------------------------  
' API to check the status of previous DLSWAP and perform DLSWAP of new DL  
' Check for the status of previous DLSWAP and if still not done wait for few ms and check again  
  
```
Local Swap_done As Byte  
  
' Perform a new DL swap  
Wr8 Reg_dlswap , Dlswap_frame  
  
```vb
' Wait till the swap is done  
While Swap_done > 0  
```
Swap_done = Rd8(reg_dlswap)  
```vb
If Dlswap_done <> Swap_done Then  
Waitms 10  
End If  
Wend  
  
End Sub ' Dlswap

```

---

## RD32

Action

This function returns a DWORD from the FT800 processor.

Syntax

var = RD32(address)

Remarks

NONE

See also

[RD8](rd8.md) , [RD16](rd16.md) , [CMD32](cmd32.md), [WR32](wr32.md)

Example

```vb
Sub Dlswap()  
'------------------------------------------------------------------------------------------------------------  
' API to check the status of previous DLSWAP and perform DLSWAP of new DL  
' Check for the status of previous DLSWAP and if still not done wait for few ms and check again  
  
```
Local Swap_done As Byte  
  
' Perform a new DL swap  
Wr8 Reg_dlswap , Dlswap_frame  
  
```vb
' Wait till the swap is done  
While Swap_done > 0  
```
Swap_done = Rd8(reg_dlswap)  
```vb
If Dlswap_done <> Swap_done Then  
Waitms 10  
End If  
Wend  
  
End Sub ' Dlswap

```

---

## RD8

Action

This function returns a BYTE from the FT800 processor.

Syntax

var = RD8(address)

Remarks

NONE

See also

[RD16](rd16.md) , [RD32](rd32.md) , [CMD32](cmd32.md), [WR32](wr32.md)

Example

```vb
Sub Dlswap()  
'------------------------------------------------------------------------------------------------------------  
' API to check the status of previous DLSWAP and perform DLSWAP of new DL  
' Check for the status of previous DLSWAP and if still not done wait for few ms and check again  
  
```
Local Swap_done As Byte  
  
' Perform a new DL swap  
Wr8 Reg_dlswap , Dlswap_frame  
  
```vb
' Wait till the swap is done  
While Swap_done > 0  
```
Swap_done = Rd8(reg_dlswap)  
```vb
If Dlswap_done <> Swap_done Then  
Waitms 10  
End If  
Wend  
  
End Sub ' Dlswap

```

---

## READ

Action

Reads those values and assigns them to variables.

Syntax

READ var

Remarks

Var | Variable that is assigned data value.  
---|---  
  
It is best to place the [DATA](data_2.md) lines at the end of your program.

![notice](notice.jpg) It is important that the variable is of the same type as the stored data.

See also

[DATA](data_2.md) , [RESTORE](restore.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : readdata.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : READ,RESTORE

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Integer , B1 As Byte , Count As Byte

Dim S As String * 15

Dim L As Long

```
Restore Dta1 'point to stored data

For Count = 1 To 3 'for number of data items

Read B1 : Print Count ; " " ; B1

Next

Restore Dta2 'point to stored data

For Count = 1 To 2 'for number of data items

Read A : Print Count ; " " ; A

Next

Restore Dta3

Read S : Print S

Read S : Print S

Restore Dta4

Read L : Print L 'long type

```vb
'demonstration of readlabel

Dim W As Iram Word At 8 Overlay ' location is used by restore pointer

'note that W does not use any RAM it is an overlayed pointer to the data pointer

```
W = Loadlabel(dta1) ' loadlabel expects the labelname

Read B1

```vb
Print B1

End

```
Dta1:

Data &B10 , &HFF , 10

Dta2:

Data 1000% , -1%

Dta3:

Data "Hello" , "World"

```vb
'Note that integer values (>255 or <0) must end with the %-sign

'also note that the data type must match the variable type that is

'used for the READ statement

```
Dta4:

Data 123456789&

```vb
'Note that LONG values must end with the &-sign

'Also note that the data type must match the variable type that is used

'for the READ statement

```

---

## READEEPROM

Action

Reads the content from the DATA EEPROM and stores it into a variable.

Syntax

READEEPROM var , address

Remarks

Var | The name of the variable that must be stored  
---|---  
Address | The address in the EEPROM where the data must be read from.  
  
This statement is provided for backwards compatibility with BASCOM-8051.

You can also use the ERAM variable instead of READEEPROM :

```vb
Dim V as Eram Byte 'store in EEPROM

Dim B As Byte 'normal variable

```
B = 10

V = B 'store variable in EEPROM

B = V 'read from EEPROM

When you use the assignment version, the data types must be equal!

According to a data sheet from ATMEL, the first location in the EEPROM with address 0, can be overwritten during a reset so don't use it.

You may also use ERAM variables as indexes. Like :

Dim ar(10) as Eram Byte

When you omit the address label in consecutive reads, you must use a new READEEPROM statement. It will not work in a loop:

Readeeprom B , Label1

```vb
Print B

Do

```
Readeeprom B

Print B Loop

Until B = 5

This will not work since there is no pointer maintained. The way it will work :

ReadEEprom B , Label1 ' specify label

ReadEEPROM B ' read next address in EEPROM

ReadEEPROM B ' read next address in EEPROM

OR

```vb
Dim Next_Read as Integer

Dim In_byte as Byte

Dim Eerom_position as Integer

```
Eerom_position = 20 ' Set the start read point in eerom

For Next_Read = 1 To 5 Step 1 ' Set up the bytes to be read from eeprom

Readeeprom In_byte , eeprom_position ' Use a variable as the pointer to eeprom location

Call another_sub_routine ' 

Incr Chr_pos_font ' Now set pointer for next eeprom data byte

Next

In the XMEGA, you need to set the mode to mapped : [CONFIG EEPROM](config_eeprom.md) = MAPPED.

See also

[WRITEEEPROM](writeeeprom.md) , [$EEPROM](eeprom.md)

ASM

NONE

Example

```vb
'-----------------------------------------------------------------------------------------

'name : eeprom2.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : shows how to use labels with READEEPROM

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'first dimension a variable

Dim B As Byte

Dim Yes As String * 1

'Usage for readeeprom and writeeprom :

'readeeprom var, address

'A new option is to use a label for the address of the data

'Since this data is in an external file and not in the code the eeprom data

'should be specified first. This in contrast with the normal DATA lines which must

'be placed at the end of your program!!

'first tell the compiler that we are using EEPROM to store the DATA

$eeprom

'the generated EEP file is a binary file.

'Use $EEPROMHEX to create an Intel Hex file usable with AVR Studio.

'$eepromhex

'specify a label

```
Label1:

Data 1 , 2 , 3 , 4 , 5

Label2:

Data 10 , 20 , 30 , 40 , 50

```vb
'Switch back to normal data lines in case they are used

$data

'All the code above does not generate real object code

'It only creates a file with the EEP extension

'Use the new label option

```
Readeeprom B , Label1

```vb
Print B 'prints 1

'Succesive reads will read the next value

'But the first time the label must be specified so the start is known

```
Readeeprom B

Print B 'prints 2

Readeeprom B , Label2

Print B 'prints 10

Readeeprom B

```vb
Print B 'prints 20

'And it works for writing too :

'but since the programming can interfere we add a stop here

Input "Ready?" , Yes

```
B = 100

Writeeeprom B , Label1

B = 101

Writeeeprom B

'read it back

Readeeprom B , Label1

```vb
Print B 'prints 100

'Succesive reads will read the next value

'But the first time the label must be specified so the start is known

```
Readeeprom B

```vb
Print B 'prints 101

End

```

---

## READHITAG

Action

Read HITAG RFID transponder serial number.

Syntax

result = READHITAG(var) 

Remarks

result | A numeric variable that will be 0 if no serial number was read from the transponder. It will return 1 if a valid number was read.  
---|---  
  
RFID is used for entrance systems, anti theft, and many other applications where a wireless chip is an advantage over the conventional magnetic strip and chip-card. 

The HITAG series from Philips(NXP) is one of the oldest and best available. The HTRC110 chip is a simple to use chip that can read and write transponders. Each transponder chip has a 5 byte(40 bits) unique serial number.

The only disadvantage of the HTRC110 is that you need to sign an NDA in order to get the important documents and 8051 example code.

When the transponder is held before the coil of the receiver, the bits stream will be modulated with the bit values. Just like RC5, HITAG is using Manchester encoding. This is a simple and reliable method used in transmission systems.

Manchester encoding is explained very well at the [Wiki](<http://en.wikipedia.org/wiki/Manchester_code>) Manchester page.

![manchester_encoding](manchester_encoding.png)

The image above is copied from the Wiki. 

There are 2 methods to decode the bits. You can detect the edges of the bits and sample on 3/4 of the bit time.

Another way is to use a state machine. The state machine will check the length between the edges of the pulse. It will start with the assumption that there is a (1). Then it will enter the MID1 state. If the next pulse is a long pulse, we have received a (0). When it received a short pulse, we enter the start1 state. Now we need to receive a short space which indicated a (1), otherwise we have an invalid state. When we are in the MID0 state, we may receive a long space(1) or a short space. All others pulses are invalid and lead to a restart of the pulse state(START).

Have a look at the image above. Then see how it really works. We start with assuming a (1). We then receive a long pulse so we receive a (0). Next we receive a long space which is a (1). And again a long pulse which is a (0) again. Then we get a short space and we are in start1 state. We get a short pulse which is a (0) and we are back in MID0 state. The long space will be a (1) and we are in MID1 state again. etc.etc. When ever we receive a pulse or space which is not defined we reset the pulse state machine.

![manchester_decoding](manchester_decoding.png)

At 125 KHz, the bit time is 512 uS. A short pulse we define as halve a bit time which is 256 uS.

We use a 1/4 of the bit time as an offset since the pulses are not always exactly precise.

So a short bit is 128-384(256-128 - 256+128 ) uS. And a long bit is 384-640 uS (512-128 - 512+128).

We use TIMER0 which is an 8 bit timer available in all AVR's to determine the time. 

Since most micro's have an 8 MHz internal clock, we run the program in 8 MHz. It depends on the pre scaler value of the timer, which value are used to determine the length between the edges.

You can use 64 or 256. The generated constants are : _TAG_MIN_SHORT, _TAG_MAX_SHORT , _TAG_MIN_LONG and _TAG_MAX_LONG. 

We need an interrupt to detect when an edge is received. We can use the INTx for this and configure the pin to interrupt when a logic level changes. Or we can use the PIN interrupt so we can use more pins.

The sample contains both methods. 

It is important that the ReadHitag() functions needs a variable that can store 5 bytes. This would be an array.

And you need to check the _TAG constants above so that they do not exceed 255. 

When you set up the interrupt, you can also use it for other tasks if needed. You only need to call the _checkhitag routine in the subroutine. And you need to make sure that the additional code you write does not take up too much time.

When you use the PCINT interrupt it is important to realize that other pins must be masked off. The PCMSK register may have only 1 bit enabled. Otherwise there is no way to determine which pin was changed. 

EM4095

The EM4095 is similar to the HTRC110. The advantage of the EM4095 is that it has a synchronized clock and needs no setup and less pins.

The EM4095 library uses the same method as the RC5 decoding : the bit is sampled on 3/4 of the bit length. The parity handling is the same. The EM4095 decoding routine is smaller then the HTRC110 decoding library.

A reference design for the EM4095 will be available from MCS.

See also

[READMAGCARD](readmagcard.md) , [CONFIG HITAG](config_hitag.md)

Example

See [CONFIG HITAG ](config_hitag.md)for 2 examples.

---

## READMAGCARD

Action

Read data from a magnetic card.

Syntax

READMAGCARD var , count , coding

Remarks

Var | A byte array the receives the data.  
---|---  
Count | A byte variable that returns the number of bytes read.  
coding | A numeric constant that specifies if 5 or 7 bit coding is used. Valid values are 5 and 7.  
  
There can be 3 tracks on a magnetic card.

Track 1 stores the data in 7 bit including the parity bit. This is handy to store alpha numeric data.

On track 2 and 3 the data is stored with 5 bit coding.

The ReadMagCard routine works with ISO7811-2 5 and 7 bit decoding.

The returned numbers for 5 bit coding are:

Returned number | ISO characterT  
---|---  
0 | 0  
1 | 1  
2 | 2  
3 | 3  
4 | 4  
5 | 5  
6 | 6  
7 | 7  
8 | 8  
9 | 9  
10 | hardware control  
11 | start byte  
12 | hardware control  
13 | separator  
14 | hardware control  
15 | stop byte  
  
Example

```vb
'-----------------------------------------------------------------------------------------

'name : magcard.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : show you how to read data from a magnetic card

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'[reserve some space]

Dim Ar(100) As Byte , B As Byte , A As Byte

'the magnetic card reader has 5 wires

'red - connect to +5V

'black - connect to GND

'yellow - Card inserted signal CS

'green - clock

'blue - data

'You can find out for your reader which wires you have to use by connecting +5V

'And moving the card through the reader. CS gets low, the clock gives a clock pulse of equal pulses

'and the data varies

'I have little knowledge about these cards and please dont contact me about magnectic readers

'It is important however that you pull the card from the right direction as I was doing it wrong for

'some time :-)

'On the DT006 remove all the jumpers that are connected to the LEDs

'[We use ALIAS to specify the pins and PIN register]

```
_mport Alias Pinb 'all pins are connected to PINB

_mdata Alias 0 'data line (blue) PORTB.0

_mcs Alias 1 'CS line (yellow) PORTB.1

_mclock Alias 2 'clock line (green) PORTB.2

Config Portb = Input 'we only need bit 0,1 and 2 for input

Portb = 255 'make them high

```vb
Do

Print "Insert magnetic card" 'print a message

```
Readmagcard Ar(1) , B , 5 'read the data

```vb
Print B ; " bytes received"

For A = 1 To B

Print Ar(a); 'print the bytes

Next

Print

Loop

'By specifying 7 instead of 5 you can read 7 bit data

```

---

## READSIG

Action

This function reads a byte from the signature area.

Syntax

var = READSIG(offset)

Remarks

Var | A byte that is assigned with the signature byte.  
---|---  
Offset | A byte variable or constant with an offset to the signature.  
  
The Xmega has a number of signature bytes that are important.

For example the ADC is calibrated in the factory and the calibration data need to be loaded into the ADC registers in order to achieve 12 bit resolution.

The following offset table is copied from the Xmega128A1 definition file. It should be the same for all other Xmega chips but it is best to check it.

Const NVM_PROD_SIGNATURES_RCOSC2M_offset = &H00 ' RCOSC 2MHz Calibration Value

Const NVM_PROD_SIGNATURES_RCOSC32K_offset =&H02 ' RCOSC 32kHz Calibration Value

Const NVM_PROD_SIGNATURES_RCOSC32M_offset = &H03 ' RCOSC 32MHz Calibration Value

Const NVM_PROD_SIGNATURES_LOTNUM0_offset = &H08 ' Lot Number Byte 0, ASCII

Const NVM_PROD_SIGNATURES_LOTNUM1_offset = &H09 ' Lot Number Byte 1, ASCII

Const NVM_PROD_SIGNATURES_LOTNUM2_offset = &H0A ' Lot Number Byte 2, ASCII

Const NVM_PROD_SIGNATURES_LOTNUM3_offset = &H0B ' Lot Number Byte 3, ASCII

Const NVM_PROD_SIGNATURES_LOTNUM4_offset = &H0C ' Lot Number Byte 4, ASCII

Const NVM_PROD_SIGNATURES_LOTNUM5_offset = &H0D ' Lot Number Byte 5, ASCII

Const NVM_PROD_SIGNATURES_WAFNUM_offset = &H10 ' Wafer Number

Const NVM_PROD_SIGNATURES_COORDX0_offset = &H12 ' Wafer Coordinate X Byte 0

Const NVM_PROD_SIGNATURES_COORDX1_offset = &H13 ' Wafer Coordinate X Byte 1

Const NVM_PROD_SIGNATURES_COORDY0_offset = &H14 ' Wafer Coordinate Y Byte 0

Const NVM_PROD_SIGNATURES_COORDY1_offset = &H15 ' Wafer Coordinate Y Byte 1

Const NVM_PROD_SIGNATURES_ADCACAL0_offset = &H20 ' ADCA Calibration Byte 0

Const NVM_PROD_SIGNATURES_ADCACAL1_offset = &H21 ' ADCA Calibration Byte 1

Const NVM_PROD_SIGNATURES_ADCBCAL0_offset = &H24 ' ADCB Calibration Byte 0

Const NVM_PROD_SIGNATURES_ADCBCAL1_offset = &H25 ' ADCB Calibration Byte 1

Const NVM_PROD_SIGNATURES_TEMPSENSE0_offset = &H2E ' Temperature Sensor Calibration Byte 0

Const NVM_PROD_SIGNATURES_TEMPSENSE1_offset = &H2F ' Temperature Sensor Calibration Byte 0

Const NVM_PROD_SIGNATURES_DACAOFFCAL_offset = &H30 ' DACA Calibration Byte 0

Const NVM_PROD_SIGNATURES_DACACAINCAL_offset = &H31 ' DACA Calibration Byte 1

Const NVM_PROD_SIGNATURES_DACBOFFCAL_offset = &H32 ' DACB Calibration Byte 0

Const NVM_PROD_SIGNATURES_DACBGAINCAL_offset = &H33 ' DACB Calibration Byte 1

```vb
While the XMEGA was the first processor with support of reading the signature row, all new UPDI AVR chips also have this functionality. And some plain AVR processors like the PB series (atmega328PB)

While in UPDI chips (Xtiny, megaX, AVRX) all these signature registers can be accessed by a register, the ReadSig() function can also read the register contents. ReadSig() was added for compatibility.

```
See also

[READUSERSIG](readusersig.md)

Example XMEGA

```vb
'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' xm128-readsig.bas  
' This sample demonstrates how to read signature bytes  
'-----------------------------------------------------------------  
  
$regfile = "xm128a1def.dat"  
$crystal = 32000000  
$hwstack = 64  
$swstack = 40  
$framesize = 40  
  
'include the following lib and code, the routines will be replaced since they are a workaround  
  
'first enable the osc of your choice  
Config Osc = Enabled , 32mhzosc = Enabled  
  
'configure the systemclock  
Config Sysclock = 32mhz , Prescalea = 1 , Prescalebc = 1_1  
  
Config Com1 = 19200 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
  
  
Dim Offset As Byte , J As Byte  
  
For J = 0 To 32  
```
Offset = Readsig(j) : Print J ; " - " ; Offset  
```vb
Next  
End

```
Example MEGA328

```vb
'--------------------------------------------------------------------------------  
'name : m328pb.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demonstrates M328pb  
'micro : Mega328pb  
'suited for demo : yes  
'commercial addon needed : no  
'--------------------------------------------------------------------------------  
$regfile = "m328pbdef.dat"  
$crystal = 8000000  
$baud = 19200  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
'USART TX RX  
' 0 D.1 D.0  
' 1 B.3 B.4  
  
'ISP programming  
'MOSI-PB3 MISO-PB4 SCK-PB5  
Config Clockdiv = 1  
Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  
Config Com2 = 19200 , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  
  
  
```
Const Device_signature_byte1 = 0  
Const Device_signature_byte2 = 2  
Const Device_signature_byte3 = 4  
Const Rc_oscillator_calibration = 1  
Const Serial_number_byte0 = &H0E  
Const Serial_number_byte1 = &H0F  
Const Serial_number_byte2 = &H10  
Const Serial_number_byte3 = &H11  
Const Serial_number_byte4 = &H12  
Const Serial_number_byte5 = &H13  
Const Serial_number_byte6 = &H14  
Const Serial_number_byte7 = &H15  
Const Serial_number_byte8 = &H16  
Const Serial_number_byte9 = &H17  
  
  
Print "ID : " ; Hex(readsig(device_signature_byte1)) ; Hex(readsig(device_signature_byte2)) ; Hex(readsig(device_signature_byte3))

---

## READUSERSIG

Action

This function reads data from the User Signature Area available in the UPDI platform.

Syntax

targ = ReadUserSig(address [, bytes])

Remarks

targ | A variable that is assigned with the data byte(s)  
---|---  
address | The address where reading must start. This must be in the range from 0 up to the available data length - 1. So when the user signature is 32 bytes, the range is from 0-31.  
bytes | The number of bytes to read. This is an optional variable. When not used the target variable data type is used to determine how many bytes must be read.  
  
The User Signature Data area can be written by the UPDI. See also the $USER directive.

See also

[READSIG](readsig.md) , $USER

Example

---

## REDO

Action

The REDO statement will restart code inside a loop.

Syntax

REDO

Remarks

REDO must be used inside a DO-LOOP, WHILE-WEND or FOR-NEXT loop.

The code jump is always inside the current loop.

Some times you want to repeat some code inside a loop. You can solve this with a GOTO and a label but use of GOTO creates hard to understand code.

```vb
DO-LOOP  
DO

```
REDO_WILL_JUMP_TO_THIS_POINT

some code here

some code here

```vb
LOOP

WHILE-WEND

WHILE <CONDIITON>

```
REDO_WILL_JUMP_TO_THIS_POINT

some code here

some code here

```vb
WEND

FOR-NEXT

FOR VAR=START TO END

```
REDO_WILL_JUMP_TO_THIS_POINT

some code here

some code here

NEXT

See also

[EXIT](exit.md) , [CONTINUE](continue.md)

Example

```vb
'-------------------------------------------------------------------------------------------------------------  
' REDO and CONTINUE example  
'  
'-------------------------------------------------------------------------------------------------------------  
$regfile = "m128def.dat"  
$hwstack = 32  
$swstack = 16  
$FrameSize = 24  
  
  
dim b as byte  
```
const test = 0  
  

```vb
#if test = 0  
for b = 1 to 10  
'when REDO is used, the code will continue here  
print b  
if b = 3 then  
```
continue ' when b becomes 3, the code will continue at the NEXT statement  
```vb
end if  
if b = 9 then exit for  
if b = 8 then  
```
redo ' when b becomes 8, the code will continue after the FOR statement, it will not increase the variable B !  
```vb
'so in this example the loop will be forever  
end if  
print b  
'code continues here when CONTINUE is used  
next  
  

#elseif test = 1  
```
b = 0  
do  
incr b  
if b = 2 then  
continue  
elseif b = 3 then  
redo  
```vb
end if  
loop until b > 5  
  

#elseif test = 2  
```
b = 0  
while b < 5  
incr b  
if b = 2 then  
continue  
elseif b = 3 then  
redo  
```vb
end if  
wend  

#endif  
end

```

---

## Registration

The software must be registered in order to get updates. This is explained in the [Updates](updates.md) topic.

We want to emphasize that it is important that you register soon as possible, at least within 1 year after purchase.

When you do not register timely, the license will not be approved. This means that you can no longer update the software.

Of course the software keeps working as is. It does not depend on the registration. But when you need support, we check if you use an actual version.

---

## REM

Action

Instruct the compiler that comment will follow.

Syntax

REM or '

Remarks

You can and should comment your program for clarity and your later sanity.

You can use REM or ' followed by your comment.

All statements after REM or ' are treated as comments so you cannot use statements on the same line after a REM statement.

Block comments can be used too:

```vb
'( start block comment

print "This will not be compiled

') end block comment

```
Example

Rem TEST.BAS version 1.00

Print A ' " this is comment : PRINT " Hello "

^ - - - This Will Not Be Executed!

---

## REPLACECHARS

Action

Replace all occurrences of a character in a string by a different character.

Syntax

REPLACECHARS  string , old,new

Remarks

string | A string variable.  
---|---  
old | A character or byte with the ASCII value of the character to search for.  
new | A character of byte with the ASCII value with the new value.  
  
When we have a string with a content of : "abcdefabc" and we want to replace the "a" by an "A" we can use :

Replacechars string , "a" , "A" 

All occurrences are replaced. 

REPLACECHARS supports [$BIGSTRINGS](bigstrings.md)

See also

[INSTR](instr.md) , [MID](mid.md) , [CHARPOS](charpos.md) , [DELCHAR](delchar.md) , [INSERTCHAR](insertchar.md) , [DELCHARS](delchars.md)

Example

```vb
$regfile = "m644def.DAT"  
$hwstack = 24 'default use 32 for the hw stack  
$swstack = 24 ' default use 10 for the SW stack  
$framesize = 24 ' default use 40 for the frame  
  
Dim Textout As String * 22  
Dim Var As String * 1  
  
```
Textout = "abcdefabdef"  
Replacechars Textout , "a" , "A"  
Print Textout  
  
Var = "e"  
Replacechars Textout , Var , "A"  
```vb
Print Textout  
  
End

```

---

## Reserved Words

See [Keyword Reference ](functionalreference.md)

Additional, there are also these reserved words :

LBYTE , HBYTE, TYPE

---

## RESET

Action

Reset a bit to zero.

Syntax

```vb
RESET bit

RESET var.x

RESET var

RESET micro

RESET watchdog

```
Remarks

Bit | Bit or Boolean variable.  
---|---  
Var | A byte, integer, word, long or dword variable.  
X | Bit of variable to clear. Valid values are : 0-7 (byte, registers), 0-15 (Integer/Word) and (0-31) for a Long/Dword  
watchdog | This will reset the Watchdog timer.   
micro | This will reset the processor. Depending on the AVR platform different methods will be used:  
\- XTINY/MEGAX/AVR : Reset controller is used \- XMEGA : Reset controller is used \- AVR : a jump to address 0 is used. This will not reset hardware registers and is not a real reset.  
  
You can also use the constants from the definition file to set or reset a bit.

RESET PORTB.PB7 'will reset pin 7 of portB. This because PB7 is a defined constant in the definition file.

When the bit is not specified, bit 0 will be cleared. 

See also

[SET](set.md) , [TOGGLE](toggle.md)

Example

[SEE SET](set.md)

---

## RESTORE

Action

Allows READ to reread values in specified DATA statements by setting data pointer to beginning of data statement.

Syntax

RESTORE label

Remarks

label | The label of a DATA statement.  
---|---  
  
See also

[DATA](data_2.md) , [READ](read.md) , [LOOKUP](lookup.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : readdata.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : READ,RESTORE

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Integer , B1 As Byte , Count As Byte

Dim S As String * 15

Dim L As Long

```
Restore Dta1 'point to stored data

For Count = 1 To 3 'for number of data items

Read B1 : Print Count ; " " ; B1

Next

Restore Dta2 'point to stored data

For Count = 1 To 2 'for number of data items

Read A : Print Count ; " " ; A

Next

Restore Dta3

Read S : Print S

Read S : Print S

Restore Dta4

Read L : Print L 'long type

```vb
'demonstration of readlabel

Dim W As Iram Word At 8 Overlay ' location is used by restore pointer

'note that W does not use any RAM it is an overlayed pointer to the data pointer

```
W = Loadlabel(dta1) ' loadlabel expects the labelname

Read B1

```vb
Print B1

End

```
Dta1:

Data &B10 , &HFF , 10

Dta2:

Data 1000% , -1%

Dta3:

Data "Hello" , "World"

```vb
'Note that integer values (>255 or <0) must end with the %-sign

'also note that the data type must match the variable type that is

'used for the READ statement

```
Dta4:

Data 123456789&

```vb
'Note that LONG values must end with the &-sign

'Also note that the data type must match the variable type that is used

'for the READ statement

```

---

## RestoreContext

Action

Restore the current graphics context from the context stack.

Syntax

RestoreContext

Remarks

Restores the current graphics context. Four (4) levels of SAVE and RESTORE are available in the FT800.

Any extra RestoreContext will load the default values into the present context.

See also

[SaveContext](savecontext.md)

Example

```vb
' Pseudocode

' Saving and restoring context means that the second 'G' is drawn in red, instead of blue

```
Begin_G BITMAPS

ColorRGB 255, 0, 0 

SaveContext

ColorRGB 50, 100, 255 

Vertex2II 80, 38, 31, &H47

RestoreContext

Vertex2II 110, 38, 31,&H47

![clip0086](clip0086.png)

---

## RETURN

Action

Return from a subroutine.

Syntax

RETURN

Remarks

Subroutines must be ended with a related RETURN statement.

Interrupt subroutines must also be terminated with the Return statement.

See also

[GOSUB](gosub.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : gosub.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: GOTO, GOSUB and RETURN

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Goto Continue

Print "This code will not be executed"

```
Continue: 'end a label with a colon

```vb
Print "We will start execution here"

Gosub Routine

Print "Back from Routine"

End

```
Routine: 'start a subroutine

```vb
Print "This will be executed"

Return 'return from subroutine

```

---

## Return_C

Action

Return from a previous [Call_C](call_c.md) command.

Syntax

Return_C

Remarks

[Call_C](call_c.md) and Return_C have 4 levels of stack in addition to the current pointer. Any additional [Call_C/](call_c.md)Return_C done wil

lead to unexpected behavior.

See also

[CALL_C](call_c.md) , [JUMP](jump.md), [MACRO_R](macro_r.md) , [DISPLAY_E](display_e.md)

---

## RGB8TO16

Action

This function converts an RGB8 byte value into an RGB16 word value.

Syntax

var = RGB8TO16(bOld)

Remarks

var | The word value that is assigned with the RGB16 value of bOld.  
---|---  
bOld | The byte that contains the RGB8 value.  
  
There are many different graphical LCD displays and most new displays can display in color. There are 8 bit and 16 bit displays. And beside the data bus width displays have different color resolution.

While high resolution is nice, it also means you need more data to display a pixel. The RGB8TO16() function converts an 8 bit RGB value into a 16 bit RGB value. This way you can use the bascom created BGC files. 

See also

NONE

Example

NONE

---

## RIGHT

Action

Return a specified number of rightmost characters in a string.

Syntax

var = RIGHT(var1 ,n )

Remarks

var | The string that is assigned.  
---|---  
Var1 | The source string.  
st | The number of bytes to copy from the right of the string.  
  
RIGHT supports [$BIGSTRINGS](bigstrings.md)

See also

[LEFT](left.md) , [MID](mid.md)

Example

Dim S As String * 15 , Z As String * 15

S ="ABCDEFG"

Z = Left(s , 5)

Print Z 'ABCDE

Z = Right(s , 3) : Print Z

Z = Mid(s , 2 , 3) : Print Z

End

---

## RMDIR

Action

This statement removes the specified directory.

Syntax

RMDIR directory

Remarks

RMDIR (ReMove DIRectory) removes the specified directory or folder.

The folder must exist. You may not use a path.

While KILL is used to remove files, RMDIR is used to remove directories. 

You should remove all files before you remove the directory.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILELEN](filelen.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [WRITE](write.md) , [INPUT](input.md) , [DIR](dir.md), [MKDIR](mkdir.md), [CHDIR](chdir.md) , [NAME](name.md)

Example

RMDIR "abc"

---

## RND

Action

Returns a random number.

Syntax

var = RND( limit )

Remarks

Limit | Word that limits the returned random number.  
---|---  
Var | The variable that is assigned with the random number.  
  
The RND() function returns an Integer/Word and needs an internal storage of 2 bytes. (___RSEED). Each new call to Rnd() will give a new positive random number.

![notice](notice.jpg) Notice that it is a software based generated number. And each time you will restart your program the same sequence will be created.

You can use a different SEED value by dimensioning and assigning ___RSEED yourself:

```vb
Dim ___rseed as word : ___rseed = 10234

Dim I as word : I = rnd(10)

```
When your application uses a timer you can assign ___RSEED with the timer value. This will give a better random number.

See also

[CONFIG RND](config_rnd.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : rnd.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : RND() function

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim I As Word ' dim variable

Do

```
I = Rnd(40) 'get random number (0-39)

```vb
Print I 'print the value

Wait 1 'wait 1 second

Loop 'for ever

End

```

---

## ROTATE

Action

Rotate all bits one place to the left or right.

Syntax

ROTATE var , LEFT/RIGHT[ , shifts]

Remarks

Var | Byte, Integer/Word or Long variable.  
---|---  
Shifts | The number of shifts to perform.  
  
The ROTATE statement rotates all the bits in the variable to the left or right. All bits are preserved so no bits will be shifted out of the variable.

This means that after rotating a byte variable with a value of 1, eight times the variable will be unchanged.

When you want to shift out the MS bit or LS bit, use the SHIFT statement.

See also

[SHIFT](shift.md) , [SHIFTIN](shiftin.md) , [SHIFTOUT](shiftout.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : rotate.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : example for ROTATE and SHIFT statement

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'dimension some variables

Dim B As Byte , I As Integer , L As Long

'the shift statement shift all the bits in a variable one

'place to the left or right

'An optional paramater can be provided for the number of shifts.

'When shifting out then number 128 in a byte, the result will be 0

'because the MS bit is shifted out

```
B = 1

Shift B , Left

```vb
Print B

'B should be 2 now

```
B = 128

Shift B , Left

```vb
Print B

'B should be 0 now

'The ROTATE statement preserves all the bits

'so for a byte when set to 128, after a ROTATE, LEFT , the value will

'be 1

'Now lets make a nice walking light

'First we use PORTB as an output

Config Portb = Output

'Assign value to portb

```
Portb = 1

```vb
Do

For I = 1 To 8

```
Rotate Portb , Left

```vb
'wait for 1 second

Wait 1

Next

'and rotate the bit back to the right

For I = 1 To 8

```
Rotate Portb , Right

```vb
Wait 1

Next

Loop

End

```

---

## ROUND

Action

Returns a value rounded to the nearest value.

Syntax

var = ROUND( x )

Remarks

Var | A single or double variable that is assigned with the ROUND of variable x.  
---|---  
X | The single or double to get the ROUND of.  
  
Round(2.3) = 2 , Round(2.8) = 3

Round(-2.3) = -2 , Round(-2.8) = -3

See Also

[INT](int.md) , [FIX](fix.md) , [SGN](sgn.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : round_fix_int.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : ROUND,FIX

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As Single , Z As Single

For S = -10 To 10 Step 0.5

Print S ; Spc(3) ; Round(s) ; Spc(3) ; Fix(s) ; Spc(3) ; Int(s)

Next

End

```

---

## RTRIM

Action

Returns a copy of a string with trailing blanks removed

Syntax

var = RTRIM( org )

Remarks

var | String that is assigned with the result.  
---|---  
org | The string to remove the trailing spaces from  
  
RTRIM supports [$BIGSTRINGS](bigstrings.md)

See also

[TRIM](trim.md) , [LTRIM](ltrim.md)

ASM

NONE

Example

Dim S As String * 6

S =" AB "

```vb
Print Ltrim(s)

Print Rtrim(s)

Print Trim(s)

End

```

---

## Running BASCOM-AVR

After you have installed BASCOM, you will find a program entry under MCS Electronics\BASCOM-AVR

Double-click the BASCOM-AVR icon ![bascom-icon](bascom-icon.png) to run BASCOM.

The following window will appear. (If this is your first run, the edit window will be empty.)

![bascomide](bascomide.png)

The most-recently opened file will be loaded automatically. Like most Windows programs, there is a menu and a toolbar. The toolbar can be customized. To do this, place the mouse cursor right beside the 'Help' menu.

Then right-click. You can turn on/off the toolbars or you can choose 'Customize'.

This will show the following window:

![toolbar_cust](toolbar_cust.png)

You have the option to create new Toolbars or the reset the toolbars to the default.

To place a new button on a menu bar, select the 'Commands' TAB.

![toolbar_commands](toolbar_commands.png)

In the example above, the Program Category has been selected and at the right pane, all buttons that belong to the Program-category are shown.

You can now select a button and drag & drop it to the Toolbar. To remove a button from the Toolbar, you drag it out of the Toolbar and release the left mouse button.

On the Options-TAB you can further customize the Toolbar:

![setup_options](setup_options.png)

To preserve screen space there are no large icons available.

Option | Description  
---|---  
Menus show recent used commands first | With this option the IDE will learn the menu options you use. It will show only the most used menu options. The idea is that you can find your option quicker this way.  
Show full menus after a short delay | This option will show the remaining menu options after short delay so you do not need to click another menu option to show all menu options.  
Reset my usage data | This option will reset the data the IDE has collected about your menu choices.  
Show Tool tips on toolbars | This option is on by default and it will show a tool tip when you hold the mouse cursor above a toolbar button  
Show shortcut keys in Tool tips | This option is on by default and it will show the shortcut in the tool tip. For example CTRL+C for the Copy button.  
  
The Editor

The editor supports syntax highlighting. Code you enter can be reformatted automatically.

When you press CTRL+J you can select a template. A template is a small piece of code that can be inserted automatically.

When you press CTRL+J you can select a template or you can type the template name and press CTRL+J. If there is only one template starting with that name, the template will be inserted. Otherwise the options are shown.

![editor_templates](editor_templates.png)

Templates are stored in the file bascavr.tpl

When you press SHIFT and move the mouse cursor over a variable, constant or other element you will get a tool tip with info.

![editor_tooltip](editor_tooltip.png)

In the sample above the variable 's' was selected and the tool tip shows that it is a string with a length of 16 bytes in the modules crc8-16-32.bas

Intellisense

The editor has built in intellisense. 

It is important that your code contains the $REGFILE directive like : $REGFILE = "M88def.dat". 

When you press CTRL+SPACE you get a list of statements, sub routines, functions, labels, asm registers, etc. This list depends on the place of the cursor in the code.

\- At the start of a line you will get a list like : ![intel_sol](intel_sol.png). You can select a value from the list and press enter to insert it into the code.

\- When you type a letter of some letters like pr ![intel_pr](intel_pr.png) Here you can see the position is set to the first item that starts with PR : PRINT

\- After PRINT when a variable is expected : ![intel_var](intel_var.png) Here you get functions, variables and constants

\- After CONFIG ![intel_config](intel_config.png) Here you get a list of all CONFIG statements. 

\- After CONFIG param (the = sign). ![intel_configParam](intel_configparam.png) Here you get a lost of parameter values.

\- After GOTO, GOSUB ![intel_gotogosub](intel_gotogosub.png) Here you get a list with labels.

\- After CALL ![intel_call](intel_call.png) Here you get a lost with sub routines.

\- Inside $ASM-$END ASM ![intel_asm](intel_asm.png) Here you get a list of ASM mnemonics. 

\- After ASM mnemonic ![intel_asm_prm](intel_asm_prm.png) Here you get a list of registers.

PLEASE NOTICE : 

\- intellisense is considered a beta function. It is subject to change. It will only work when there are no syntax errors.

\- values for CONFIG might not be shown. This is because all these values need to be present in the DAT files. And each processor has specific options. 

Select Text

Selection of text can be done by double clicking the text, by holding SHIFT down and moving the cursor or you can select a block of text by pressing the ALT key and dragging the mouse cursor.

![edit_select_textblock](edit_select_textblock.png)

TABS

When you have loaded multiple files, each file will be shown in a TAB. The active TAB can be closed or dragged to a new position. When a file is modified the TAB caption will be shown in red.

![editor_tabs](editor_tabs.png)

SHIFT + MOUSE

When you move the mouse cursor to the TAB caption you will see the full path of the loaded file.

When you press the SHIFT key and move the mouse cursor you can get information in a tool tip.

For example when you hover over an indention line :

![edit_indention_mouse](edit_indention_mouse.png)

The tooltip shows info about the structure. So you know that the green line belongs to While Unseen > 0

When we hover over a code element like CH :

![edit_intelli_dim](edit_intelli_dim.png)

This time since CH is a variable. the data type is shown.

In 2084 String constants will be shown with their length. 

The Reference window will list all referenced variables :

![edit_reference_window](edit_reference_window.png)

When you click an item, the cursor will be changed automatically.

Custom Configuration

You can load a custom configuration file by specifying the filename as a parameter.

This allows you to run different versions of the software with different setting/option files.

The configuration file has the XML extension. It can be found by clicking the XML data folder link in the Help, About window.

By default bascom uses the file : \Users\<USER>\AppData\Roaming\MCS Electronics\bascom-avrXXXX.xml

The XXXX is the version. For example 2082. 

When you want to use a custom file we would recommend to store it in the bascom-avr application folder. This way you can run multiple versions of bascom, all with their own settings.

The name of the settings file must be provided as a parameter to BasCom. For example to use a settings file named mysettings.xml :

bascavr.exe mysettings.xml

When BasCom is started it will check if the provided file exists and will load the settings of that file.

If the files does not exist, the normal setting file ise used. 

The reason for unique file names is that once in a while a menu option is added. That is no problem when you update, but when you want to use the xml with an older file you could get errors because of non existing menus.

---

## Sample Electronics cable programmer

Sample Electronics submitted the simple cable programmer.

They produce professional programmers too. This simple programmer you can make yourself within 10 minutes.

What you need is a DB25 centronics male connector, a flat cable and a connector that can be connected to the target MCU board.

The connections to make are as following:

DB25 pin | Target MCU pin(AT90S8535) | Target MCU M103/M128 | Target MCU pin 8515 | DT104  
---|---|---|---|---  
2, D0 | MOSI, pin 6 | PE.0, 2 | MOSI, 6 | J5, pin 4  
4, D2 | RESET, pin 9 | RESET, 20 | RESET, 9 | J5, pin 8  
5, D3 | CLOCK, pin 8 | PB.1,11 | CLOCK, 8 | J5, pin 6  
11, BUSY | MISO, pin 7 | PE.1, 3 | MISO, 7 | J5, pin 5  
18-25,GND | GROUND | GROUND | GND,20 | J5, pin 1  
  
The MCU pin numbers are shown for an 8535! And 8515

Note that 18-25 means pins 18,19,20,21,22,23,24 and 25

You can use a small resistor of 100-220 ohm in series with the D0, D2 and D3 line in order not to short circuit your LPT port in the event the MCU pins are high.

It was tested without these resistors and no problems occurred.

![notice](notice.jpg) Tip : when testing programmers etc. on the LPT it is best to buy an I/O card for your PC that has a LPT port. This way you donât destroy your LPT port that is on the motherboard in the event you make a mistake!

The following picture shows the connections to make. Both a setup for the DT104 and stand-alone PCB are shown.

![BASC0084](basc0084.gif)

I received the following useful information:

I have been having spurious success with the simple cable programmer from Sample Electronics for the AVR series.

After resorting to hooking up the CRO I have figured it out (I think). When trying to identify the chip, no response on the MISO pin indicates that the Programming Enable command has not been correctly received by the target.

The SCK line Mark/Space times were okay but it looked a bit sad with a slow rise time but a rapid fall time. So I initially tried to improve the rise

time with a pull-up. No change ie still could not identify chip. I was about to add some buffers when I came across an Atmel app note for their serial programmer "During this first phase of the programming cycle, keeping the SCK line free from pulses is critical, as pulses will cause the target AVR to loose synchronization with the programmer. When synchronization is lost, the only means of regaining synchronization is to release the RESET line for more than 100ms."

I have added a 100pF cap from SCK to GND and works first time every time now. The SCK rise time is still sad but there must have been enough noise to corrupt the initial command despite using a 600mm shielded cable.

---

## SaveContext

Action

Push the current graphics context on the context stack.

Syntax

SaveContext

Remarks

Saves the current graphics context Any extra SaveContext will throw away the earliest saved context.

See also

[RestoreContext](restorecontext.md)

Example

```vb
' Pseudocode

' Saving and restoring context means that the second 'G' is drawn in red, instead of blue

```
Begin_G BITMAPS

ColorRGB 255, 0, 0 

SaveContext

ColorRGB 50, 100, 255

Vertex2II 80, 38, 31, &H47

RestoreContext

Vertex2II 110, 38, 31, &H47

![clip0083](clip0083.png)

---

## ScissorSize

Action

Specify the size of the scissor clip rectangle.

Syntax

ScissorSize width, height

Remarks

width | The width of the scissor clip rectangle, in pixels. The initial value is 512. The valid value range is from 0 to 512.  
---|---  
height | The height of the scissor clip rectangle, in pixels. The initial value is 512. The valid value range is from 0 to 512  
  
Sets the width and height of the scissor clip rectangle, which limits the drawing area.

See Also

[SCISSORXY](scissorxy.md)

Example

```vb
' Pseudocode

' Setting a 40 x 30 scissor rectangle clips the clear and bitmap drawing

```
ScissorXY 40, 30

ScissorSize 80, 60

ClearColorRGB 0, 0, 255

Clear_B 1, 1, 1

Begin_G BITMAPS

Vertex2II 35, 20, 31, &H47

![clip0084](clip0084.png)

---

## ScissorXY

Action

Specify the size of the scissor clip rectangle.

Syntax

ScissorXY x, y

Remarks

x | The x coordinate of the scissor clip rectangle, in pixels. The initial value is 0  
---|---  
y | The y coordinate of the scissor clip rectangle, in pixels. The initial value is 0  
  
Sets the top-left position of the scissor clip rectangle, which limits the drawing area.

See Also

[SCISSORSIZE](scissorsize.md)

Example

```vb
' Pseudocode

' Setting a 40 x 30 scissor rectangle clips the clear and bitmap drawing

```
ScissorXY 40, 30

ScissorSize 80, 60

ClearColorRGB 0, 0, 255

Clear_B 1, 1, 1

Begin_G BITMAPS

Vertex2II 35, 20, 31, &H47

![clip0084](clip0084.png)

---

## SECELAPSED

Action

Returns the elapsed Seconds to a former assigned time-stamp.

Syntax

Target = SECELAPSED(TimeStamp)

Remarks

Target | A variable (LONG), that is assigned with the elapsed Seconds  
---|---  
TimeStamp | A variable (LONG), which holds a timestamp like the output of an earlier called SecOfDay()  
  
The Function works with the SOFTCLOCK variables _sec, _min and _hour and considers a jump over midnight and gives a correct result within 24 hour between two events.

The Return-Value is in the range of 0 to 86399.

See also

[Date and Time Routines](datetime.md) , [SecOfDay](secofday.md) , [SysSecElapsed](syssecelapsed.md)

Partial Example

Lsecofday = Secofday()

_hour = _hour + 1

Lvar1 = Secelapsed(lsecofday)

Print Lvar1

---

## SECOFDAY

Action

Returns the Seconds of a Day.

Syntax

Target = SECOFDAY()

Target = SECOFDAY(bSecMinHour)

Target = SECOFDAY(strTime)

Target = SECOFDAY(lSysSec)

Remarks

Target | A variable (LONG), that is assigned with the Seconds of the Day  
---|---  
bSecMinHour | A Byte, which holds the Second-value followed by Minute(Byte) and Hour(Byte)  
strTime | A String, which holds the time in the format âhh:mm:ss"  
LSysSec | A Variable (Long) which holds the System Second  
  
The Function can be used with 4 different kind of inputs:

1.| Without any parameter. The internal Time of SOFTCLOCK (_sec, _min, _hour) is used.  
---|---  
  
2.| With a user defined time array. It must be arranged in same way (Second, Minute, Hour) as the internal SOFTCLOCK time. The first Byte (Second) is the input by this kind of usage. So the Second of Day can be calculated of every time.  
---|---  
  
3.| With a time-String. The time-string must be in the Format âhh:mm:ss".  
---|---  
  
4.| With a System Second Number (LONG)  
---|---  
  
The Return-Value is in the range of 0 to 86399 from 00:00:00 to 23:59:59.

No validity-check of input is made.

See also

[Date and Time Routines](datetime.md) , [SysSec](syssec.md)

Partial Example

```vb
' ================= Second of Day =============================================

' Example 1 with internal RTC-Clock

```
_sec = 12 : _min = 30 : _hour = 18 ' Load RTC-Clock for example - testing

Lsecofday = Secofday()

```vb
Print "Second of Day of " ; Time$ ; " is " ; Lsecofday

' Example 2 with defined Clock - Bytes (Second / Minute / Hour)

```
Bsec = 20 : Bmin = 1 : Bhour = 7

Lsecofday = Secofday(bsec)

```vb
Print "Second of Day of Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " (" ; Time(bsec) ; ") is " ; Lsecofday

' Example 3 with System Second

```
Lsyssec = 1234456789

Lsecofday = Secofday(lsyssec)

```vb
Print "Second of Day of System Second " ; Lsyssec ; "(" ; Time(lsyssec) ; ") is " ; Lsecofday

' Example 4 with Time - String

```
Strtime = "04:58:37"

Lsecofday = Secofday(strtime)

Print "Second of Day of " ; Strtime ; " is " ; Lsecofday

---

## SEEK

Action

Function: Returns the position of the next Byte to be read or written

Statement: Sets the position of the next Byte to be read or written

Syntax

Function: NextReadWrite = SEEK (#bFileNumber)

Statement: SEEk #bFileNumber, NewPos

Remarks

bFileNumber | A byte holding the File number, which identifies a previous opened file  
---|---  
NextReadWrite | A Long Variable, which is assigned with the Position of the next Byte to be read or written (1-based). In case of an error, 0 is returned.  
NewPos | A Long variable that holds the new position the file pointer must be set to.  
  
This function returns the position of the next Byte to be read or written. 

Check DOS-Error in variable gbDOSError in case of an error, when the function returns a zero.

SEEK only works on files opened in BINARY mode. The SEEK() function returns 1 for an opened file since this is the start of the file. Once you write data to the file, SEEK() will return the updated location.

The statement also returns an error in the gbDOSerror variable in the event that an error occurs.

You can for example not set the file position behind the file.

In VB the file is filled with 0 bytes when you set the file pointer behind the size of the file. For embedded systems this does not seem a good idea.

Seek and Loc seems to do the same function, but take care : the seek function will return the position of the next read/write, while the Loc function returns the position of the last read/write. You may say that Seek = Loc+1.

![notice](notice.jpg) In QB/VB you can use seek to make the file bigger. When a file is 100 bytes long, setting the file pointer to 200 will increase the file with 0 bytes. By design this is not the case in AVR-DOS.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Function Calls | _FileSeek |   
---|---|---  
Input | r24: filenumber | X: Pointer to Long-variable, which gets the result  
Output | r25: Errorcode | C-Flag: Set on Error  
  
Statement Calls | _FileSeekSet |   
---|---|---  
Input | r24: filenumber | X: Pointer to Long-variable with the position  
Output | r25: Errorcode | C-Flag: Set on Error  
  
Partial Example

Open "test.biN"for Binary As #2

Put#2 , B ' write a byte

Put#2 , W ' write a word

Put#2 , L ' write a long

Ltemp = Loc(#2) + 1 ' get the position of the next byte

```vb
Print Ltemp ; " LOC" ' store the location of the file pointer

Print Seek(#2) ; " = LOC+1"

```
Close #2

'now open the file again and write only the single

Open "test.bin" For Binary As #2

Seek#2 , Ltemp ' set the filepointer

Sn = 1.23 ' change the single value so we can check it better

Put #2 , Sn,1 ' specify the file position

Close #2

Example2

```vb
'------------------------------------------------------------------------------  
' simulate-AVR-DOS.bas  
' simulate AVR-DOS using virtual XRAM drive  
'  
'------------------------------------------------------------------------------  
$regfile = "M128def.dat"  
$crystal = 16000000  
' Adjust HW Stack, Soft-Stack and Frame size to 128 minimum each!!!  
$hwstack = 128 : $swstack = 128 : $framesize = 128  
$xramsize = &H10000 'specify 64KB of XRAM for the file system  
$sim 'for simulation only !  
$baud = 19200  
  
Config Clock = Soft  
Enable Interrupts  
Config Date = Mdy , Separator = Dot  
  
Dim Btemp1 As Byte , Battr1 As Byte , Battr2 As Byte  
$include "Config_XRAMDrive.bas" ' Does drive init too  
$include "Config_AVR-DOS.BAS"  
  
Print "Wait for Drive"  
If Gbdriveerror = 0 Then  
Print "Init File System ... ";  
```
Btemp1 = Initfilesystem(1) ' Partition 1  
```vb
' use 0 for drive without Master boot record  
If Btemp1 <> 0 Then  
Print "Error: " ; Btemp1 ; " at Init file system"  
Else  
Print " OK"  
Print "Filesystem: " ; Gbfilesystem  
Print "FAT Start Sector: " ; Glfatfirstsector  
Print "Root Start Sector: " ; Glrootfirstsector  
Print "Data First Sector: " ; Gldatafirstsector  
Print "Max. Cluster Nummber: " ; Glmaxclusternumber  
Print "Sectors per Cluster: " ; Gbsectorspercluster  
Print "Root Entries: " ; Gwrootentries  
Print "Sectors per FAT: " ; Glsectorsperfat  
Print "Number of FATs: " ; Gbnumberoffats  
End If  
Else  
Print "Error during Drive Init: " ; Gbdriveerror  
End If  
  
Dim Lpos As Long  
```
Open "test.bin" For Binary As #11  
Print Seek(#11) ' 1  
Put #11 , Btemp1  
Print Seek(#11) ' 2  
Lpos = Lof(#11) + 1 ' 1+1=2  
Seek #11 , Lpos  
Put #11 , Btemp1  
Print Seek(#11) '3  
Close #11  
  
End

---

## SELECT-CASE-END SELECT

Action

Executes one of several statement blocks depending on the value of an expression.

Syntax

```vb
SELECT CASE var

CASE test1 : statements

```
[CASE test2 : statements ]

```vb
CASE ELSE : statements

END SELECT

```
Remarks

Var | Variable to test the value of  
---|---  
Test1 | Value to test for.  
Test2 | Value to test for.  
  
You can test for conditions to like:

CASE IS > 2 :

Another option is to test for a range :

CASE 2 TO 5 :

See also

[IF THEN](if_then_else_end_if.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : case.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates SELECT CASE statement

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim I As Byte 'dim variable

Dim S As String * 5 , Z As String * 5

Do

Input "Enter value (0-255) " , I

Select Case I

Case 1 : Print "1"

Case 2 : Print "2"

Case 3 To 5 : Print "3-5"

Case Is >= 10 : Print ">= 10"

Case Else : Print "Not in Case statement"

End Select

Loop

End

'note that a Boolean expression like > 3 must be preceded

'by the IS keyword

```

---

## SERIN

Action

Reads serial data from a dynamic software UART.

Syntax

SERIN var , bts , port , pin, baud , parity , dbits , sbits

Remarks

While the OPEN and CLOSE statements can be used for software UARTS, they do not permit to use the same pin for input and output. The settings used when opened the communication channel can also not be changed at run time.

The SERIN and SEROUT statements are dynamic software UART routines to perform input and output. You can use them on the same pin for example send some data with SEROUT and get back an answer using SERIN.

Since the SERIN and SEROUT routines can use any pin and can use different parameter values, the code size of these routines is larger.

Parameter | Description  
---|---  
Var | A variable that will be assigned with the received data.  
Bts | The number of bytes to receive. String variables will wait for a return (ASCII 13). There is no check if the variable you assign is big enough to hold the result.  
Port | The name of the port to use. For example: portA.  
Pin | The pin number you want to use of the port. This must be in the range from 0-7.  
Baud | The baud rate you want to use. For example 19200.  
Parity | A number that codes the parity. 0= NONE, 1 = EVEN, 2 = ODD  
Dbits | The number of data bits. Use 7 or 8.  
Sbits | The number of stop bits. 1 to 2.  
  
The use of SERIN will create an internal variable named ___SER_BAUD. This is a LONG variable. It is important that you specify the correct crystal value with $CRYSTAL so the correct calculation can be made for the specified baud rate.

Note that ___SER_BAUD will not hold the passed baud rate but will hold the bit delay used internal.

Since the SW UART is dynamic you can change all the parameters at run time. For example you can store the baud rate in a variable and pass this variable to the SERIN routine.

Your code could change the baud rate under user control this way.

It is important to realize that software timing is used for the bit timing. Any interrupt that occurs during SERIN or SEROUT will delay the transmission. Disable interrupts while you use SERIN or SEROUT.

ASM

The routine called is named _serin and is stored in mcs.lib

```vb
For Xmega it is located in Xmega.lib and Xtiny in Xtiny.lib

For the baud rate calculation, _calc_baud is called.

```
See also

[SEROUT](serout.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : serin_out.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstration of DYNAMIC software UART

'micro : AT90S2313

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "2313def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'tip : Also look at OPEN and CLOSE

'some variables we will use

Dim S As String * 10

Dim Mybaud As Long

'when you pass the baud rate with a variable, make sure you dimesion it as a LONG

```
Mybaud = 19200

```vb
Do

'first get some data

```
Serin S , 0 , PORTD , 0 , Mybaud , 0 , 8 , 1

'now send it

Serout S , 0 , PORTD , 1 , Mybaud , 0 , 8 , 1

```vb
' ^ 1 stop bit

' ^---- 8 data bits

' ^------ even parity (0=N, 1 = E, 2=O)

' ^-------------- baud rate

' ^-------------------- pin number

' ^----------------------- port so PORTA.0 and PORTA.1 are used

' ^--------------------------- for strings pass 0

' ^-------------------------------- variable

Wait 1

Loop

End

'because the baud rate is passed with a variable in this example, you could change it under user control

'for example check some DIP switches and change the variable mybaud

```

---

## SERIN

This is an alternative library that adds timeout support to the [SERIN](serin.md) statement. Development was sponsored by a customer.

To use this library instead of the default SERIN code, you need to add it to the configuration using the [$LIB](lib.md) directive

```vb
$lib "serin.lib"

Then you need to dimension a DWORD or LONG variable named SERIN_TIMEOUT which is used for the timeout.

```
You assign a time out value to this variable. A higher value will cause a longer time out.

The time out is not in uSec or mSec but relative to the processor speed.

Thus using a clock of 1 Mhz will have a longer time out than a processor clock of 16 MHz.

How it works : The value of SERIN_TIMEOUT is copied to 4 registers. When the software is waiting for a certain bit level, instead of looping, it will decrease the registers and when they reach 0, the code ends. This will prevent that the processor locks up when you have bad signals.

This lib is only available in the full version.

---

## SEROUT

Action

Sends serial data through a dynamic software UART.

Syntax

SEROUT var , bts , port , pin, baud , parity , dbits , sbits [,INVERTED]

Remarks

While the OPEN and CLOSE statements can be used for software UARTS, they do not permit to use the same pin for input and output. The settings used when opening the communication channel can also not be changed at run time.

The SERIN and SEROUT statements are dynamic software UART routines to perform input and output. You can use them on the same pin for example to send some data with SEROUT and get back an answer using SERIN.

Since the SERIN and SEROUT routines can use any pin and can use different parameter values, the code size of these routines is larger.

Parameter | Description  
---|---  
Var | A variable which content is send through the UART. A constant can NOT be used.  
Bts | The number of bytes to send. For strings you can specify 0. In that case the whole string will be sent.  
Port | The name of the port to use. For example : portA.  
Pin | The pin number you want to use of the port. This must be in the range from 0-7.  
Baud | The baud rate you want to use. For example 19200.  
Parity | A number that codes the parity. 0= NONE, 1 = EVEN, 2 = ODD  
Dbits | The number of data bits. Use 7 or 8.  
Sbits | The number of stop bits. 1 to 2.  
INVERTED | This is an optional parameter. When set, the signal will be inverted.   
  
The use of SEROUT will create an internal variable named ___SER_BAUD. This is a LONG variable. It is important that you specify the correct crystal value with $CRYSTAL so the correct calculation can be made for the specified baud rate.

Note that ___SER_BAUD will not hold the passed baud rate but will hold the bit delay which is used internal.

Since the SW UART is dynamic you can change all the parameters at run time. For example you can store the baud rate in a variable and pass this variable to the SEROUT routine.

Your code could change the baud rate under user control this way.

It is important to realize that software timing is used for the bit timing. Any interrupt that occurs during SERIN or SEROUT will delay the transmission. Disable interrupts while you use SERIN or SEROUT.

![notice](notice.jpg)SEROUT can be used in PORT and open collector TRI-state mode. 

PORT mode means that the defined PORT PIN will be set to output mode, and that the pin output will be switched between 0 and 1.

The disadvantage of this mode is that you can not connect multiple outputs together. (never connect 2 outputs together). 

For this reason there is also the TRI state/open collector mode.

By default TRI-state mode will be used. This mode requires an external pull up resistor on the Xmega/Xtiny. For the normal AVR this external pull up resistor is optional.

Since the port architecture differs for all platforms there are different implementations to create the bit stream in open collector mode.

The normal AVR has a pull up resistor that can be activated by writing 1 to a port. The Xmega has a special register to activate the pull up resistor. And the Xtiny has a special register as well to activate the pull up resistor. For all platforms, a zero bit is created by setting the data direction register to output mode and clear the output pin.

To create a one, the normal AVR is set to input mode and the pull up is activated by writing a one to data direction.

For the Xmega the code is similar but more code is required for the pinctrl register since each pin has its own register. The pull up mode is the wired and mode. 

In Open Collector mode you can connect several AVR chip pin and poll the âbusâ with the [SERIN](serin.md) statement.   
When you want to use the pins in PORT OUTPUT mode, the pins can not be tied together.

Define a constant named SEROUT_EXTPULL with a value of 1 for the TRI-STATE open collector mode. 

Define a constant named SEROUT_EXTPULL with a value of 0 to work in PORT mode.

When you do not define a constant the SEROUT_EXTPULL will be created automatically with a value of 1.

![notice](notice.jpg)The mode you chose is fixed and global for all SEROUT statements. You can not switch between SEROUT_EXTPULL value in your code dynamically.

ASM

The routine called is named _serout and is stored in mcs.lib. An overloaded version is placed in xmega.lib and xtiny.lib

For the baud rate calculation, _calc_baud is called.

See also

[SERIN](serin.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : serin_out.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstration of DYNAMIC software UART

'micro : AT90S2313

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "2313def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'tip : Also look at OPEN and CLOSE

'some variables we will use

Dim S As String * 10

Dim Mybaud As Long

'when you pass the baud rate with a variable, make sure you dimesion it as a LONG

```
Mybaud = 19200

```vb
Do

'first get some data

```
Serin S , 0 , PORTD , 0 , Mybaud , 0 , 8 , 1

'now send it

Serout S , 0 , PORTD , 1 , Mybaud , 0 , 8 , 1

```vb
' ^ 1 stop bit

' ^---- 8 data bits

' ^------ even parity (0=N, 1 = E, 2=O)

' ^-------------- baud rate

' ^-------------------- pin number

' ^----------------------- port so PORTA.0 and PORTA.1 are used

' ^--------------------------- for strings pass 0

' ^-------------------------------- variable

Wait 1

Loop

End

'because the baud rate is passed with a variable in this example, you could change it under user control

'for example check some DIP switches and change the variable mybaud

```

---

## SET

Action

Set a bit to the value one.

Syntax

```vb
SET bit

SET var.x

SET var

```
Remarks

Bit | Bit or Boolean variable.  
---|---  
Var | A byte, integer, word or long variable.  
X | Bit of variable to set. Valid values are : 0-7 (byte, registers), 0-15 (Integer/Word) and (0-31) for a Long  
  
When the bit is not specified, bit 0 will be set. 

Also notice that the bit range is 0-255. Using a larger value on a variable will overwrite a different variable !

When you need an array of say 128 bits you can use code like this : dim ar(32) as long

You can index these variables like : SET ar(1).127 , in this case you write only to the memory of the intended variable.

See also

[RESET](reset.md) , [TOGGLE](toggle.md)

Example

```vb
'--------------------------------------------------------------------------------

'name : boolean.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: AND, OR, XOR, NOT, BIT, SET, RESET and MOD

'suited for demo : yes

'commercial add on needed : no

'use in simulator : possible

'--------------------------------------------------------------------------------

'This very same program example can be used in the Help-files for  
' AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
  
  
$baud = 19200  
$crystal = 16000000  
$regfile = "m32def.dat"  
  
$hwstack = 40  
$swstack = 20  
$framesize = 20  
  
Dim A As Byte , B1 As Byte , C As Byte  
Dim Aa As Bit , I As Integer  
  
```
A = 5 : B1 = 3 ' assign values  
C = A And B1 ' and a with b  
Print "A And B1 = " ; C ' print it: result = 1  
  
C = A Or B1  
Print "A Or B1 = " ; C ' print it: result = 7  
  
C = A Xor B1  
Print "A Xor B1 = " ; C ' print it: result = 6  
  
A = 1  
C = Not A  
Print "c = Not A " ; C ' print it: result = 254  
C = C Mod 10  
```vb
Print "C Mod 10 = " ; C ' print it: result = 4  
  
  
If Portb.1 = 1 Then  
Print "Bit set"  
Else  
Print "Bit not set"  
End If 'result = Bit not set  
  
```
Aa = 1 'use this or ..  
```vb
Set Aa 'use the set statement  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit set (aa=1)  
  
```
Aa = 0 'now try 0  
```vb
Reset Aa 'or use reset  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit not set(aa=0)  
  
```
C = 8 'assign variable to &B0000_1000  
```vb
Set C 'use the set statement without specifying the bit  
Print C 'print it: result = 9 ; bit0 has been set  
  
```
B1 = 255 'assign variable  
```vb
Reset B1.0 'reset bit 0 of a byte variable  
Print B1 'print it: result = 254 = &B11111110  
  
```
B1 = 8 'assign variable to &B00001000  
```vb
Set B1.0 'set it  
Print B1 'print it: result = 9 = &B00001001  
End

```

---

## SETATTR

Action

Sets the file Attribute.

Syntax

SETATTR [sFile ,] bFileAttribute

Remarks

sFile | The name of the file (no wildcard) which attribute need to be set. You may also omit the name in which case the file will be used previous found by the DIR() function.  
---|---  
bFileAttribute | Numeric variable holding the attribute bits to set.  
  
This statement sets the DOS file attributes. A file can have multiple attributes.

You should not use attributes 8(Volume) and 16(Sub Directory) on a normal file. 

Return value | DOS Attribute  
---|---  
1 | Read Only  
2 | Hidden  
4 | System File  
8 | Volume Label  
16 | Sub Directory  
32 | Archive  
64,128 | reserved  
  
A file can have multiple bits set like 3 (hidden + read only). So you can combine multiple bits to set multiple bits at once.

When you specify the filename, make sure it does not have a wildcard. SETATTR does not support wildcards.

When you omit the filename, the last found file from [DIR](dir.md)() will be used for the operation.

In VB, SETATTR expect a new value for the attribute which replaces the old attribute byte.

In AVR-DOS you specify the bits to set. So old attributes are kept. 

In AVR-DOS you can also reset the individual bits using the CLEARATTR statement.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [DISKSIZE](disksize.md) , [GET](get.md) , [PUT](put.md), [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [FILELEN](filelen.md), [WRITE](write.md) , [INPUT](input.md) , [FILEATTR](fileattr.md) , [CLEARATTR](clearattr.md) , [GETATTR](getattr.md)

Example

```vb
'------------------------------------------------------------------------------  
' simulate-AVR-DOS.bas  
' simulate AVR-DOS using virtual XRAM drive  
'  
'------------------------------------------------------------------------------  
$regfile = "M128def.dat"  
$crystal = 16000000  
' Adjust HW Stack, Soft-Stack and Frame size to 128 minimum each!!!  
$hwstack=128 : $swstack=128 : $framesize=128  
$xramsize = &H10000 'specify 64KB of XRAM for the file system  
$sim 'for simulation only !  
$baud = 19200  
  
Config Clock = Soft  
Enable Interrupts  
Config Date = Mdy , Separator = dot  
  
Dim Btemp1 As Byte ,battr1 as Byte, battr2 as Byte  
$include "Config_XRAMDrive.bas" ' Does drive init too  
$include "Config_AVR-DOS.BAS"  
  
Print "Wait for Drive"  
If Gbdriveerror = 0 Then  
Print "Init File System ... ";  
```
Btemp1 = Initfilesystem(1) ' Partition 1  
```vb
' use 0 for drive without Master boot record  
If Btemp1 <> 0 Then  
Print "Error: " ; Btemp1 ; " at Init file system"  
Else  
Print " OK"  
Print "Filesystem: " ; Gbfilesystem  
Print "FAT Start Sector: " ; Glfatfirstsector  
Print "Root Start Sector: " ; Glrootfirstsector  
Print "Data First Sector: " ; Gldatafirstsector  
Print "Max. Cluster Nummber: " ; Glmaxclusternumber  
Print "Sectors per Cluster: " ; Gbsectorspercluster  
Print "Root Entries: " ; Gwrootentries  
Print "Sectors per FAT: " ; Glsectorsperfat  
Print "Number of FATs: " ; Gbnumberoffats  
End If  
Else  
Print "Error during Drive Init: " ; Gbdriveerror  
End If  
  
Dim strDummy as String * 12  
Dim Datei As String * 12 , Attribut As Byte  
```
Datei = "Test1.txt"  
  
Open Datei For Output As #11  
Print #11 , "Testzeile1"  
Close #11  
  
open "Test2.txt" For output as #11  
Print #11, "Testzeile2"  
close #11  
  
open "Test3.txt" for output as #11  
Print #11, "Testzeile3"  
close #11  
  
  
' Set readonly Bit in Test1.txt  
Attribut = &B00000001  
Setattr Datei , Attribut  
  
' Reset Archib-Bit in test1.txt  
Attribut = &B00100000  
clearattr Datei , Attribut  
  
```vb
' Check for Filename with wildcard, which is not supported  
' Set readonly Bit in Test1.txt  
```
Datei = "Test*.txt"  
Attribut = &B00000001  
Setattr Datei , Attribut  
Print gbDOSError  
  
Datei = DIR("Test*.txt")  
Attribut = &B00000001  
while Datei > ""  
SetAttr Attribut  
Datei = DIR()  
wend  
  
Datei = DIR("Test*.txt")  
Attribut = &B00100000  
While Datei > ""  
battr1=Getattr()  
clearattr Attribut  
battr2=Getattr()  
print datei ;" "; battr1;" " ; battr2  
Datei = DIR()  
```vb
wend  
  
End

```

---

## SETFONT

Action

Sets the current font which can be used on some graphical displays.

Syntax

SETFONT font

Remarks

font | The name of the font that need to be used with LCDAT statements.  
---|---  
  
Since SED-based displays do not have their own font generator, you need to define your own fonts. You can create and modify your own fonts with the FontEditor Plugin.

SETFONT will set an internal used data pointer to the location in memory where you font is stored. The name you specify is the same name you use to define the font.

You need to include the used fonts with the $include directive:

$INCLUDE "font8x8.font"

The order of the font files is not important. The location in your source is however important.

The $INCLUDE statement will include binary data and this may not be accessed by the flow of your program.

When your program flow enters into font code, unpredictable results will occur.

So it is best to place the $INCLUDE files at the end of your program behind the END statement.

You need to include the glibSED library with :

```vb
$LIB "glibsed.lbx"

While original written for the SED1521, fonts are supported on a number of displays now including color displays.

```
See also

[CONFIG GRAPHLCD](config_lcd.md) , [LCDAT](lcdat.md), [GLCDCMD](glcdcmd.md), [GLCDDATA](glcddata.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : sed1520.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates the SED1520 based graphical display support

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 7372800 ' used crystal frequency

$baud = 115200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'I used a Staver to test

'some routines to control the display are in the glcdSED.lib file

'IMPORTANT : since the SED1520 uses 2 chips, the columns are split into 2 of 60.

'This means that data after column 60 will not print correct. You need to locate the data on the second halve

'For example when you want to display a line of text that is more then 8 chars long, (8x8=64) , byte 8 will not draw correctly

'Frankly i find the KS0108 displays a much better choice.

$lib "glcdSED1520.lbx"

'First we define that we use a graphic LCD

Config Graphlcd = 120 * 64sed , Dataport = Porta , Controlport = Portd , Ce = 5 , Ce2 = 7 , Cd = 3 , Rd = 4

'The dataport is the portname that is connected to the data lines of the LCD

'The controlport is the portname which pins are used to control the lcd

'CE =CS Chip Enable/ Chip select

'CE2= Chip select / chip enable of chip 2

'CD=A0 Data direction

'RD=Read

'Dim variables (y not used)

Dim X As Byte , Y As Byte

'clear the screen

```
Cls

```vb
Wait 2

'specify the font we want to use

```
Setfont Font8x8

```vb
'You can use locate but the columns have a range from 1-132

'When you want to show somthing on the LCD, use the LDAT command

'LCDAT Y , COL, value

```
Lcdat 1 , 1 , "1231231"

Lcdat 3 , 80 , "11"

```vb
'lcdat accepts an additional param for inversing the text

'lcdat 1,1,"123" , 1 ' will inverse the text

Wait 2

```
Line(0 , 0) -(30 , 30) , 1

Wait 2

Showpic 0 , 0 , Plaatje 'show a comnpressed picture

```vb
End 'end program

'we need to include the font files

$include "font8x8.font"

'$include "font16x16.font"

```
Plaatje:

```vb
'include the picture data

$bgf "smile.bgf"

```

---

## SETREG

Action

Writes a byte value to an internal register.

Syntax

SETREG Reg , value

Remarks

Most AVR chips have 32 registers named R0-R31. Registers R16-R31 can be assigned directly. Register R0-R15 do not accept this.

In some cases you might want to write to the internal registers. While you can include some ASM code directly, you can also use the BASIC SETREG statment.

Reg | The register name : R0-R31 or a register definition.  
---|---  
Value | A constant or byte value to assign to the register.  
  
PEEK and POKE work with an address. And will return a HW register on the Xmega since Xmega has a different address map.

GetReg and SetReg will read/write registers on all AVR processors.

Internally the compiler will use R24 if you write a constant to register R0-R15 :

For example :

Setreg R0 , 1

Compiles into:

Ldi R24,$01

Mov R0, R24

Setreg R31 , 1

Compiles into:

Ldi R31,$01

![notice](notice.jpg)In version 2078, all internal registers (R0-R31) are made available as normal BYTE variables. This means that you can simply assign or read a register from basic : Rx=value.

This is more convenient than using SETREG and GETREG. 

See also

[GETREG](getreg.md) , [PEEK](peek.md) , [POKE](poke.md)

Example

Setreg R16,&HFF

---

## SGN

Action

Returns the sign of a numeric value.

Syntax

var = SGN( x )

Remarks

Var | A numeric variable that is assigned with the SGN() of variable x.  
---|---  
X | The numeric variable to get the sign of.  
  
```vb
For values < 0, -1 will be returned

For 0, 0 will be returned

For values >0, 1 will be returned

While the SGN function can return a negative value, it can only do so for integers, longs, singles and doubles.

```
When a byte, word or dword is passed, only 0 or 1 can be returned since these values do not contain a sign bit.

When a byte,word or dword is passed, the returned value is a byte.

When an integer is passed, the returned value is an integer.

When a long is passed, the returned value is a long.

When a single is passed, the returned value is a single.

When a double is passed, the returned value is a double.

See Also

[INT](int.md) , [FIX](fix.md) , [ROUND](round.md)

Example

Dim S As Single , X As Single , Y As Single

X = 2.3 : S = Sgn(x)

Print S

X = -2.3 : S = Sgn(x)

```vb
Print S

End

```

---

## SHIFT

Action

Shift all bits one place to the left or right.

Syntax

SHIFT var , LEFT/RIGHT[ , shifts] [,SIGNED]

Remarks

Var | Byte, Integer, Word, Long, Dword or Single variable.  
---|---  
Shifts | The number of shifts to perform.  
signed | An option that only works with right shifts. It will preserve the sign bit which otherwise would be cleared by the first shift.  
  
The SHIFT statement rotates all the bits in the variable to the left or right.

When shifting LEFT the most significant bit, will be shifted out of the variable. The LS bit becomes zero. Shifting a variable to the left, multiplies the variable with a value of two.

When shifting to the RIGHT, the least significant bit will be shifted out of the variable. The MS bit becomes zero. Shifting a variable to the right, divides the variable by two. Use the SIGNED parameter to preserve the sign.

A Shift performs faster than a multiplication or division.

See also

[ROTATE](rotate.md) , [SHIFTIN](shiftin.md) , [SHIFTOUT](shiftout.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : shift.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : example for SHIFTIN and SHIFTOUT statement

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim L As Long

```
Clock Alias Portb.0

Output Alias Portb.1

Sin Alias Pinb.2 'watch the PIN instead of PORT

```vb
'shiftout pinout,pinclock, var,parameter [,bits , delay]

' value for parameter :

' 0 - MSB first ,clock low

' 1 - MSB first,clock high

' 2 - LSB first,clock low

' 3 - LSB first,clock high

'The bits is a new option to indicate the number of bits to shift out

'For a byte you should specify 1-8 , for an integer 1-16 and for a long 1-32

'The delay is an optional delay is uS and when used, the bits parameter must

'be specified too!

'Now shift out 9 most significant bits of the LONG variable L

```
Shiftout Output , Clock , L , 0 , 9

```vb
'shiftin pinin,pinclock,var,parameter [,bits ,delay]

' 0 - MSB first ,clock low (4)

' 1 - MSB first,clock high (5)

' 2 - LSB first,clock low (6)

' 3 - LSB first,clock high (7)

'To use an external clock, add 4 to the parameter

'The shiftin also has a new optional parameter to specify the number of bits

'The bits is a new option to indicate the number of bits to shift out

'For a byte you should specify 1-8 , for an integer 1-16 and for a long 1-32

'The delay is an optional delay is uS and when used, the bits parameter must

'be specified too!

'Shift in 9 bits into a long

```
Shiftin Sin , Clock , L , 0 , 9

'use shift to shift the bits to the right place in the long

Shift L , Right , 23

End

---

## SHIFTCURSOR

Action

Shift the cursor of the LCD display left or right by one position.

Syntax

SHIFTCURSOR LEFT | RIGHT

See also

[SHIFTLCD](shiftlcd.md)

Partial Example

LCD "Hello"

SHIFTCURSOR LEFT

End

---

## SHIFTIN

Action

Shifts a bit stream into a variable.

Syntax

SHIFTIN pin , pclock , var , option [, bits , delay ]

Remarks

Pin | The port pin which serves as an input.PINB.2 for example  
---|---  
Pclock | The port pin which generates the clock.  
Var | The variable that is assigned. The existing value is not preserved. For example when you shiftin 3 bits, the whole byte will be replaced with the 3 bits. See CONFIG SHIFTIN for other SHIFTIN behaviour.  
Option | Option can be : 0 â MSB shifted in first when clock goes low 1 â MSB shifted in first when clock goes high 2 â LSB shifted in first when clock goes low 3 â LSB shifted in first when clock goes high Adding 4 to the parameter indicates that an external clock signal is used for the clock. In this case the clock will not be generated. So using 4 will be the same a 0 (MSB shifted in first when clock goes low) but the clock must be generated by an external signal. 4 â MSB shifted in first when clock goes high with ext. clock 5 â MSB shifted in first when clock goes low with ext. clock 6 â LSB shifted in first when clock goes high with ext. clock 7 â LSB shifted in first when clock goes low with ext. clock  
Bits | Optional number of bits to shift in. Maximum 255. The number of bits is automatic loaded depending on the used variable. For a long for example which is 4 bytes long, 32 will be loaded.   
Delay | Optional delay in uS.   
  
If you do not specify the number of bits to shift, the number of shifts will depend on the type of the variable.

When you use a byte, 8 shifts will occur and for an integer, 16 shifts will occur. For a Long and Single 32 shifts will occur.

The SHIFTIN routine can be used to interface with all kind of chips.

The PIN is normally connected with the output of chip that will send information.

The PCLOCK pin can be used to clock the bits as a master, that is the clock pulses will be generated. Or it can sample a pin that generates these pulses.

The VARIABLE is a normal BASIC variable. And may be of any type except for BIT. The data read from the chip is stored in this variable.

The OPTIONS is a constant that specifies the direction of the bits. The chip that outputs the data may send the LS bit first or the MS bit first. It also controls on which edge of the clock signal the data must be stored.

When you add 4 to the constant you tell the compiler that the clock signal is not generated but that there is an external clock signal.

The number of bits may be specified. You may omit this info. In that case the number of bits of the element data type will be used.

The DELAY normally consists of 2 NOP instructions. When the clock is too fast you can specify a delay time(in uS).

SHIFTIN with option NEW

The new option[ CONFIG SHIFTIN](config_shiftin.md)=NEW , will change the behaviour of the SHIFTIN statement.

When using this option, it will work for all SHIFTIN statements. The SHIFTIN will work more like the normal SHIFT statement. Bits are shifted from left to right or right to left.

The new SHIFTIN can preserve the value/bits when shifting in bits. 

For example when the value of a word is &B101 and you shift in 3 bits with value &B111, the resulting value will be &B101111. When you not want to preserve the value, you can add a value of 8 to the parameter. When you add a value of 16, the value will also not be preserved, but then the value will be cleared initially. You would only need this when shifting in less 8 bits then the size of the variable. 

Another important difference is that the new SHIFTIN can only SHIFTIN a maximum of 8 bytes. For quick operation, register R16-R23 are used. You may specify the number of bits to shiftin. This may be a variable too. When you shiftin a value into a Word, the number of bits is automatic loaded with 16. This is true for all numeric data types. 

Some of the code is stored in the MCS library. While this reduces code when SHIFTIN is used multiple times, it has the drawback that the code is written for 8 bytes and thus is not optimal for shifting in less bytes. 

You can choose to generate a part of the library code instead. Add a value of 32 to the parameter to do so.

Another new option is not to set the initial pin state for the clock and input pin. By default the clock pin is made an input or output, depending on the external clock option. And the clock is set to an initial state when no external clock is used.

When you want to use shiftin after a shiftout, you might not want the level to change. In this case, add 64 to the parameter.

Pin | The port pin which serves as an input.PINB.2 for example  
---|---  
Pclock | The port pin which generates the clock. An external signal can also be used for the clock. In that case, the pin is used in input mode.  
Var | The variable that is assigned. The existing value is preserved. With some additional constants which you can add to the option parameter, you can influence the behaviour : \- 8 - Do NOT preserve the value. This saves code. -16 - Do not preserve value, but clear the value before shifting in the bits  
Option | A constant which can be one of the following values : 0 â MS bit shifted in first when clock goes low 1 â MS bit shifted in first when clock goes high 2 â LS bit shifted in first when clock goes low 3 â LS bit shifted in first when clock goes high Adding 4 to the parameter indicates that an external clock signal is used for the clock. In this case the clock will not be generated. So using 4 will be the same a 0 (MSB shifted in first when clock goes low) but the clock must be generated by an external signal. 4 â MSB shifted in first when clock goes high with ext. clock 5 â MSB shifted in first when clock goes low with ext. clock 6 â LSB shifted in first when clock goes high with ext. clock 7 â LSB shifted in first when clock goes low with ext. clock Add a value of 8 to the option, so the existing variable will not be preserved. Add a value of 16 to the option to clear the variable first. Add a value of 32 to the option to generate code instead of using the lib code. Add a value of 64 to the option when you do not want the clock and input pin data direction and state want to be set. For example, when using SHIFTIN after a SHIFTOUT statement.  Example : Shiftin Pind.3 , Portd.4 , W , 2 + 32 + 16 , 3   
Bits | Optional number of bits to shift in. Maximum 64. The number of bits is automatic loaded depending on the used variable. For a long for example which is 4 bytes long, 32 will be loaded. You can use a constant or variable.  
Delay | Optional delay in uS. When not specified, 2 nops are used. The delay is intended to slow down the clock frequency.   
  
The initial state for the clock depends on the option. For option 1 and 3, it will be low. For option 0 and 2 it will be high.

Thus for example option 2 will set the clock pin high. Then the clock is brought low and the data is sampled/stored. After this the clock is made high again. This means when ready, the clock pin will be in the same state as the initial state.

See also

[SHIFTOUT](shiftout.md) , [SHIFT](shift.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : shift.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : example for SHIFTIN and SHIFTOUT statement

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim L As Long

```
clock Alias Portb.0

Output Alias Portb.1

sinp Alias Pinb.2 'watch the PIN instead of PORT

```vb
'shiftout pinout,pinclock, var,parameter [,bits , delay]

' value for parameter :

' 0 - MSB first ,clock low

' 1 - MSB first,clock high

' 2 - LSB first,clock low

' 3 - LSB first,clock high

'The bits is a new option to indicate the number of bits to shift out

'For a byte you should specify 1-8 , for an integer 1-16 and for a long 1-32

'The delay is an optional delay is uS and when used, the bits parameter must

'be specified too!

'Now shift out 9 most significant bits of the LONG variable L

```
Shiftout Output , Clock , L , 0 , 9

```vb
'shiftin pinin,pinclock,var,parameter [,bits ,delay]

' 0 - MSB first ,clock low (4)

' 1 - MSB first,clock high (5)

' 2 - LSB first,clock low (6)

' 3 - LSB first,clock high (7)

'To use an external clock, add 4 to the parameter

'The shiftin also has a new optional parameter to specify the number of bits

'The bits is a new option to indicate the number of bits to shift out

'For a byte you should specify 1-8 , for an integer 1-16 and for a long 1-32

'The delay is an optional delay is uS and when used, the bits parameter must

'be specified too!

'Shift in 9 bits into a long

```
Shiftin Sinp , Clock , L , 0 , 9

'use shift to shift the bits to the right place in the long

Shift L , Right , 23

End

---

## SHIFTOUT

Action

Shifts a bit stream out of a variable into a port pin .

Syntax

SHIFTOUT pin , pclock , var , option [, bits , delay ]

Remarks

Pin | The port pin which serves as a data output.  
---|---  
Pclock | The port pin which generates the clock.  
Var | The variable that is shifted out.  
Option | Option can be : 0 â MSB shifted out first when clock goes low 1 â MSB shifted out first when clock goes high 2 â LSB shifted out first when clock goes low 3 â LSB shifted out first when clock goes high  
Bits | Optional number of bits to shift out.  
Delay | Optional delay in uS. When you specify the delay, the number of bits must also be specified. When the default must be used you can also use NULL for the number of bits.  
  
If you do not specify the number of bits to shift, the number of shifts will depend on the type of the variable.

When you use a byte, 8 shifts will occur and for an integer, 16 shifts will occur. For a Long and Single 32 shifts will occur.

The SHIFTIN routine can be used to interface with all kind of chips.

The PIN is normally connected with the input of a chip that will receive information.

The PCLOCK pin is used to clock the bits out of the chip.

The VARIABLE is a normal BASIC variable. And may be of any type except for BIT. The data that is stored in the variable is sent with PIN.

The OPTIONS is a constant that specifies the direction of the bits. The chip that reads the data may want the LS bit first or the MS bit first. It also controls on which edge of the clock signal the data is sent to PIN.

The number of bits may be specified. You may omit this info. In that case the number of bits of the element data type will be used.

The DELAY normally consists of 2 NOP instructions. When the clock is too fast you can specify a delay time(in uS).

![notice](notice.jpg)The clock pin is brought to a initial level before the shifts take place. For mode 0, it is made 1. This way, the first clock can go from 1 to 0. And back to 1. You could see this as another clock cycle. So check if you use the proper mode. Or put the clock pin in the right state before you use SHIFT.

See also

[SHIFTIN](shiftin.md) , [SHIFT](shift.md)

Example

See [SHIFTIN](shiftin.md) sample

---

## SHOWPIC

Action

Shows a BGF file on the graphic display

Syntax

SHOWPIC x, y , label

Remarks

Showpic can display a converted BMP file. The BMP must be converted into a BGF file with the [Tools Graphic Converter](tools_graphic_converter.md).

The X and Y parameters specify where the picture must be displayed. X and Y must be 0 or a multiple of 8. The picture height and width must also be a multiple of 8.

The label tells the compiler where the graphic data is located. It points to a label where you put the graphic data with the $BGF directive.

You can store multiple pictures when you use multiple labels and $BGF directives,

Note that the BGF files are RLE encoded to save code space.

See also

[PSET](pset.md) , [$BGF](_bgf.md) , [CONFIG GRAPHLCD](config_graphlcd.md) , [LINE](line.md) , [CIRCLE](circle.md) , [SHOWPICE](showpice.md)

Example

See [$BGF](_bgf.md) example

---

## SHOWPICE

Action

Shows a BGF file stored in EEPROM on the graphic display

Syntax

SHOWPICE x, y , label

Remarks

Showpice can display a converted BMP file that is stored in the EEPROM of the micro processor. The BMP must be converted into a BGF file with the [Tools Graphic Converter](tools_graphic_converter.md).

The X and Y parameters specify where the picture must be displayed. X and Y must be 0 or a multiple of 8. The picture height and width must also be a multiple of 8.

The label tells the compiler where the graphic data is located. It points to a label where you put the graphic data with the $BGF directive.

You can store multiple pictures when you use multiple labels and $BGF directives,

Note that the BGF files are RLE encoded to save code space.

See also

[PSET](pset.md) , [$BGF](_bgf.md) , [CONFIG GRAPHLCD](config_graphlcd.md) , [LINE](line.md) , [SHOWPIC](showpic.md) , [CIRCLE](circle.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : showpice.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstrates showing a picture from EEPROM

'micro : AT90S8535

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "8535def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'First we define that we use a graphic LCD

' Only 240*64 supported yet

Config Graphlcd = 240 * 128 , Dataport = Porta , Controlport = Portc , Ce = 2 , Cd = 3 , Wr = 0 , Rd = 1 , Reset = 4 , Fs = 5 , Mode = 8

'The dataport is th e portname that is connected to the data lines of the LCD

'The controlport is the portname which pins are used to control the lcd

'CE, CD etc. are the pin number of the CONTROLPORT.

' For example CE =2 because it is connected to PORTC.2

'mode 8 gives 240 / 8 = 30 columns , mode=6 gives 240 / 6 = 40 columns

'we will load the picture data into EEPROM so we specify $EEPROM

'the data must be specified before the showpicE statement.

$eeprom

```
Plaatje:

```vb
'the $BGF directive will load the data into the EEPROM or FLASH depending on the $EEPROM or $DATA directive

$bgf "mcs.bgf"

'switch back to normal DATA (flash) mode

$data

'Clear the screen will both clear text and graph display

```
Cls

```vb
'showpicE is used to show a picture from EEPROM

'showpic must be used when the data is located in Flash

```
Showpice 0 , 0 , Plaatje

End

---

## SIN

Action

Returns the sine of a float

Syntax

var = SIN( source )

Remarks

Var | A numeric variable that is assigned with sinus of variable source.  
---|---  
source | The single or double variable to get the sinus of.  
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [ATN](atn.md) , [COS](cos.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As Single , X As Single

```
S = 0.5 : X = Tan(s) : Print X ' prints 0.546302195

S = 0.5 : X = Sin(s) : Print X ' prints 0.479419108

S = 0.5 : X = Cos(s) : Print X ' prints 0.877588389

End

---

## SINH

Action

Returns the sinus hyperbole of a float

Syntax

var = SINH( source )

Remarks

Var | A numeric variable that is assigned with sinus hyperbole of variable source.  
---|---  
source | The single or double variable to get the sinus hyperbole of.  
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [ATN](atn.md) , [COS](cos.md) , [SIN](sin.md) , [TANH](tanh.md) , [COSH](cosh.md)

Example

[Show sample](fp_trig.md)

---

## SIZEOF

Action

This function returns the size of a variable.

Syntax

size = Sizeof(var)

Remarks

The SizeOf function returns the size in memory of a variable. It does not matter where the variable is stored : sram, xram or eeprom.

The functions accepts normal variables and indexed variables. When using an index, note that the total size is returned of the array. No matter which index you specify.

Since variables do not store run time information this function only works at compile time. So you can not use this function in a dynamic way

Variables use the following amount of memory.

Variable | Size in Bytes  
---|---  
Bit | 1  
Byte | 1  
Integer | 2  
Word | 2  
Dword | 4  
Long | 4  
Single | 4  
Double | 8  
String  | length + 1  
String * 1 | 2  
String * 10 | 11  
  
A bit is 1/8 of a byte. So there will fit 8 bits into a byte. The function will return the minimum length.

A string always uses an additional byte since strings are null terminated. Which means a null marks the end of a string. 

See also

[VARPTR](varptr.md)

Example

```vb
'--------------------------------------------------------------------------------------  
' sizeof.bas  
' (c)1995-2025, MCS Electronics  
' demo of sizeof() function  
'  
'--------------------------------------------------------------------------------------  
$regfile = "atXtiny816.dat"  
$hwstack = 32  
$swstack = 32  
$FrameSize=24  
  
'set the base for arrays to 0  
Config Base = 0  
  
Dim S As String * 10  
Dim B As Byte  
Dim I As Integer  
Dim L As Long  
Dim Sng As Single  
Dim D As Double  
  
Dim Bar(3) As Byte  
Dim Sar(4) As String * 5  
  
```
Const X3 = Sizeof(sar(0))  
  
```vb
Print X3  
Print Sizeof(s)  
Print Sizeof(b)  
Print Sizeof(i)  
Print Sizeof(l)  
Print Sizeof(sng)  
Print Sizeof(d)  
Print Sizeof(bar(_base))  
Print Sizeof(sar(_base))  
```
B = Sizeof(sar(_base))  
  
End

---

## SNTP

Action

This function retrieves the date and time from an SNTP server using the TCP/IP W3100 or W5100.

Syntax

result=SNTP(socket,IP)

Remarks

Result | A long or dword that is assigned with the date/time. If there is no data, the result will be 0.  
---|---  
socket | The socket number of the connection.  
IP | The IP number of the SNTP server you want to connect to. This may be a number like 192.168.0.2 or a LONG variable that is assigned with an IP number.  
  
SNTP means Network Time Protocol. It is an internet protocol used to synchronize clocks. SNTP uses UTC as reference time.

The SNTP function is intended to be used with a W3100A or W5100 chip. The SNTP function uses UDP routines from the library to fetch the time.

See also

NONE

Example

```vb
'-----------------------------------------------------------------------------------------  
'name : sntp_SPI.bas RFC 2030  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : test SNTP() function  
'micro : Mega88  
'suited for demo : yes  
'commercial addon needed : no  
'-----------------------------------------------------------------------------------------  
  
  
$regfile = "m88def.dat" ' specify the used micro  
$crystal = 8000000 ' used crystal frequency  
$baud = 19200 ' use baud rate  
$hwstack = 80 ' default use 32 for the hardware stack  
$swstack = 128 ' default use 10 for the SW stack  
$framesize = 80 ' default use 40 for the frame space  
$lib "datetime.lbx" ' this example uses date time routines  
  
Print "Init TCP" ' display a message  
Enable Interrupts ' before we use config tcpip , we need to enable the interrupts  
Config Tcpip = Int1 , Mac = 12.128.12.34.56.78 , Ip = 192.168.1.70 , Submask = 255.255.255.0 , Gateway = 192.168.1.1 , Localport = 1000 , Tx = $55 , Rx = $55 , Chip = W5100 , Spi = 1  
Print "Init done"  
  
Dim Var As Byte ' for i2c test  
  
  
Dim Ip As Long ' IP number of time server  
Dim Idx As Byte ' socket number  
Dim Lsntp As Long ' long SNTP time  
  
Print "SNTP demo"  
  
'assign the IP number of a SNTP server  
```
Ip = Maketcp(64.90.182.55 ) ' assign IP num NIST time.nist.gov port 37  
```vb
Print "Connecting to : " ; Ip2str(ip)  
  
  
'we will use Dutch format  
Config Date = Dmy , Separator = -  
  
  
'we need to get a socket first  
'note that for UDP we specify sock_dgram  
```
Idx = Getsocket(idx , Sock_dgram , 5000 , 0) ' get socket for UDP mode, specify port 5000  
```vb
Print "Socket " ; Idx ; " " ; Idx  
  
'UDP is a connection less protocol which means that you can not listen, connect or can get the status  
'You can just use send and receive the same way as for TCP/IP.  
'But since there is no connection protocol, you need to specify the destination IP address and port  
'So compare to TCP/IP you send exactly the same, but with the addition of the IP and PORT  
'The SNTP uses port 37 which is fixed in the tcp asm code  
  
  
  
Do  
  
'toggle the variable  
Toggle Var  
  
Waitms 5000  
  
```
Lsntp = Sntp(idx , Ip) ' get time from SNTP server  
```vb
' Print Idx ; Lsntp  
'notice that it is not recommended to get the time every sec  
'the time server might ban your IP  
'it is better to sync once or to run your own SNTP server and update that once a day  
  
'what happens is that IP number of timer server is send a diagram too  
'it will put the time into a variable lsntp and this is converted to BASCOM date/time format  
'in case of a problem the variable is 0  
Print Date(lsntp) ; Spc(3) ; Time(lsntp)  
Loop  
  
  
End

```

---

## SORT

Action

Sorts an array in ascending order.

Syntax

SORT array() [,elements] 

Remarks

array() | The first element of the array to sort.  
---|---  
elements | The number of elements to sort. This is an optional value. By default all elements will be sorted.  
  
Sorting is implemented for BYTE, WORD, INTEGER, LONG and DWORD arrays. 

The routines are located in mcs.lib. 

See also

The SAMPLES folder contains a user contributed insertion sort algorithm sample. (insertionsort.bas)

Example

```vb
'-------------------------------------------------------------------------------  
' SORT.BAS  
' (c) 1995-2025 , MCS Electronics  
' This demo demonstrates the SORT statement. It will sort an array  
'------------------------------------------------------------------------------  
$regfile = "m88def.dat"  
$crystal = 8000000  
$hwstack = 16  
$swstack = 8  
$framesize = 30  
  
'Dim some arrays  
Dim B(10) As Byte , I(10) As Integer , W(10) As Word  
Dim J As Byte  
  
'point to data  
```
Restore Arraydata  
  
```vb
'read the data  
For J = 1 To 10  
```
Read B(j)  
```vb
Next  
'read the words  
For J = 1 To 10  
```
Read W(j)  
```vb
Next  
'read the integers  
For J = 1 To 10  
```
Read I(j)  
```vb
Next  
  
'now sort the arrays  
```
Sort B(1) , 10 ' 10 elements  
Sort W(1) ' all elements  
Sort I(1)  
  
```vb
'and show the result  
For J = 1 To 10  
Print J ; " " ; B(j) ; " " ; W(j) ; " " ; I(j)  
Next  
End  
  
  
  
  
```
Arraydata:  
Data 1 , 4 , 8 , 9 , 2 , 5 , 3 , 7 , 6 , 4  
Data 1000% , 101% , 1% , 400% , 30000% , 20000% , 15000% , 0% , 999% , 111%  
Data -1000% , 101% , -1% , 400% , 30000% , 2000% , -15000% , 0% , 999% , 111%

---

## SOUND

Action

Sends pulses to a port pin.

Syntax

SOUND pin, duration, pulses

Remarks

Pin | Any I/O pin such as PORTB.0 etc.  
---|---  
Duration | The number of pulses to send. Byte, integer/word or constant.  
Pulses | The time the pin is pulled low and high. This is the value for a loop counter.  
  
When you connect a speaker or a buzzer to a port pin (see hardware) , you can use the SOUND statement to generate some tones.

The port pin is switched high and low for pulses times.

This loop is executed duration times.

The SOUND statement is not intended to generate accurate frequencies. Use a TIMER to do that.

![sound](sound.png)

See also

NONE

Example

```vb
'-----------------------------------------------------------------------------------------

'name : sound.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo : SOUND

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim Pulses As Word , Periods As Word

```
Pulses = 65535 : Periods = 10000 'set variables

Speaker Alias Portb.1 'define port pin

Sound Speaker , Pulses , Periods 'make some noice

```vb
'note that pulses and periods must have a high value for high XTALS

'sound is only intended to make some noise!

'pulses range from 1-65535

'periods range from 1-65535

End

```

---

## SPACE

Action

Returns a string that consists of spaces.

Syntax

var = SPACE(x)

Remarks

X | The number of spaces. This must be a value > 0  
---|---  
Var | The string that is assigned.  
  
In version 2085 the passed value is tested for 0. Since zero is not allowed, the resulting string will be unaltered when using 0.

SPACE supports [$BIGSTRINGS](bigstrings.md)

See also

[STRING](string.md) , [SPC](spc.md)

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates DEG2RAD function

'-------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 40 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As String * 15 , Z As String * 15

```
S = Space(5)

```vb
Print " {" ; S ; " }" '{ }

Dim A As Byte

```
A = 3

S = Space(a)

End

---

## SPC

Action

Prints the number of specified spaces.

Syntax

PRINT SPC(x)

LCD SPC(x)

Remarks

X | The number of spaces to print.  
---|---  
  
Using 0 for x will result in a string of 255 bytes because there is no check for a zero length assign.

SPC can be used with [LCD](lcd_1.md) too.

The difference with the SPACE function is that SPACE returns a number of spaces while SPC() can only be used with printing. Using SPACE() with printing is also possible but it will use a temporary buffer while SPC does not use a temporary buffer.

See also

[SPACE](space.md)

Example

```vb
'-------------------------------------------------------------------------------

'copyright : (c) 1995-2025, MCS Electronics

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'purpose : demonstrates DEG2RAD function

'-------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 40 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As String * 15 , Z As String * 15

Print "{" ; Spc(5) ; "}" '{ }

```
Lcd "{" ; Spc(5) ; "}" '{ }

---

## SPLIT

Action

Split a string into a number of array elements.

Syntax

count = SPLIT (source, array(idx), search)

Remarks

count | The number of elements that SPLIT() returned. When the array is not big enough to fill the array, this will be the maximum size of the array. So make sure the array is big enough to hold the results.  
---|---  
source | The source string or string constant to search for.  
array(idx) | The index of the first element of the array that will be filled. Notice that arrays are global.  
search | The character to search for. This can be a string or string constant or a byte with the ASCII value.  
  
When you use the serial port to receive data, in some cases you need to process the data in parts.

For example when you need to split an IP number as "123.45.24.12" you could use INSTR() or you can use SPLIT().

You must DIM the array yourself. The content of the array will be overwritten.

It is also important to know that the individual elements of the array need to be big enough to store the string part.

For example when the array has 5 elements and each element may be 10 characters long, a string that is 11 bytes long will not fit. Another element will be used in that case to store the additional info.

The SPLIT function takes care not to overwrite other memory. So when you split "1.2.2.2.2.2.2.3.3.3" into an array of 3 elements, you will loose the data.

If empty data is encountered, an empty element will be created. Thus "1,2,3,,5" will create 5 elements. Element 4 will be empty.

See also

[INSTR](instr.md) , [CHARPOS](charpos.md) , [JOIN](join.md)

Example

```vb
'--------------------------------------------------------------

' mega48.bas

' mega48 sample file

' (c) 1995-2025, MCS Electronics

'--------------------------------------------------------------

$regfile = "m48def.dat"

$crystal = 8000000

$baud = 19200

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As String * 80

Dim Ar(5) As String * 10

Dim Bcount As Byte

'The split function can split a string or string constant into elements

'It returns the number of elements

'You need to take care that there are enough elements and that each element is big enough

'to hold the result

'When a result does not fit into 1 element it will be put into the next element

'The memory is protected against overwriting.

```
S = "this is a test"

Bcount = Split( "this is a test" , Ar(1) , " ")

```vb
'bcount will get the number of filled elements

'ar(1) is the starting address to use

'" " means that we check for a space

'When you use " aa" , the first element will contain a space

```
Bcount = Split( "thiscannotfit! into the element" , Ar(1) , " ")

```vb
Dim J As Byte

For J = 1 To Bcount

Print Ar(j)

Next

'this demonstrates that your memory is safe and will not be overwritten when there are too many string parts

```
Bcount = Split( "do not overflow the array please" , Ar(1) , " ")

```vb
For J = 1 To Bcount

Print Ar(j)

Next

End

```

---

## SQR

Action

Returns the Square root of a variable.

Syntax

var = SQR( source )

Remarks

var | A numeric single or double variable that is assigned with the SQR of variable source.  
---|---  
source | The single or double variable to get the SQR of.  
  
When SQR is used with a single, the FP_TRIG library will be used.

When SQR is used with bytes, integers, words and longs, the SQR routine from MCS.LBX will be used.

See Also

[POWER](power.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 40 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Single

Dim B As Double

```
A = 9.0

B = 12345678.123

A =Sqr(A)

Print A ' prints 3.0

B = Sqr(b)

```vb
Print B

End

```

---

## START

Action

Start the specified hardware source.

Syntax

START device [ , cfg]

Remarks

Device | TIMER0, TIMER1, COUNTER0 or COUNTER1, WATCHDOG, AC (Analog comparator power), ADC(A/D converter power) or DAC(D/A converter).  
---|---  
XMEGA | For the Xmega you can also specify : DACA or DACB for the Digital/Analog Converters A and B. ADCA and ADCB for the A/D converters. For the timers you can use TCC0, TCC1, TCD0, TCD1, TCE0, TCE1, TCF0 and TCF1. To start a DMA soft transfer, you can use DMACH0, DMACH1, DMACH2 or DMACH3. The transfer starts after the DMA channel is ready.  For Xmega with Enhanced DMA, use EDMACH0, EDMACH1, EDMACH2 and EDMACH3.  
cfg | The optional cfg is only used for the TIMER when the optional CONFIGURATION is used. If CONFIG TIMERx = option , CONFIGURATION=mysetting was used, you would specify START TIMERx, mysetting.  
  
When you configure a timer (CONFIG TIMER), the TIMER is started automatically when a pre-scaler value is provided.

When you want to halt the timer you can use the STOP TIMER statement. To start the timer after it has been stopped, you can use the START TIMER statement. The START TIMER statement will only work correctly when you have selected a clock source or pre-scaler value with the CONFIG TIMER statement.

When you stored settings using the option CONFIGURATION=setting , then you can specify which configuration the timer must use by providing the setting name as a parameter : START TIMER1 , mysetting

When a timer is used in interrupt mode, it must be running otherwise the interrupt will never occur. 

TIMER0 and COUNTER0 are the same device. And so are TIMER1 and COUNTER1. 

The AC, ADC and DAC parameters will switch power to the device and thus enabling it to work.

The WATCHDOG parameter will activate the Watchdog.

See also

[STOP](stop.md)

Example

```vb
'--------------------------------------------------------------------------------

'name : adc.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demonstration of GETADC() function for 8535 or M163 micro

'micro : Mega163

'suited for demo : yes

'commercial addon needed : no

'use in simulator : possible

' Getadc() will also work for other AVR chips that have an ADC converter

'--------------------------------------------------------------------------------

$regfile = "m163def.dat" ' we use the M163

$crystal = 4000000

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'configure single mode and auto prescaler setting

'The single mode must be used with the GETADC() function

'The prescaler divides the internal clock by 2,4,8,16,32,64 or 128

'Because the ADC needs a clock from 50-200 KHz

'The AUTO feature, will select the highest clockrate possible

Config Adc = Single , Prescaler = Auto

'Now give power to the chip

```
Start Adc

```vb
'With STOP ADC, you can remove the power from the chip

'Stop Adc

Dim W As Word , Channel As Byte

```
Channel = 0

```vb
'now read A/D value from channel 0

Do

```
W = Getadc(channel)

Print "Channel " ; Channel ; " value " ; W

Incr Channel

```vb
If Channel > 7 Then Channel = 0

Loop

End

'The new M163 has options for the reference voltage

'For this chip you can use the additional param :

'Config Adc = Single , Prescaler = Auto, Reference = Internal

'The reference param may be :

'OFF : AREF, internal reference turned off

'AVCC : AVCC, with external capacitor at AREF pin

'INTERNAL : Internal 2.56 voltage reference with external capacitor ar AREF pin

'Using the additional param on chip that do not have the internal reference will have no effect.

```

---

## STCHECK

Action

Calls a routine to check for various stack overflows. This routine is intended for debug purposes.

Syntax

STCHECK

Remarks

The different stack spaces used by BASCOM-AVR lead to lots of questions about them.

The STCHECK routine can help to determine if the stack size are trashed by your program. The program STACK.BAS is used to explain the different settings.

Note that STCHECK should be removed form your final program. That is once you tested your program and found out is works fine, you can remove the call to STCHECK since it costs time and code space.

The settings used are :

Hwstack = 8

Softstack = 2

Framesize = 14

Below is a part of the memory of the 90S2313 used for the example:

C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF

D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF

FR FR FR FR FR FR FR FR

FR FR FR FR FR FR YY YY SP SP SP SP SP SP SP SP

Since the last memory in SRAM is DF, the hardware stack is occupied by D8-DF(8 bytes)

When a call is made or a push is used the data is saved at the position the hardware stack pointer is pointing to. After this the stack pointer is decreased.

A call uses 2 bytes so SP will be SP-2. (DF-2) =DD

When 8 bytes are stored the SP will point to D7. Another call or push will thus destroy memory position D7 which is occupied by the soft stack.

The soft stack begins directly after the hardware stack and is also growing down.

The Y pointer(r28+r29) is used to point to this data.

Since the Y pointer is decreased first and then the data is saved, the pointer must point at start up to a position higher. That is D8, the end of the hardware space.

St -y,r24 will point to D8-1=D7 and will store R24 at location D7.

Since 2 bytes were allocated in this example we use D7 and D6 to store the data.

When the pointer is at D6 and another St -y,r24 is used, it will write to position D5 which is the end of the frame space that is used as temporarily memory.

The frame starts at C8 and ends at D5. Writing beyond will overwrite the soft stack.

And when there is no soft stack needed, it will overwrite the hardware stack space.

The map above shows FR(frame), YY(soft stack data) and SP(hardware stack space)

How to determine the right values?

The stack check routine can be used to determine if there is an overflow.

It will check :

-if SP is below it's size. In this case below D8.

-if YY is below itâs size in this case when it is D5

-if the frame is above its size in this case D6

When is YY(soft stack) used? When you use a LOCAL variable inside a SUB or function. Each local variable will use 2 bytes.

When you pass variables to user Subroutines or functions it uses 2 bytes for each parameter.

call mysub(x,y) will use 2 * 2 = 4 bytes.

local z as byte ' will use another 2 bytes

This space is freed when the routine ends.

But when you call another sub inside the sub, you need more space.

sub mysub(x as byte,y as byte)

call testsub(r as byte) ' we must add another 2 bytes

When you use empty(no params) call like :

call mytest() , No space is used.

When do you need frame space?

When ever you use a num<>string conversion routine like:

Print b (where b is a byte variable)

Bytes will use 4 bytes max (123+0)

Integer will use 7 bytes max (-12345+0)c

Longs will use 16 bytes max

And the single will use 24 bytes max

When you add strings and use the original the value must be remembered by the compiler.

Consider this :

s$ = "abcd" + s$

Here you give s$ a new value. But you append the original value so the original value must be remembered until the operation has completed. This copy is stored in the frame too.

So when string s$ was dimmed with a length of 20, you need a frame space of 20+1(null byte)

When you pass a variable by VALUE (BYVAL) then you actually pass a copy of the variable.

When you pass a byte, 1 byte of frame space is used, a long will take 4 bytes.

When you use a LOCAL LONG, you also need 4 bytes of frame space to store the local long.

The frame space is reused and so is the soft stack space and hardware stack space.

So the hard part is to determine the right sizes!

The stack check routine must be called inside the deepest nested sub or function.

Gosub test

test:

```vb
gosub test1

return

```
test1:

' this is the deepest level so check the stack here

stcheck

return

Stcheck will use 1 variable named ERROR. You must dimension it yourself.

Dim Error As Byte

Error will be set to :

1: if hardware stack grows down into the soft stack space

2: if the soft stack space grows down into the frame space

3: if the frame space grows up into the soft stack space.

The last 2 errors are not necessarily bad when you consider that when the soft stack is not used for passing data, it may be used by the frame space to store data. Confusing right.?

![notice](notice.jpg) It is advised to use the simpler DBG/$DBG method. This requires that you can simulate your program.

ASM

Routines called by STCHECK :

_StackCheck : uses R24 and R25 but these are saved and restored.

Because the call uses 2 bytes of hardware stack space and the saving of R24 and R25 also costs 2 bytes, it uses 4 more bytes of hardware stack space than your final program would do that f course does not need to use STCHECK.

Example

```vb
'-----------------------------------------------------------------------------------------

'name : stack.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : shows how to check for the stack sizes

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 8 ' default use 32 for the hardware stack

$swstack = 2 ' default use 10 for the SW stack

$framesize = 14 ' default use 40 for the frame space

'settings must be :

'HW Stack : 8

'Soft Stack : 2

'Frame size : 14

'note that the called routine (_STACKCHECK) will use 4 bytes

'ofhardware stack space

'So when your program works, you may subtract the 4 bytes of the needed hardware stack size

'in your final program that does not include the STCHECK

'testmode =0 will work

'testmode =1 will use too much hardware stack

'testmode =2 will use too much soft stack space

'testmode =3 will use too much frame space

```
Const Testmode = 0

```vb
'compile and test the program with testmode from 0-3

'you need to dim the ERROR byte !!

Dim Error As Byte

#if Testmode = 2

Declare Sub Pass(z As Long , Byval K As Long)

#else

Declare Sub Pass()

#endif

Dim I As Long

```
I = 2

```vb
Print I

'call the sub in your code at the deepest level

'normally within a function or sub

#if Testmode = 2

```
Call Pass(i , 1)

#else

Call Pass()

```vb
#endif

End

#if Testmode = 2

Sub Pass(z As Long , Byval K As Long)

#else

Sub Pass()

#endif

#if Testmode = 3

```
Local S As String * 13

#else

Local S As String * 8

```vb
#endif

Print I

Gosub Test

End Sub

```
Test:

#if Testmode = 1

push r0 ; eat some hardware stack space

push r1

push r2

```vb
#endif

' *** here we call the routine ***

```
Stcheck

```vb
' *** when error <>0 then there is a problem ***

#if Testmode = 1

```
pop r2

pop r1

pop r0

```vb
#endif

Return

```

---

## StencilFunc

Action

Set function and reference value for stencil testing.

Syntax

StencilFunc func, ref, mask

Remarks

func | Specifies the test function, one of NEVER, LESS, LEQUAL, GREATER, GEQUAL, EQUAL, NOTEQUAL, or ALWAYS. The initial value is ALWAYS.   
---|---  
ref | Specifies the reference value for the stencil test, range 0 to 255, the initial value is 0  
mask | Specifies a mask that is ANDed with the reference value and the stored stencil value, range 0 to 255 The initial value is 255  
  
Stencil test rejects or accepts pixels depending on the result of the test function defined in func parameter, which operates 

on the current value in the stencil buffer against the reference value.

See also

[StencilOp](stencilop.md), [StencilMask](stencilmask.md)

Example

```vb
' Pseudocode

' Draw two points, incrementing stencil at each pixel, then draw the pixels with value 2 in red

```
StencilOp INCR, INCR

PointSize 760

Begin_G FTPOINTS

Vertex2II 50, 60, 0, 0

Vertex2II 110, 60, 0, 0

StencilFunc EQUAL, 2, 255

ColorRGB 100, 0, 0

Vertex2II 80, 60, 0, 0

![clip0085](clip0085.png)

---

## StencilMask

Action

Control the writing of individual bits in the stencil planes.

Syntax

StencilMask mask

Remarks

mask | The mask used to enable writing stencil bits, range 0 \- 255,  the initial value is 255  
---|---  
  
See also

[StencilFunc](stencilfunc.md), [StencilOp](stencilop.md), [TagMask](tagmask.md)

---

## StencilOp

Action

Set stencil test actions.

Syntax

StencilOp sfail, spass

Remarks

sfail | Specifies the action to take when the stencil test fails, one of KEEP, ZERO, REPLACE, INCR, DECR and INVERT. The initial value is KEEP  
---|---  
spass | Specifies the action to take when the stencil test passes, one of the same constants as sfail.  The initial value is KEEP  
  
The stencil operation specifies how the stencil buffer is updated. The operation selected depends on whether the stencil test 

passes or not.

See also

[StencilFunc](stencilfunc.md), [StencilMask](stencilmask.md)

Example

```vb
' Pseudocode

' Draw two points, incrementing stencil at each pixel, then draw the pixels with value 2 in red

```
StencilOp INCR, INCR

PointSize 760

Begin_G FTPOINTS

Vertex2II 50, 60, 0, 0

Vertex2II 110, 60, 0, 0

StencilFunc EQUAL, 2, 255

ColorRGB 100, 0, 0

Vertex2II 80, 60, 0, 0

![clip0085](clip0085.png)

---

## STK500 Programmer

When you select the STK500 programmer, BASCOM will run the file named stk500.exe that is installed with AVR Studio.

That is why you have to specify the file location of the stk500.exe

The normal STK500 support will erase, and program the flash.

The STK500.EXE supports a number of Atmel programmers which all use the STK500 V1 or V2 protocol.

For the AVR ISP mkII, you need to supply the serial number of the USB programmer. The USB port will be used then instead of the serial port.

You can also use the native driver which does not use/need the stk500.exe

If you select this programmer, you will see the following window when you launch the programmer with F4(manual program)

![stk500_native](stk500_native.png)

When the source code is compiled and the BIN file exists, it is loaded automatic into the buffer.

When an EEPROM image file exists (EEP), it is loaded too into the EEPROM buffer. When it does not exist you will see a warning which you can ignore.

When the target device is not read yet, the CHIP will be unidentified which is marked as ???.

In the status bar you can see the loaded file, and the size of the file. Notice that 16000 will be shown as 16 KB. 

You can select the EEPROM-TAB to view the EEPROM image. Memory locations can be altered. Select a cell, and type a new value. Then press ENTER to confirm. You can immediately see the new value. 

When you select the Lock and Fusebits-TAB the lock and fuse bits will be read.

![stk500_native_lockfuse](stk500_native_lockfuse.png)

As you can see that as soon as the target chip is determined, the chip name is shown under the tool bar.

The FLASH size and EEPROM size are shown also.

As soon as you alter a lock or fuse bit, the corresponding Write-button will be enabled. You need to click it to write the new value. The lock and fuse bits are read again so you can see if it worked out. The lock and fuse bits shown will depend on the used chip. Every chip has different fuse bits. Some fuse bits can not be altered via the serial programming method. The native stk500 driver uses the serial programming method. Some fuse bits require the parallel or high voltage programming method. For example the fuse bit 'enable serial downloading' can not be changed with the serial programming method.

Fuse bits of interest are : the clock divider and the oscillator fuse bits. When you select a wrong oscillator fuse bit (for example you select an external oscillator) the chip will not work anymore till you connect such an external oscillator! Of course a simple 555 chip can generate a clock signal you can use to 'wake' a locked chip. 

Once you have all settings right, you can press the 'Write PRG' button which will insert some code into your program at the current cursor position. This is the $PROG directive. 

For example : $prog &HFF , &HED , &HD0 , &HFF 

When you compile your program with the [$PROG](_prog.md) directive it will generate a PRG file with the lock and fuse bit settings. 

```vb
If you then auto program(see later) a chip, it will use these settings. 

$PROG is great to load the right lock and fuse bits into a new chip. But be careful : do not enable $PROG till you are done with development. Otherwise programming will be slow because of the extra reading and writing steps. 

```
The following menu options are available: 

Option | Description  
---|---  
File |   
  
Exit | Close programmer.  
  
|   
  
Buffer |   
  
Clear | Clear buffer. Will put a value of 255 (FF hex) into each memory location. When the FLASH-TAB has the focus, the FLASH buffer will be cleared. When the EEPROM-TAB has the focus, the EEPROM buffer will be cleared. 255 is the value of an empty memory location.  
Load from File | This will shown an open file dialog so you can select a binary file (BIN)  
  
| The file is loaded into the buffer.  
Save to File | Will save the current buffer to a file.  
Reload | Reloads the buffer from the file image.  
  
|   
  
Chip |   
  
Identify | Will attempt to read the signature of the chip. When the signature is unknown(no DAT file available) or there is no chip or other error, you will get an error. Otherwise the chip name will be shown.  
Write buffer to chip | This will write the active buffer(FLASH or EEPROM) into the chip.  
Read chipcode | When the chip lock bit is not set you can read the FLASH or EEPROM into the buffer.  
Blank check | Check if the chip FLASH or EEPROM is empty.   
Erase | Erases the chip FLASH. It depends on the fusebits if the EEPROM is erased too. Normally the EEPROM is erased too but some chip have a fuse bit to preserve EEPROM when erasing the chip. A chip MUST be erased before it can be programmed.  
Verify | Checks if the buffer matches the chip FLASH or EEPROM.  
Auto program | This will eraser, and program the FLASH and EEPROM and if $PROG is used, it will set the lock and fusebits too.   
  
Under Options, you can find a setting to change the clock frequency. 

![notice](notice.jpg)The clock frequency should not be higher then a quarter of the oscillator frequency.

This means that a chip with an internal 8 MHz oscillator which has the 8-divider fuse enabled, will have a clock frequency of 1 Mhz.

The programming clock may not exceed 250 KHz in this case.

STK500 board

When using the STK500 board, you can change the target voltage and the reference voltage. In 2081 you can also change the board oscillator frequency.

The BOARD menu has a sub menu named STK500. This sub menu has a few options :

\- Read Settings : you should do this first

\- Vtarget : this is the target voltage. Make sure the chip can handle the voltage you enter

\- Vref : this is the reference voltage. It may not exceed Vtarget.

\- Osc : this is the oscillator frequency. 

\- Write settings : this will write the new settings to the STK500 board. After doing so, read back the settings to see if the values are correct. You will notice that not all values you enter are possible. This is exactly the same when you use AVR Studio. 

![stk500-custom-settings](stk500-custom-settings.png)

---

## STK600

The STK600 is a development board from Atmel. It uses a similar protocol as the STK500 and has an integrated USB programmer on board.

The programmer can be connected with a cable to the STK600 board itself, but also to an external board.

The STK600 replaces the STK500 and is advised for XMEGA development. For regular AVR chips we would recommend the STK500.

The STK600 has actual 3 different programmers on board : ISP, PDI and JTAG. the ISP/PDI protocols are combined and placed on one connector. 

When programming XMEGA chips, the BASCOM programmers will automatic switch to the PDI protocol. The ISP protocol can not be used with XMEGA chips.

For other chips, (non-xmega), the ISP protocol will be used.

There are affordable PDI programmers available. 

The following description is also true for the AVRISP/mkII programmer which also supports the PDI protocol.

In order to use the STK600 protocol you need to have [LIBSUSB](libusb.md) installed.

Identification

The BASCOM programmers always try to identify the chip before an action is performed. This is needed to check the size and to check if your program is intended for the selected chip.

It would not be a good idea for example to program an attiny13 with xmega128a1 code.

When you chose manual programming, you will get the following window:

![stk600_1](stk600_1.jpg)

As you can see, the binary image is loaded and if an EEPROM EEP binary image was available it would have been loaded too.

When you click the Identify button, the programmer will read the device id. The same will happen for any other action you chose.

![STK600_2](stk600_2.jpg)

The Device ID is now read and you can see the ATXMEGA128A1 is detected. 

The programmer has the same options as the STK500 programmer. Only the lock and fuse byte differ for the Xmega.

When you select the Lock and Fuse bits, you will get a similar screen:

![stk600_3](stk600_3.jpg)

The XMEGA has one lock byte and 6 fuse byes named FUSE0-FUSE5.

Not all fuse bytes are used. The options depend on the XMEGA chip you use.

In the screen shot from above you can see that under the FUSE1 section, the 'Watchdog Window Configuration' is colored red. 

When you change an option and move focus or enter, a change will result in the option to be shown in red.

When you have selected all values you can select the WRITE button to write the lock and fuse bytes.

After this the values will be read again and updated.

The WRITE PRG button will insert a $PROG directive into your code with all lock and fuse bytes.

A description of the fuse bytes you can find in the PDF of the processor.

---

## STOP

Action

Stop the specified device. Or stop the program

Syntax

STOP device

STOP

Remarks

Device | TIMER0, TIMER1, COUNTER0 or COUNTER1, WATCHDOG, AC (Analog comparator power) , ADC(A/D converter power) or DAC(D/A converter)  
---|---  
XMEGA | For the Xmega you can also specify : DACA or DACB for the Digital/Analog Converters A and B.  
  
The single STOP statement will end your program by generating a never ending loop. When END is used it will have the same effect but in addition it will disable all interrupts.

The STOP statement with one of the above parameters will stop the specified device.

TIMER0 and COUNTER0 are the same device.

The AC and ADC parameters will switch power off the device to disable it and thus save power.

See also

[START](start.md) , [END](end.md)

Example

See [START](start.md) example

---

## STR

Action

Returns a string representation of a number.

Syntax

var = STR( x [,digits])

Remarks

var | A string variable.  
---|---  
X | A numeric variable.  
digits | An options parameter, only allowed for singles and doubles. It specifies how many digits after the comma/point are used. When using with a single, you need to use : [CONFIG SINGLE=SCIENTIFIC](configsingle.md)  
  
![notice](notice.jpg)The string must be big enough to store the result. So if you have a string like this : Dim S as string * 4, and you use it on a single with the value 0.00000001 then there is not enough space in the string to hold the result. Strings that are assigned with Str() should be dimmed 16 characters long.

You do not need to convert a variable into a string before you print it.

When you use PRINT var, then you will get the same result as when you convert the numeric variable into a string, and print that string.

The PRINT routine will convert the numeric variable into a string before it gets printed to the serial port.

As the integer conversion routines can convert byte, integer, word and longs into a string it also means some code overhead when you do not use longs. You can include the alternative library named [mcsbyte](mcsbyte.md).lbx then. This library can only print bytes. There is also a library for printing integers and words only. This library is named [mcsbyteint](mcsbyteint.md).

When you use these libs to print a long you will get an error message.

See also

[VAL](val.md) , [HEX](hex.md) , [HEXVAL](hexval.md) , [MCSBYTE](mcsbyte.md) , [BIN](bin.md) , [STR2DIGITS](str2digits.md) , [FUSING](fusing.md)

Difference with VB

In VB STR() returns a string with a leading space. BASCOM does not return a leading space.

Example

Dim A As Byte , S As String * 10

A = 123

S = Str(a)

```vb
Print S ' 123

'when you use print a, you will get the same result.

'but a string can also be manipulated with the string routines.

End

```

---

## STR2DIGITS

Action

This statement will convert a string into an array of binary numbers.

Syntax

STR2DIGITS  s , ar(1)

Remarks

s | A string variable that holds a number. For example "12345"  
---|---  
ar(1) | The first element of a byte array that will be assigned with the binary representation of the digits. After the conversion, the first element will be assigned with the number of processed digits. The next element will become the most right digit of the string, the last element will become the first character of the string. In this example with string "12345" ar(1) = 5 ar(2) = 5 ar(3) = 4 ar(4) = 3 ar(5) = 2 ar(6) = 1 Your array need to be big enough to hold all digits and the digit counter.  
  
You can convert a string into a number with VAL() and a number into a string with STR().

In some cases, it is required to have access to all the individual digits of a variable.

While you can use a loop and MOD to get all digits, the STR2DIGITS will work for bytes, word, and longs.

Non numeric digits will not be converted properly. For example, in a string "-0" , the 0 which is ASCII 48, will be converted into a 0. The - is 45 and will result in 45-48=-3, and in byte form : 253.

The dot (.) will be converted into 254. 

See also

[STR](str.md) , [VAL](val.md)

Example

```vb
'-------------------------------------------------------------------------------  
' ARDUINO-Duemilanove.BAS  
' Also tested with ARDUINO NANO V3.0  
' (c) 1995-2025, MCS Electronics  
' This is a sample file for the Mega328P based ARDUINO board  
' Select Programmer 'ARDUINO' , 57600 baud and the proper COM port  
'-------------------------------------------------------------------------------  
$regfile= "m328pdef.dat" ' used micro  
$crystal=16000000 ' used xtal  
$baud=19200 ' baud rate we want  
config clockdiv=1 ' either use this or change the divider fuse byte  
'-------------------------------------------------------------------------------  
  
dim w as word  
dim s as string * 6, ar(6) as byte  
  
config portb=output ' make portb an output  
do  
toggle portb ' toggle level  
waitms 1000 ' wait 1 sec  
print "Duemilanove" ' test serial com  
  
```
w=w+1 : s=str(w) ' convert w to a string  
str2digits s,ar(1) ' convert string into an array with binary numbers  
loop

---

## STRING

Action

Returns a string consisting of m repetitions of the character with ASCII Code n.

Syntax

var = STRING(m ,n)

Remarks

Var | The string that is assigned.  
---|---  
N | The ASCII-code that is assigned to the string.  
M | The number of characters to assign. This must be a number > 0  
  
Since a string is terminated by a 0 byte, you can't use 0 for n. That is you could but the result would be an empty string.

Using 0 for x will not alter the resulting string.

STRING supports [$BIGSTRINGS](bigstrings.md)

See also

[SPACE](space.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 40 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As String * 15

```
S = String(5 , 65)

```vb
Print S 'AAAAA

End

```

---

## SUB

Action

Defines a Sub procedure.

Syntax

SUB Name[(var1 , â¦ )]

Remarks

Name | Name of the sub procedure, can be any non-reserved word.  
---|---  
var1 | The name of the optional parameter(s).  
  
You must end each subroutine with the END SUB statement.

You can copy the DECLARE SUB line and remove the DECLARE statement. This ensures that you have the right parameters.

You can also use CONFIG SUBMODE=NEW and only write the implementation. In that case you do not need to write the DECLARATION.

See Also

[FUNCTION](declare_function.md) , [CALL](call.md) , [CONFIG SUBMODE](config_submode.md) , [EXIT](exit.md)

See the [DECLARE SUB](declare_sub.md) topic for more details.

---

## Supported Programmers

BASCOM supports the following programmers

[AVR ICP910 based on the AVR910.ASM application note](avr_isp_programmer.md)

[STK200 ISP programmer from Atmel](avr_isp_programmer.md)

[The PG302 programmer from Iguana Labs](pg302_programmer.md)

[The simple cable programmer from Sample Electronics.](sample_electronics_cable_programmer.md)

[KITSRUS KIT122 Programmer](kitsrus_programmer.md)

[MCS Universal Interface Programmer](mcs_universal_interface_programmer.md)

The MCS Universal Interface supports a number of programmers as well. In fact it is possible to support most parallel printer port programmers.

[STK500 programmer and Extended STK500 programmer.](stk500_programmer.md)

[Lawicel BootLoader](lawicel_bootloader.md)

[USB-ISP Programmer](usb_ispprogrammer.md)

[MCS Bootloader](mcsbootloader.md)

[PROGGY](proggy.md)

[MyAVR/MK2/AVR910 programmer](myavrmk2avr910_programmer.md)

[FLIP](flip.md)

[USBprog Programmer / AVR ISP mkII](elektor__avr_isp_mkii.md) (AVRISP)

[KamProg for AVR](kamprog_for_avr.md)

[USBASP](usbasp.md)

[STK600](stk600.md)

[ARDUINO](arduino.md)

[BIPOM MINI-MAX/C](bipom_mini_maxc.md)

[mySmartUSB light](mysmartusb_light.md)

[UPDI Programmer](updi_programmer.md)

[MCS EDBG Programmer](mcs_snap_programmer.md)

---

## SWAP

Action

Exchange two variables of the same type.

Exchange a nibble or 2 bytes

Syntax

SWAP var1, var2

SWAP var3

Remarks

var1 | A variable of type bit, byte, integer, word, long or string.  
---|---  
var2 | A variable of the same type as var1.  
var3 | A byte, integer,word,long or dword  
  
After the swap, var1 will hold the value of var2 and var2 will hold the value of var1.

When using swap with a single variable it need to be a byte, integer/word or long/dword variable.

In version 2084 you can also swap a dword or long.

When using swap on a byte, the nibbles will be swapped. 

Example :

byte=&B1100_0001 : swap byte : byte will become : &B0001_1100

When using swap on a single integer or word, the 2 bytes will be swapped so the LSB becomes the MSB and the MSB becomes the LSB.

When using swap on a single dword or long, the 4 bytes will be swapped the following way :

LSB NSB1 NSB2 MSB will become : MSB NSB2 NSB1 LSB

Example

```vb
'-----------------------------------------------------------------------------------------

'name : swap.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: SWAP

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte , B1 As Byte

Dim Bbit1 As Bit , Bbit2 As Bit

Dim S1 As String * 10 , S2 As String * 10

```
S1 = "AAA" : S2 = "BBB"

Swap S1 , S2

A = 5 : B1 = 10 'assign some vars

Print A ; " " ; B1 'print them

Swap A , B1 'swap them

```vb
Print A ; " " ; B1 'print is again

Set Bbit1

```
Swap Bbit1 , Bbit2

```vb
Print Bbit1 ; Bbit2

End

```

---

## SYSDAY

Action

Returns a number, which represents the System Day

Syntax

Target = SysDay()

Target = SysDay(bDayMonthYear)

Target = SysDay(strDate)

Target = SysDay(lSysSec)

Remarks

Target | A Variable (WORD), that is assigned with the System-Day  
---|---  
bDayMonthDay | A Byte, which holds the Day-value followed by Month(Byte) and Year (Byte)  
strDate | A String, which holds a Date-String in the format specified in the CONFIG DATA statement  
lSysSec | A variable, which holds a System Second (SysSec)  
  
The Function can be used with 4 different kind of inputs:

1.| Without any parameter. The internal Date-values of SOFTCLOCK (_day, _month, _year) are used.  
---|---  
  
2.| With a user defined date array. It must be arranged in same way (Day, Month, Year) as the internal SOFTCLOCK date. The first Byte (Day) is the input by this kind of usage. So the Day of the Year can be calculated of every date.  
---|---  
  
3.| With a Date-String. The date-string must be in the Format specified in the Config Date Statement.  
---|---  
  
4.| With a System Second Number (LONG)  
---|---  
  
The Return-Value is in the Range of 0 to 36524. 2000-01-01 starts with 0.

The Function is valid in the 21th century (from 2000-01-01 to 2099-12-31).

See also

[Date and Time Routines](datetime.md) , [Config Date](config_date.md) , [Config Clock](config_clock.md) , [SysSec](syssec.md)

Example

```vb
Enable Interrupts

Config Clock = Soft

Config Date = YMD , Separator =.' ANSI-Format

Dim Strdate As String * 8

Dim Bday Asbyte , Bmonth As Byte , Byear As Byte

Dim Wsysday As Word

Dim Lsyssec As Long

' Example 1 with internal RTC-Clock

```
_day = 20 : _Month = 11 : _Year = 2 ' Load RTC-Clock for example - testing

Wsysday = Sysday()

```vb
Print "System Day of " ; Date$ ; " is " ; Wsysday

' System Day of 02.11.20 is 1054

' Example 2 with defined Clock - Bytes (Day / Month / Year)

```
Bday = 24 : Bmonth = 5 : Byear = 8

Wsysday = Sysday(bday)

```vb
Print "System Day of Day=" ; Bday ; " Month=" ; Bmonth ; " Year=" ; Byear ; " is " ; Wsysday

' System Day of Day=24 Month=5 Year=8 is 3066

' Example 3 with Date - String

```
Strdate = "04.10.29"

Wsysday = Sysday(strdate)

```vb
Print "System Day of " ; Strdate ; " is " ; Wsysday

' System Day of 04.10.29 is 1763

' Example 4 with System Second

```
Lsyssec = 123456789

Wsysday = Sysday(lsyssec)

```vb
Print "System Day of System Second " ; Lsyssec ; " is " ; Wsysday

' System Day of System Second 123456789 is 1428"Now it's " ; Lsystemsecondselapsed ; " seconds later"

```

---

## SYSSEC

Action

Returns a Number, which represents the System Second

Syntax

Target = SYSSEC()

Target = SYSSEC(bSecMinHour)

Target = SYSSEC(strTime, strDate)

Target = SYSSEC(wSysDay)

Remarks

Target | A Variable (LONG), that is assigned with the System-Second  
---|---  
BSecMinHour | A Byte, which holds the Sec-value followed by Min(Byte), Hour (Byte), Day(Byte), Month(Byte) and Year(Byte)  
StrTime | A time-string in the format âhh:mm:ss"  
StrDate | A date-string in the format specified in the Config Date statement  
wSysDay | A variable (Word) which holds the System Day (SysDay)  
  
The Function can be used with 4 different kind of inputs:

1.| Without any parameter. The internal Time and Date of SOFTCLOCK (_sec, _min, _hour, _day, _month, _year) is used.  
---|---  
  
2.| With a user defined time and Date array. It must be arranged in same way (Second, Minute, Hour, Day, Month, Year) as the internal SOFTCLOCK time/date. The first Byte (Second) is the input by this kind of usage. So the System Second can be calculated of every time/date.  
---|---  
  
3.| With a time-String and a date-string. The time-string must be in the Format âhh:mm:ss". The date-string must be in the format specified in the Config Date statement  
---|---  
  
4.| With a System Day Number (Word). The result is the System Second of this day at 00:00:00.  
---|---  
  
The Return-Value is in the Range of 0 to 2147483647. 2000-01-01 at 00:00:00 starts with 0.

The Function is valid from 2000-01-01 to 2068-01-19 03:14:07. In the year 2068 a LONG â overflow will occur.

Unix time stamp starts 1-1-1970 which will limit the use till 2038.

Bascom time stamp starts 1-1-2000 giving longer working time.

If you wish to convert to NTP which starts at 1.1.1970, which is 30 years earlier, you need to subtract a value of 946684800

BASCOM DATE_TIME = NTP - 946684800

See also

[Date and Time Routines](datetime.md) , [SYSSECELAPSED](syssecelapsed.md), [SYSDAY](sysday.md)

Example

```vb
Enable Interrupts

Config Clock = Soft

Config Date = YMD , Separator =.' ANSI-Format

Dim Strdate As String * 8

Dim Strtime As String * 8

Dim Bsec As Byte , Bmin As Byte , Bhour As Byte

Dim Bday As Byte , Bmonth As Byte , Byear As Byte

Dim Wsysday As Word

Dim Lsyssec As Long

' Example 1 with internal RTC-Clock

' Load RTC-Clock for example - testing

```
_sec = 17 : _min = 35 : _hour = 8 : _day = 16 : _month = 4 : _year = 3

Lsyssec = Syssec()

```vb
Print "System Second of " ; Time$ ; " at " ; Date$ ; " is " ; Lsyssec

' System Second of 08:35:17 at 03.04.16 is 103797317

' Example 2 with with defined Clock - Bytes (Second, Minute, Hour, Day / Month / Year)

```
Bsec = 20 : Bmin = 1 : Bhour = 7 : Bday = 22 : Bmonth = 12 : Byear = 1

Lsyssec = Syssec(bsec)

Strtime = Time_sb(bsec) : Strdate = Date_sb(bday)

```vb
Print "System Second of " ; Strtime ; " at " ; Strdate ; " is " ; Lsyssec

' System Second of 07:01:20 at 01.12.22 is 62319680

' Example 3 with Time and Date - String

```
Strtime = "04:58:37"

strDate ="02.09.18"

Lsyssec = Syssec(strtime , Strdate)

```vb
Print "System Second of " ; Strtime ; " at " ; Strdate ; " is " ; Lsyssec

' System Second of 04:58:37 at 02.09.18 is 85640317

' Example 4 with System Day

```
Wsysday = 2000

Lsyssec = Syssec(wsysday)

```vb
Print "System Second of System Day " ; Wsysday ; " (00:00:00) is " ; Lsyssec

' System Second of System Day 2000 (00:00:00) is 172800000 

```

---

## SYSSECELAPSED

Action

Returns the elapsed Seconds to a earlier assigned system-time-stamp.

Syntax

Target = SysSecElapsed(SystemTimeStamp)

Remarks

Target | A variable (LONG), that is assigned with the elapsed Seconds  
---|---  
SystemTimeStamp | A variable (LONG), which holds a Systemtimestamp like the output of an earlier called SysSec()  
  
The Return-Value is in the Range of 0 to 2147483647. The Function is valid from 2000-01-01 to 2068-01-19 at 03:14:07. In the year 2068 a LONG â overflow will occur.

The difference to the pair DayOfSec and SecElapsed is, that SysSec and SysSecElapsed can be used for event distances larger than 24 hours.

See also

[Date and Time Routines](datetime.md) , [SECELAPSED](secelapsed.md), [SYSSEC](syssec.md)

Example

```vb
Enable Interrupts

Config Clock = Soft

Dim Lsystemtimestamp As Long

Dim Lsystemsecondselapsed As Long

```
Lsystemtimestamp = Syssec()

```vb
Print "Now it's " ; Lsystemtimestamp ; " seconds past 2000-01-01 00:00:00"

' do other stuff

' some time later

```
Lsystemsecondselapsed = Syssecelapsed(lsystemtimestamp)

Print "Now it's " ; Lsystemsecondselapsed ; " seconds later"

---

## Table of contents

Index

[Index](index.md)

[Keyword Reference](functionalreference.md)

[Changes](what_is_new_in_2078_2079.md)

About MCS

[About MCS](about_mcs_electronics.md)

[Custom Design](custom_designs.md)

[Application Notes](application_notes.md)

Installation

[Installation](installation.md)

[Problems and solutions](newbie_problems.md)

[Updates](updates.md)

[Move to a New PC](move_to_new_pc.md)

[Installation on multiple computers](install_on_multiple_computers.md)

BASCOM-IDE

[The BASCOM IDE](running_bascom_avr.md)

File

[New](file_new.md) , [Open](file_open.md) , [Close](file_close.md) , [Save](file_save.md) , [Save As](file_save_as.md) , [Print Preview](file_print_preview.md) , [Print](file_print.md) , [Project](file_project.md), [Exit](file_exit.md) , [ZIP](file_zip.md)

Edit

[Undo](edit_undo.md) , [Redo](edit_redo.md) , [Cut](edit_cut.md) , [Copy](edit_copy.md) , [Paste](edit_paste.md) , [Find](edit_find.md) , [Find Next](edit_find_next.md) , [Replace](edit_replace.md) , [Goto](edit_goto.md) , [Toggle Bookmark](edit_toggle_bookmark.md) , [Goto Bookmark](edit_goto_bookmark.md) , [Indent Block](edit_indent_block.md) , [Unindent Block](edit_unindent_block.md) , [Encrypt Selected Code](edit_encrypt_selected_code.md) , [Proper Indent](edit_proper_indent.md) , [Show Excluded Code](edit_show_excluded_code.md) , [Insert ASCII](edit_insert_ascii.md) , [Fold All Subs and Functions](edit_fold_all_subs_and_functions.md), [Unfold All Code](edit_unfold_all_code.md) , [Show Dead Code](edit_show_dead_code.md)

View

[PinOut](viewpinout.md) , [PDF ](viewpdfviewer.md), [Errors](viewerrorpanel.md) , [Show Alert Window](viewalertwindow.md) , [Project Files](view_project_files.md), [Code Explorer](view_code_explorer.md) , [Vertical Splitter](view_vertical_splitter.md)

Program

[Compile](program_compile.md) , [Syntax Check](program_syntax_check.md) , [Show Result](program_show_result.md) , [Simulate](program_simulate.md) , [Send to Chip](program_send_to_chip.md) , [Reset Chip](program_reset_chip.md)

Tools  
[LIB Manager](tools_lib_manager.md) , [Terminal Emulator](tools_terminal_emulator.md) , [LCD Designer](tools_lcd_designer.md) , [Graphic Converter](tools_graphic_converter.md) , [Batch Compile](toolsbatchcompile.md) , [PDF Update](tools_pdf_update.md) , [Resource Editor](tools_resource_editor.md) , [Stack Analyzer](tools_stack_analyzer.md), [Plugin Manager](tools_plugin_manager.md) , [Font Editor](tools_font_editor.md)

Options

[Compiler](options_compiler.md) , [Compiler Chip](options_compiler_chip.md) , [Compiler Output](options_compiler_output.md) , [Compiler Communication](options_compiler_communication.md) , [Compiler I2C,SPI,1WIRE](options_compiler_i2c__spi__1wire.md) , [Compiler LCD](options_compiler_lcd.md) , [Communication](options_communication.md) , [Environment](options_environment.md) , [Simulator](options_simulator.md) , [Programmer](options_programmer.md) , [Printer](options_printer.md), [Options Select Settings File](options_select_settings_file.md)

Window

[Cascade](window_cascade.md) , [Tile](window_tile.md), [Arrange Icons](window_arrange_icons.md), [Minimize All](window_minimize_all.md), [Maximize All](windows_maximize_all.md) , [Tile Vertically](window_tile_vertically.md)

Help

[About](help_about.md) , [Index](help_index.md), [MCS Forum](help_mcs_forum.md), [Support](helpsupport.md), [Knowledge Base](helpknowledgebase.md) , [Credits](help_credits.md) , [Wiki](help_wiki.md) , [Update](help_update.md)

[Editor Keys](bascom_editor_keys.md)

[BASCOM Developing Order](developing_order.md)

[BASCOM and Memory](memory_usage.md)

[BASCOM Error codes](error_codes.md)

[Reserved Words](reserved_words.md)

BASCOM and Hardware

[Additional Hardware](additional_hardware.md)

[AVR Internal Hardware](avr_internal_hardware.md)

[AVR Internal Hardware TIMER0](avr_internal_hardware_timer0.md)

[AVR Internal Hardware TIMER1](avr_internal_hardware_timer1.md)

[AVR Internal Hardware Watchdog timer](avr_internal_hardware_watchdog_timer.md)

[AVR Internal Hardware PORT B](avr_internal_hardware_port_b.md)

[AVR Internal Hardware PORT D](avr_internal_hardware_port_d.md)

[AVR Internal Registers](avr_internal_registers.md)

[Adding XRAM](adding_xram.md)

[Adding SRAM 4-port Non Multiplexed](adding_sram_4_port_non_multipl.md)

[Attaching an LCD display](attaching_an_lcd_display.md)

[Using the UART](uart.md)

[Using RS485](using_rs485.md)

[Using the I2C protocol](using_the_i2c_protocol.md)

[Using the 1 Wire protocol](using_the_1_wire_protocol.md)

[Using the SPI protocol](using_the_spi_protocol.md)

[Using USI](using_usi_universal_serial_int.md)

[Power Up](power_up.md)

[ATXMEGA](atxmega.md)

[XTINY](xtiny.md)

[MEGAX](megax.md)

[AVRX](avrx.md)

[Statements and Hardware Resources](statements_and_hardware_resour.md)

Reference Designs

[EM4095 RFID Reader](em4095_rfid_reader.md)

Misc

[Assembly Mnemonics](assembler_mnemonics.md)

[International Resellers](international_resellers.md)

[Language Fundamentals](language_fundamentals.md)

[Mixing BASIC with assembly](mixing_asm_and_basic.md)

[Supported Programmers](supported_programmers.md)

[BASCOMP, command line compiler](bascomp.md)

ASM Libs and Add-Ons

Library | Category  
---|---  
[AVR-DOS](avr_dos_file_system.md) | AVR-DOS  
[BCCARD](bccard.md) | BCCARD  
[EXTENDED I2C](extendedi2c.md) | I2C  
[FM24C16](fm24c16.md) | I2C  
[FM24C64_256](fm24c64_256.md) | I2C  
[I2C MULTIBUS](i2c_multibus.md) | I2C  
[I2CV2](i2cv2.md) | I2C  
[I2C_TWI-MULTI](i2c_twi_multi.md) | I2C TWI  
[I2C_USI](i2c_usi.md) | I2C/USI  
[I2CSLAVE](i2cslave.md) | I2C  
[I2C_USI_SLAVE](i2c_usi_slave.md) | I2C/USI  
[FM25C256](fm25c256.md) | SPI  
[HEXVAL](hexval2.md) | Conversion  
[MCSBYTE](mcsbyte.md) | Conversion  
[MCSBYTEINT](mcsbyteint.md) | Conversion  
[MODBUS](modbus_slaveserver.md) | MODBUS  
[LCD4BUSY](lcd4busy.md) | LCD  
[LCD_RX1602A5](lcd_rx1602a5.md) | LCD  
[LCD4](lcd4_lib.md) | LCD  
[LCD4E2](lcd4e2.md) | LCD  
[lcd4_anypin_oled_RS0010](lcd4_anypin_oled_rs0010.md) | LCD  
[GLCD](glcd.md) | LCD  
[GLCDSED](glcdsed.md) | LCD  
[PCF8533](pcf8533.md) | LCD  
[LCD-EPSON](lcd_epson.md) | LCD  
[GLCDST7565R](glcdr7565r.md) | LCD  
[GLCDSSD1325_96x64](glcdssd1325_96x64.md) | LCD  
[GLCDEADOGMXL240-7-I2C](glcdeadogmxl240_7_i2c.md) | LCD  
[GLCDdSSD1306-I2C](glcddssd1306_i2c.md) | LCD  
[FT800](ft800.md) | LCD  
[PULSEIN](pulsein2.md) | IO  
[PS2 Lib](ps2mouse_emulator.md) | PS2  
[AT_EMULATOR](at_emulator.md) | PS2  
[PS2MOUSE_EMULATOR](ps2mouse_emulator.md) | PS2  
[DATETIME](datetime.md) | DATE TIME  
[EUROTIMEDATE](eurotimedate.md) | DATE TIME  
[SPISLAVE](spislave.md) | SPI  
[TCPIP](tcpip.md) | TCPIP  
[M128-1WIRE-PORTF](m128_1wire_portf.md) | 1WIRE  
[TVOUT](tvout.md) | VIDEO  
[USB](usb_add_on.md) | USB  
[RAINBOWBSC](rainbowbsc.md) | WS2812/RAINBOW  
[SERIN](serin2.md) | SERIAL  
[LCD_I2C_PCF8574](lcd_i2c_pcf8574.md) | LCD I2C PCF8574  
BIGBUF | SERIAL  
  
BASCOM Language Reference

-#-

[#IF](_if_else_endif.md) , [#ELSE](_if_else_endif.md) , [#ENDIF](_if_else_endif.md) , [#AUTOCODE](autocode.md)

-$-

[$ASM](asm.md) , [$BAUD](baud_1.md) , [$BAUD1](_baud1.md) , [$BIGSTRINGS](bigstrings.md), [$BGF](_bgf.md) , [$BOOT](_boot.md) , [$CRYSTAL](crystal_1.md) , [$DATA](data_1.md) , [$DBG](_dbg.md) , [$DEFAULT](default.md) , [$EEPLEAVE](_eepleave.md) , [$EEPROM](eeprom.md) , [$EEPROMHEX](_eepromhex.md) , [$EEPROMSIZE](eepromsize.md), [$EXTERNAL](external.md) , [$HWSTACK](_hwstack.md) , [$INC](_inc.md) , [$INCLUDE](include.md) , [$INITMICRO](_initmicro.md) , [$LCD](lcd_1.md) , [$LCDRS](lcdrs.md) , [$LCDPUTCTRL](lcdputctrl.md) , [$LCDPUTDATA](lcdputdata.md) , [$LCDVFO](_lcdvfo.md) , [$LIB](lib.md) , [$LOADER](loader.md) , [$LOADERSIZE](loadersize.md) , [$MAP](_map.md) , [$NOCOMPILE](nocompile.md) , [$NOINIT](_noinit.md) , [$NORAMCLEAR](_noramclear.md) , [$NORAMPZ](norampz.md) , [$PROJECTTIME](_projecttime.md), [$PROG](_prog.md) , [$PROGRAMMER](programmer.md) , [$REGFILE](regfile.md) , [$RESOURCE](resource.md) , [$ROMSTART](_romstart.md) [$SERIALINPUT](serialinput.md), [$SERIALINPUT1](_serialinput1.md) , [$SERIALINPUT2LCD](serialinput2lcd.md) , [$SERIALOUTPUT](serialoutput.md) , [$SERIALOUTPUT1](_serialoutput1.md) , [$SIM](sim.md) , [$SWSTACK](_swstack.md) , [$TIMEOUT](_timeout.md) , [$TINY](_tiny.md) , [$WAITSTATE](_waitstate.md) , [$XRAMSIZE](xramsize.md) , [$XRAMSTART](xramstart.md) , [$XA](xa.md) , [$CRYPT](crypt.md) , [$NOTRANSFORM](notransform.md) , [$FILE](file.md) , [$AESKEY](_aeskey.md) , [$XTEAKEY](xteakey.md) , [$STACKDUMP](stackdump.md) ,[ $NOFRAMEPROTECT](noframeprotect.md) ,[ $FRAMEPROTECT](frameprotect.md) , [$FORCESOFTI2C](forcesofti2c.md) , [$REDUCEIVR](_aeskey.md) , [$BOOTVECTOR](bootvector.md)

-1-

[1WRESET](1wreset.md) , [1WREAD](1wread.md) , [1WWRITE](1wwrite.md) , [1WSEARCHFIRST](1wsearchfirst.md) , [1WSEARCHNEXT](1wsearchnext.md) ,[1WVERIFY](1wverify.md) , [1WIRECOUNT](1wirecount.md)

-A-

[ABS](abs.md) , [ADR](adr___adr2.md), [ADR2](adr___adr2.md) , [ACOS](acos.md) , [ALIAS](alias.md) , [ASC](asc.md) , [ASIN](asin.md) , [ATN](atn.md) , [ATN2](atn2.md) , [AESENCRYPT](aesencrypt.md) , [AESDECRYPT](aesdecrypt.md) , [AND](and.md)

-B-

[BASE64DEC](base64dec.md) , [BASE64ENC](base64enc.md) , [BAUD](baud_2.md) , [BAUD1-BAUDx](baud1.md), [BCD](bcd.md) , [BIN](bin.md) , [BITS](bits.md) , [BINVAL](binval.md) , [BIN2GRAY](bin2gray.md) , [BITWAIT](bitwait.md) , [BYVAL](byval.md) , [BOX](box.md), [BOXFILL](boxfill.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [BUFSPACE](bufspace.md) , [BREAK](break.md)

-C-

[CALL](call.md) ,[CHARPOS](charpos.md), [CIRCLE](circle.md) , [CHECKFLOAT](checkfloat.md), [CHECKSUM](checksum.md) , [CHECKSUMXOR](checksum.md), [CHR](chr.md) , [CLEAR](clear.md) , [CLS](cls.md) , [CLOCKDIVISION](clockdivision.md) , [CLOSE](close.md) , [CLOSESOCKET](socketclose.md) , [CPEEKH](cpeekh.md) , [CONST](const.md) , [COS](cos.md) , [COSH](cosh.md) , [CRC8](crc8.md) , [CRC16](crc16.md) , [CRC32](crc32.md) , [CRC16UNI](crc16uni.md) , [CRYSTAL](crystal_2.md) , [CPEEK](cpeek.md) , [CPEEKH](cpeekh.md) , [CURSOR](cursor.md) , [CANBAUD](canbaud.md), [CANRESET](canreset.md), [CANCLEARMOB](canclearmob.md), [CANCLEARALLMOBS](canclearallmobs.md), [CANSEND](cansend.md), [CANRECEIVE](canreceive.md) , [CANID](canid.md), [CANSELPAGE](canselpage.md), [CANGETINTS](cangetints.md) , [CHDIR](chdir.md) , [CMD8](cmd8.md) , [CMD16](cmd16.md) , [CMD32](cmd32.md) , [CLEARATTR](clearattr.md) , [COMPARE](compare.md) , [EDMA](config_edma.md) , [EDMAx](config_edmax.md) , [CRCMB](crcmb.md) ,[CONTINUE](continue.md) , [CRC8UNI](crc8uni.md) , 

[CONFIG](config.md) , 

[CONFIG 1WIRE](config_1wire.md) , [CONFIG ACAX|ACBX](config_acxx.md) , [CONFIG ACI](config_aci.md) , [CONFIG ACx](config_acix.md) , [CONFIG ADC](config_adc.md) , [CONFIG ADCA|ADCB](config_adca.md) , [CONFIG ADC0|ADCx](config_adc0_adcx.md) , [CONFIG ATEMU](config_atemu.md) , 

[CONFIG BASE](config_base.md) , [CONFIG BCCARD](config_bccard.md) , [CONFIG CANBUS](config_canbusmode.md) , [CONFIG CANMOB](config_canmob.md) , [CONFIG CLOCK](config_clock.md) , [CONFIG CLOCKDIV](config_clockdiv.md) , [CONFIG COM1](config_com1.md) , [CONFIG COM2](config_com2.md) , [CONFIG COMx](configcomx.md) , 

[CONFIG DACA|DACB](config_dacx.md) , [CONFIG DACX](config_dacx2.md) , [CONFIG DATE](config_date.md) , [CONFIG DCF77](configdcf77.md) , [CONFIG DEBOUNCE](config_debounce.md) , [CONFIG DMA](config_dma.md) , [CONFIG DMACHx](config_dmachx.md) , [CONFIG DMXSLAVE](config_dmxslave.md) , [CONFIG DP](config_dp.md) , 

[CONFIG EDMA](config_edma.md) , [CONFIG EDMAx](config_edmax.md) , [CONFIG EEPROM](config_eeprom.md) , [CONFIG ERROR](config_error.md) , [CONFIG EVENT_SYSTEM](config_event_system.md) (xmega) , [CONFIG EVENT_SYSTEM](config_event_system_xtiny.md) (xtiny) , [CONFIG EXTENDED_PORT](config_extended_port.md) ,

[CONFIG FT800](config_ft800.md), [CONFIG GRAPHLCD](config_graphlcd.md) , [CONFIG HITAG](config_hitag.md) , [CONFIG I2CBUS](config_i2cbus.md) , [CONFIG I2CDELAY](config_i2cdelay.md) , [CONFIG I2CSLAVE](config_i2cslave.md) , [CONFIG INPUT](configinput.md) , [CONFIG INPUTBIN](config_inputbin.md) , [CONFIG INTx](config_intx.md) , [CONFIG INTVECTORSELECTION](config_intvectorselection.md) , 

[CONFIG KBD](config_kbd.md) , [CONFIG KEYBOARD](config_kbd.md) , [CONFIG LCD](config_lcd.md) , [CONFIG LCDBUS](config_lcdbus.md) , [CONFIG LCDMODE](config_lcdmode.md) , [CONFIG LCDPIN](config_lcdpin.md) , 

[CONFIG OPAMP](config_opamp.md), [CONFIG OSC](config_osc.md) XMEGA , [CONFIG OSC](config_osc_xtiny.md) XTINY , [CONFIG PORT](config_port.md) , [CONFIG PORT_MUX](config_port_mux.md) , [CONFIG POWERMODE](config_powermode.md) , [CONFIG POWER_REDUCTION](config_power_reduction.md) , [CONFIG PRIORITY](config_priority.md) XMEGA , [CONFIG PRIORITY](config_priority_xtiny.md) XTINY , 

[CONFIG PRINT](configprint.md) , [CONFIG PRINTBIN](config_printbin.md) , [CONFIG PS2EMU](config_ps2emu.md) , [CONFIG RAINBOW](config_rainbow.md) , [CONFIG RC5](config_rc5.md) , [CONFIG RC5SEND](config_rc5send.md), [CONFIG RND](config_rnd.md) , 

[CONFIG SERIALIN](config_serialin.md) , [CONFIG SERIALIN1](config_serialin.md) , [CONFIG SERIALIN2](config_serialin.md) , [CONFIG SERIALIN3](config_serialin.md) , [CONFIG SERIALOUT](config_serialout.md) , [CONFIG SERIALOUT1](config_serialout.md) , [CONFIG SERIALOUT2](config_serialout.md) , [CONFIG SERIALOUT3](config_serialout.md) , [CONFIG SERVOS](config_servos.md) , [CONFIG SHIFTIN](config_shiftin.md) , 

[CONFIG SINGLE](configsingle.md) , [CONFIG SDA](config_sda.md) , [CONFIG SCL](config_scl.md) , [CONFIG SPI](config_spi.md) , [CONFIG SPIx](config_spix.md) , [CONFIG SUBMODE](config_submode.md) , [CONFIG SYSCLOCK](config_sysclock.md) XMEGA ,[CONFIG SYSCLOCK](config_sysclock_xtiny.md) XTINY , 

[CONFIG TCXX](config_tcxx.md) , [CONFIG TCA0](config_tca0.md) , [CONFIG TCB0, TCB1](config_tcb0_tcb1.md) , [CONFIG TCD0](config_tcd0.md) , [CONFIG TCPIP](config_tcpip.md) , [CONFIG TWI](config_twi.md) , [CONFIG TWISLAVE](config_twislave.md) , [CONFIG TWIxSLAVE](config_twixslave.md) , [CONFIG TIMER0](config_timer0.md) , [CONFIG TIMER1](config_timer1.md) , [CONFIG TIMER2 and 3](config_timer2.md) , 

[CONFIG USB](config_usb.md), [CONFIG USI](config_usi.md) , [CONFIG VPORT](config_vport.md) , [CONFIG VREF](config_vref.md) , [CONFIG VREGPWR](config_vregpwr.md) , [CONFIG WATCHDOG](config_watchdog.md) , [CONFIG WAITSUART](config_waitsuart.md) , [CONFIG X10](config_x10.md) , [CONFIG XPIN](config_xpin.md) , [CONFIG XRAM](configxram.md) , [CONFIG ZCDx](config_zcdx.md) , [CONFIG VARPTRMODE](config_varptrmode.md)

-D-

[DATE](date.md) , [DATA](data_2.md) , [DATE$](date_.md) , [DBG](dbg.md) , [DEBOUNCE](debounce.md) , [DECR](decr.md) , [DAYOFWEEK](dayofweek.md) , [DAYOFYEAR](dayofyear.md) , [DriveGetIdentity](drivegetidentity.md) , [DriveWriteSector](drivewritesector.md) , [DriveReadSector](drivereadsector.md) ,[DEBUG](debug.md), [DECLARE FUNCTION](declare_function.md) , [DECLARE SUB](declare_sub.md) , [DEFXXX](defxxx.md) , [DEFLCDCHAR](deflcdchar.md) , [DEG2RAD](deg2rad.md) , [DELAY](delay.md) , [DIM](dim.md) , [DISABLE](disable.md) , [DISPLAY](display.md) , [DO-LOOP](do_loop.md) , [DTMFOUT](dtmfout.md) , [DISKFREE](diskfree.md) , [DIR](dir.md) , [DriveReset](drivereset.md) , [DriveInit](driveinit.md) , [DELCHAR](delchar.md) , [DELCHARS](delchars.md) , [DESENCRYPT](desencrypt.md), [DESDECRYPT](desdecrypt.md)

-E-

[ECHO](echo.md) , [ELSE](else.md) , [ENABLE](enable.md) , [END](end.md) , [EXIT](exit.md) , [EXP](exp.md) , [EOF](eof.md) , [ENCODER](encoder.md)

-F-

[FIX](fix.md) , [FORMAT](format.md) , [FOR-NEXT](for_next.md) , [FOURTHLINE](fourthline.md) , [FRAC](frac.md) , [FUSING](fusing.md) , [FLUSH](flush.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [FILELEN](filelen.md) , [FLIP](flip2.md)

-G-

[GET](get.md) , [GETADC](getadc.md) , [GETKBD](getkbd.md) , [GETATKBD](getatkbd.md) , [GETRC](getrc.md) , [GETRC5](getrc5.md) , [GLCDCMD](glcdcmd.md) , [GLCDDATA](glcddata.md) , [GOSUB](gosub.md) , [GOTO](goto.md) , [GRAY2BIN](gray2bin.md) , [GETDSTIP](getdstip.md) , [GETDSTPORT](getdstport.md) , [GETSOCKET](getsocket.md) , [GETTCPREGS](gettcpregs.md) , [GETREG](getreg.md) , [GETATTR](getattr.md)

-H-

[HEX](hex.md) , [HEXVAL](hexval.md) , [HIGH](high.md) , [HIGHW](highw.md) , [HOME](home.md)

-I-

[I2CINIT](i2cinit.md) , [I2CRECEIVE](i2creceive.md) , [I2CSEND](i2csend.md) , [I2CSTART, I2CREPSTART, I2CSTOP,I2CRBYTE,I2CWBYTE](i2start_i2cstop__i2crbyte__i2cwbyte.md) , [IDLE](idle.md) , [IF-THEN-ELSE-END IF](if_then_else_end_if.md) , [INCR](incr.md) , [INITLCD](initlcd.md) , [INKEY](inkey.md) , [INP](inp.md) , [INPUTBIN](inputbin.md) , [INPUTHEX](inputhex.md) , [INPUT](input.md) , [INSTR](instr.md) , [INT](int.md) , [ISCHARWAITING](ischarwaiting.md) , [INITFILESYSTEM](initfilesystem.md) , [IP2STR](ip2str.md) , [INSERTCHAR](insertchar.md)

-J-

[JOIN](join.md)

-K-

[KILL](kill.md)

-L-

[LCASE](lcase.md) , [LCD](lcd_2.md) , [LCDAT](lcdat.md) , [LCDCMD](lcdcmd.md), [LCDDATA](lcddata.md), [LCDAUTODIM](lcdautodim.md) , [LEFT](left.md) , [LEN](len.md) , [LINE](line.md) , [LOAD](load.md) , [LOADADR](loadadr.md) , [LOADLABEL](loadlabel.md) , [LOADWORDADR](loadwordadr.md) , [LOCAL](local.md) , [LCDCONTRAST](lcdcontrast.md) , [LOCATE](locate.md) , [LOG](log.md) , [LOG10](log10.md) , [LOOKDOWN](lookdown.md) , [LOOKUP](lookup.md) , [LOC](loc.md) , [LOF](lof.md) , [LOOKUPSTR](lookupstr.md) , [LOW](low.md) , [LOWERLINE](lowerline.md) , [LTRIM](ltrim.md) , [LINE INPUT](line_input.md) , [LCDFONT](lcdfont.md)

-M-

[MACRO](macro.md) , [MAKEBCD](makebcd.md) , [MAKEDEC](makedec.md) , [MAKEMODBUS](makemodbus.md) , [MAKEINT](makeint.md) , [MID](mid.md) , [MAX](max.md) , [MIN](min.md) , [MOD](mod.md) , [MKDIR](mkdir.md) , [MANCHESTERDEC](manchesterdec.md), [MANCHESTERENC](manchesterenc.md) , [MEMFILL](memfill.md)

-N-

[NAME](name.md) , [NBITS](nbits.md) , [NOT](not.md) , [NOP](nop.md)

-O-

[ON INTERRUPT](on_interrupt.md) ,[ON VALUE](on_value.md) , [OPEN](open.md) , [OUT](out.md) , [OR](or.md)

-P-

[PEEK](peek.md) , [POKE](poke.md) , [POPALL](popall.md) , [POWER mode](power_mode.md) , [POWER](power.md) , [POWERDOWN](powerdown.md) , [POWERSAVE](powersave.md) , [PRINT](print.md) , [PRINTBIN](printbin.md) , [PSET](pset.md) , [PULSEIN](pulsein.md) , [PS2MOUSEXY](ps2mousexy.md) , [PUT](put.md) , [PULSEOUT](pulseout.md) , [PUSHALL](pushall.md)

-Q-

[QUOTE](quote.md) , [QSIN](qsin.md) , [QCOS](qcos.md)

-R-

[RAD2DEG](rad2deg.md) , [RC5SEND](rc5send.md) , [RC6SEND](rc6send.md) , [READ](read.md) , [READEEPROM](readeeprom.md) , [READHITAG](readhitag.md) , [READMAGCARD](readmagcard.md) , [REM](rem.md) , [REPLACECHARS](replacechars.md) , [RESET](reset.md) , [RESTORE](restore.md) , [RETURN](return.md) , [RIGHT](right.md) , [RND](rnd.md) , [ROTATE](rotate.md) , [ROUND](round.md) [RTRIM](rtrim.md) , [READSIG](readsig.md) , [RMDIR](rmdir.md) , [RGB8TO16](rgb8to16.md) , 

[RB_ADDCOLOR](rb_addcolor.md), [RB_ANDCOLOR](rb_andcolor.md), [RB_ORCOLOR](rb_orcolor.md), [RB_SUBCOLOR](rb_subcolor.md), [RB_CLEARSTRIPE](rb_clearstripe.md) , [RB_CLEARCOLORS](rb_clearcolors.md) , [RB_FILL](rb_fill.md) , [RB_FILLCOLORS](rb_fillcolors.md) , [RB_FILLSTRIPE](rb_fillstripe.md) , [RB_SELECTCHANNEL](rb_selectchannel.md), [RB_SEND](rb_send.md), [RB_SETCOLOR](rb_setcolor.md) , [RB_SWAPCOLOR](rb_swapcolor.md) , [RB_ROTATELEFT](rb_rotateleft.md), [RB_ROTATERIGHT](rb_rotateright.md), [RB_SHIFTLEFT](rb_shiftleft.md), [RB_SHIFTRIGHT](rb_shiftright.md) , [RB_CHANGEPIN](rb_changepin.md) , [RB_SETTABLECOLOR](rb_settablecolor.md) , [RB_GETCOLOR](rb_getcolor.md) , [RB_LOOKUPCOLOR](rb_lookupcolor.md) , [RB_COLOR](rb_color.md) , [RB_COPY](rb_copy.md) , [REDO](redo.md)

-S-

[SENDSCAN](sendscan.md) , [SENDSCANKBD](sendscankbd.md) , [SELECT CASE - END SELECT](select_case_end_select.md) , [SET](set.md) , [SETFONT](setfont.md) , [SERIN](serin.md) , [SEROUT](serout.md) , [SECOFDAY](secofday.md) , [SECELAPSED](secelapsed.md) , [SYSDAY](sysday.md) , [SYSSEC](syssec.md) , [SYSSECELAPSED](syssecelapsed.md) , [SETTCP](settcp.md) , [SGN](sgn.md) , [SHIFT](shift.md) , [SHIFTCURSOR](shiftcursor.md) , [SHIFTIN](shiftin.md) , [SHIFTOUT](shiftout.md) , [SHIFTLCD](shiftlcd.md) , [SHOWPIC](showpic.md) , [SHOWPICE](showpice.md) , [SIN](sin.md) , [SINH](sinh.md) , [SONYSEND](sonysend.md) , [SOUND](sound.md) , [SPACE](space.md) , [SPC](spc.md) , [SPIIN](spiin.md) , [SPIINIT](spiinit.md) , [SPIMOVE](spimove.md) , [SPIOUT](spiout.md) , [SQR](sqr.md) , [START](start.md) , [STCHECK](stcheck.md) , [STOP](stop.md) , [STR](str.md) , [STRING](string.md) , [SUB](sub.md) , [SOCKETSTAT](socketstat.md) , [SOCKETCONNECT](socketconnect.md) , [SOCKETLISTEN](socketlisten.md) , [SEEK](seek.md) , [SWAP](swap.md) , [SPLIT](split.md) , [SETTCPREGS](settcpregs.md) , [SETIPPROTOCOL](setipprotocol.md) , [SORT](sort.md) , [STR2DIGITS](str2digits.md) ,[SETREG](setreg.md) , [SNTP](sntp.md) , [SOCKETCLOSE](socketclose.md), [SOCKETDISCONNECT](socketdisconnect.md) , [SETATTR](setattr.md) , [SPI1IN](spiin.md) , [SPI1INIT](spiinit.md) , [SPI1MOVE](spimove.md) , [SPI1OUT](spiout.md) , [SIZEOF](sizeof.md)

-T-

[TIME](time.md) , [TCPWRITE](tcpwrite.md) , [TCPWRITESTR](tcpwritestr.md) , [TCPREAD](tcpread.md) , [TCPCHECKSUM](tcpchecksum.md) , [TAN](tan.md) , [TANH](tanh.md) , [THIRDLINE](thirdline.md) , [TIME$](time_.md) , [TRIM](trim.md) , [TOGGLE](toggle.md) , [TCPREADHEADER](tcpreadheader.md) , [TYPE](type.md)

-U-

[UCASE](ucase.md) , [UPPERLINE](upperline.md) , [UDPREAD](udpread.md) , [UDPWRITE](udpwrite.md) , [UDPWRITESTR](udpwritestr.md) , [UDPREADHEADER](udpreadheader.md), [URL2IP](url2ip.md)

-V-

[VAL](val.md) , [VARPTR](varptr.md) , [VER](ver.md) , [VERSION](version.md)

-W-

[WAIT](wait.md) , [WAITKEY](waitkey.md) , [WAITMS](waitms.md) , [WAITUS](waitus.md) , [WRITE](write.md) , [WHILE-WEND](while_wend.md) , [WRITEEEPROM](writeeeprom.md) , [WR8](wr8.md) , [WR16](wr16.md) , [WR32](wr32.md) , [WRITEDAC](writedac.md)

-X-

[X10DETECT](x10detect.md) , [X10SEND](x10send.md) , [XTEADECODE](xteadecode.md) , [XTEAENCODE](xteaencode.md) , [XOR](xor.md)

---

## Tag

Action

Attach the tag value for the following graphics objects drawn on the screen.

Syntax

Tag s

Remarks

s | Tag value. Valid value range is from 1 to 255  
---|---  
  
The initial value of the tag buffer of the FT800 is specified by command [ClearTag](cleartag.md) and taken effect by command [Clear_B](clear_b.md). 

Tag command can specify the value of the tag buffer of the FT800 that applies to the graphics objects when they are drawn

on the screen. This Tag value will be assigned to all the following objects, unless the [TagMask](tagmask.md) command is used to disable it.

Once the following graphics objects are drawn, they are attached with the tag value successfully. 

When the graphics objects attached with the tag value are touched, the register REG_TOUCH_TAG will be updated 

with the tag value of the graphics object being touched.

If there is no Tag commands in one display list, all the graphics objects rendered by the display list will report tag value as 255

in REG_TOUCH_TAG when they were touched.

See also

[ClearTag](cleartag.md), [TagMask](tagmask.md)

---

## TagMask

Action

Control the writing of the tag buffer.

Syntax

TagMask mask

Remarks

mask | Allow updates to the tag buffer. The initial value is one (1) and it means the tag buffer of the FT800 is updated with the value given by the [Tag](tag.md) command.  Therefore, the following graphics objects will be attached to the tag value given by the TAG command. The value zero (0) means the tag buffer of the FT800 is set as the default value, rather than the value given by [Tag](tag.md) command in the display list.  
---|---  
  
Every graphics object drawn on screen is attached with the tag value which is defined in the FT800 tag buffer. 

The FT800 tag buffer can be updated by [Tag](tag.md) command.

The default value of the FT800 tag buffer is determined by [ClearTag](cleartag.md) and [Clear_B](clear_b.md) commands. 

If there is no [ClearTag](cleartag.md) command present in the Display List, the default value in tag buffer shall be 0.

[TagMask](tagmask.md) command decides whether the FT800 tag buffer takes the value from the default value of the FT800 tag buffer or

the [Tag](tag.md) command of the Display List.

See also

[Tag](tag.md), [ClearTag](cleartag.md), [StencilMask](stencilmask.md), [ColorMask](colormask.md)

---

## TAN

Action

Returns the tangent of a float

Syntax

var = TAN( source )

Remarks

Var | A numeric variable that is assigned with tangent of variable source.  
---|---  
Source | The single or double variable to get the tangent of.  
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [ATN](atn.md) , [COS](cos.md) , [SIN](sin.md) , [ATN2](atn2.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim S As Single , X As Single

```
S = 0.5 : X = Tan(s) : Print X ' prints 0.546302195

S = 0.5 : X = Sin(s) : Print X ' prints 0.479419108

S = 0.5 : X = Cos(s) : Print X ' prints 0.877588389

End

---

## TANH

Action

Returns the hyperbole of a floating point variable

Syntax

var = TANH( source )

Remarks

Var | A numeric variable that is assigned with hyperbole of variable source.  
---|---  
Source | The single or double variable to get the hyperbole of.  
  
All trig functions work with radians. Use deg2rad and rad2deg to convert between radians and angles.

See Also

[RAD2DEG](rad2deg.md) , [DEG2RAD](deg2rad.md) , [ATN](atn.md) , [COS](cos.md) , [SIN](sin.md) , [SINH](sinh.md) , [COSH](cosh.md)

Example

[Show sample](fp_trig.md)

---

## THIRDLINE

Action

Reset LCD cursor to the third line.

Syntax

THIRDLINE

Remarks

NONE

See also

[UPPERLINE](upperline.md) , [LOWERLINE](lowerline.md) , [FOURTHLINE](fourthline.md)

Example

Dim A As Byte

A = 255

Cls

Lcd A

Thirdline

Lcd A

Upperline

End

---

## TIME

Action

Returns a time-value (String or 3 Byte for Second, Minute and Hour) depending of the Type of the Target

Syntax

bSecMinHour = Time(lSecOfDay)

bSecMinHour = Time(lSysSec)

bSecMinHour = Time(strTime)

strTime = Time(lSecOfDay)

strTime = Time(lSysSec)

strTime = Time(bSecMinHour)

Remarks

bSecMinHour | A BYTE â variable, which holds the Second-value followed by Minute (Byte) and Hour (Byte)  
---|---  
strTime | A Time â String in Format âhh:mm:ss"  
lSecOfDay | A LONG â variable which holds Second Of Day (SecOfDay)  
lSysSec | A LONG â variable which holds System Second (SysSec)  
  
Converting to a time-string:

The target string strTime must have a length of at least 8 Bytes, otherwise SRAM after the target-string will be overwritten.

Converting to Softclock format (3 Bytes for Second, Minute and Hour):

Three Bytes for Seconds, Minutes and Hour must follow each other in SRAM. The variable-name of the first Byte, that one for Second must be passed to the function.

![notice](notice.jpg) Time not to be confused with Time$ !

See also

[Date and Time Routines](datetime.md) , [SECOFDAY](secofday.md), [SYSSEC](syssec.md)

Partial Example

```vb
Enable Interrupts

Config Clock = Soft

Dim Strtime As String * 8

Dim Bsec As Byte , Bmin As Byte AT Bsec + 1 , Bhour As Byte AT Bmin +1

Dim Lsecofday As Long

Dim Lsyssec As Long

' Example 1: Converting defined Clock - Bytes (Second / Minute / Hour) to Time - String

```
Bsec = 20 : Bmin = 1 : Bhour = 7

Strtime = Time(bsec)

```vb
Print "Time values: Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour ; " converted to string " ; Strtime

' Time values: Sec=20 Min=1 Hour=7 converted to string 07:01:20

' Example 2: Converting System Second to Time - String

```
Lsyssec = 123456789

Strtime = Time(lsyssec)

```vb
Print "Time of Systemsecond " ; Lsyssec ; " is " ; Strtime

' Time of Systemsecond 123456789 is 21:33:09

' Example 3: Converting Second of Day to Time - String

```
Lsecofday = 12345

Strtime = Time(lsecofday)

```vb
Print "Time of Second of Day " ; Lsecofday ; " is " ; Strtime

' Time of Second of Day 12345 is 03:25:45

' Example 4: Converting System Second to defined Clock - Bytes (Second / Minute / Hour)

```
Lsyssec = 123456789

Bsec = Time(lsyssec)

```vb
Print "System Second " ; Lsyssec ; " converted to Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour

' System Second 123456789 converted to Sec=9 Min=33 Hour=21

' Example 4: Converting Second of Day to defined Clock - Bytes (Second / Minute / Hour)

```
Lsecofday = 12345

Bsec = Time(lsecofday)

```vb
Print "Second of Day " ; Lsecofday ; " converted to Sec=" ; Bsec ; " Min=" ; Bmin ; " Hour=" ; Bhour

' Second of Day 12345 converted to Sec=45 Min=25 Hour=3

```

---

## TIME$

Action

Internal variable that holds the time.

Syntax

TIME$ = "hh:mm:ss"

var = TIME$

Remarks

The TIME$ variable is used in combination with the CONFIG CLOCK and CONFIG DATE directive.

See [CONFIG CLOCK](config_clock.md) statement for further information. In this interrupt routine the _Sec, _Min and _Hour variables are updated. The time format is 24 hours format.

When you assign TIME$ to a string variable these variables are assigned to the TIME$ variable.

When you assign the TIME$ variable with a constant or other variable, the _sec, _Hour and _Min variables will be changed to the new time.

The only difference with VB is that all digits must be provided when assigning the time. This is done for minimal code. You can change this behavior of course.

![important](important.jpg) Do not confuse TIME$ with the TIME function !

ASM

The following asm routines are called from mcs.lib.

When assigning TIME$ : _set_time (calls _str2byte)

When reading TIME$ : _make_dt (calls _byte2str)

See also

[DATE$](date_.md) , [CONFIG CLOCK](config_clock.md) , [CONFIG DATE](config_date.md)

Example

See the sample of [DATE$](date_.md)

---

## TOGGLE

Action

Toggles(inverts) the state of an output pin or bit/Boolean variable. When used on a numeric variable, all bits in the variable are inverted.

Syntax

```vb
TOGGLE pin

TOGGLE var

```
Remarks

pin | Any port pin like PORTB.0 or boolean variable. A port pin must be configured as an output pin before TOGGLE will have effect.  
---|---  
var | A numeric variable like byte, word, integer or long. When you invert a byte, all bits of that byte will be inverted.   
  
With TOGGLE you can simply invert the output state of a port pin.

When the pin is driving a relay for example and the relay is OFF, one TOGGLE statement will turn the relays ON. Another TOGGLE will turn the relays OFF again.

When TOGGLE is used with a variable of the type Byte, Word, Integer or Long, all bits in the variable are toggled. It has the same effect as using the EXOR boolean operand with $FF, $FFFF or $FFFFFFFF

Example:

Toggle Var_byte has the same effect as

Var_byte = Var_byte XOR &HFF

New AVR chips have an enhanced port architecture which allow a toggle of the PORT by setting the PIN register to 1. The DAT files have a setting under the [DEVICE] section named NEWPORT.

When the value is 1, the PIN register will be set to toggle the PORT pin. When the NEWPORT value is set to 0, an XOR will be used to toggle the port pin.

TOGGLE can also be used on numeric variables. It will invert all bits in the variable. It has the same effect as NOT.

var = NOT var ' invert all bits

See also

[CONFIG PORT](config_port.md)

ASM

NONE

Example

```vb
'Bascom Help, Nov 16, 2008  
'ToggleNov15_2008.bas  
'Program example for use in the Help-files for  
' TOGGLE  
  
'Program has been compiled and tested using Bascom 1.11.9.2.003  
'Nard Awater, November 16, 2008  
  
  
$baud = 19200  
$crystal = 16000000  
$regfile = "m32def.dat"  
  
$hwstack = 40  
$swstack = 20  
$framesize = 20  
  
Dim B As Byte , W As Word , I As Integer , L As Long  
```
Led Alias Portb.0 'the anode of the LED connected to PortB.0, cathode with resistor (470 Ohm) to ground  
Config Pinb.0 = Output  
  
B = 0  
```vb
Reset Led  
'Toggle the led  
Do  
Print "Led is off "  
Waitms 500  
Toggle Led  
Print "Led is on "  
Waitms 500  
Toggle Led  
```
Incr B  
```vb
Loop Until B = 5  
  
'Toggle a bit in a variable  
```
B = &B11110000 'assign a new value: 240 in decimal  
```vb
Toggle B.0  
Print "B in decimal " ; B ' print it: result = 241 ; bit0 is set  
Print Bin(b) ' print it: result = 11110001  
Toggle B.0  
Print "B in decimal " ; B ' print it: result = 240 ; bit0 is reset  
Print Bin(b) ' print it: result = 11110000  
  
  
```
W = &H000F '15 in decimal  
I = &H00FF '255 in decimal  
L = &H00CC00DD '13369565 in decimal  
```vb
Toggle W  
Print "toggled W= " ; W ' print it: result = 65520  
Print Hex(w) ' print it: result = &HFFF0  
  
Toggle I  
Print "toggled I= " ; I ' print it: result = -256 ; two's complement !  
Print Hex(i) ' print it: result = &HFF00  
  
Toggle L  
Print "toggled L= " ; L ' print it: result = -13369566 ; two's complement !  
Print Hex(l) ' print it: result = &HFF33FF22  
  
End  


```

---

## Tools Batch Compile

The Batch Compiler is intended to compile multiple files.

Shortcut : CTRL+B

The Batch compile option was added for internal test usage. It is used by MCS to test the provided test samples.

The following window is shown :

![batch_compile](batch_compile.png)

There are a number of menu options.

File Load Batch

Load an earlier created and saved batch file list from disk.

File Save Batch

Save a created list of files to disk

When you have composed a list with various files it is a good idea to save it for later re usage.

File Save Result

Save the batch compile log file to disk. A file named batchresult.txt will be saved in the BASCOM application directory.

File Exit

Close window

Batch Compile

Compile the checked files. By default all files you added are checked. During compilation all files that were compiled without errors are unchecked.

![batchcomp2](batchcomp2.png)

This screen print shows that $inc.bas could not be compiled.

And that array.bas was not yet compiled.

Batch Add Files

Add files to the list. You can select multiple *.BAS files that will be added to the list.

Batch Add Dir

Add a directory to the list. All sub directories will be added too. The entire directory and the sub directories are searched for *.BAS files. They are all added to the list.

Batch Clear List

Clear the list of files.

Batch Clear Good

Remove the files that were compiled without error. You will keep a list with files that compiled with an error.

All results are shown in an error list at the bottom of the screen.

When you double click an item, the file will be opened by the editor.

See Also

[$NOCOMP](nocompile.md)

---

## TRIM

Action

Returns a copy of a string with leading and trailing blanks removed

Syntax

var = TRIM( org )

Remarks

Var | String that receives the result.  
---|---  
Org | The string to remove the spaces from  
  
TRIM is the same as an LTRIM() and RTRIM() call. It will remove the spaces on the left and right side of the string.

TRIM supports [$BIGSTRINGS](bigstrings.md)

See also

[RTRIM](rtrim.md) , [LTRIM](ltrim.md)

Partial Example

Dim S As String * 6

S =" AB "

```vb
Print Ltrim(s)

Print Rtrim(s)

Print Trim(s)

End

```

---

## TVOUT

The TVOUT add on is an add on that allows you to show text in color on a TV using the SCART connector.

The add on is free for personal use but for commercial use you need to buy a [license](<http://www.mcselec.com/index.php?page=shop.product_details&flypage=shop.flypage&product_id=261&category_id=6&option=com_phpshop&Itemid=1>) from the author (Graham Carnell).

![tvout_sample](tvout_sample.png)

This is a photo of the TV display function working on a flat panel LCD TV set

  
The actual display is perfectly straight, some distortion is seen here caused by the camera optics.  


The TV code is free for personal use but that support is not included. 

For commercial application you do need a license.

  
Company licence (unlimited copies for company use) now available for commercial use. Includes built & tested board, pre-programmed sample IC, TV generation software module including all pixel data which can be edited, plus full support from the developer by phone and e-mail.  
  
  
TV Code Features  
  
* Generates a 55 column color TV character display from an AVR MPU without any extra ICs  
* Connects via a standard SCART socket giving a sharp RGB output signal (not composite video)  
* Flexible RAM use - display RAM can be as large or small as needed  
* Completely interrupt driven software - transparent to user  
* Character pixel data can be edited or replaced by the user to allow custom characters  
  
The TV software can be customized to special user requirements (e.g. differing character sizes) but is time critical machine code.  
  
  
ICs supported  
  
This code is for the ATMega 48/88/168/328 ICs. A PCB is available for testing and / or production. The code can be ported to other ATMega AVR ICs which have 512 bytes or more RAM, and a clock of 16-20 MHz.   
  


BASCOM versions  
  
When using the company licence (which allows as many copies as you need) you will also require a registered copy of BASCOM to allow sufficient Flash program memory for most projects, as the binary include file for the TV output code is 2.5K, leaving only 1.5K of available space for your program out of the 4K maximum space allowed in the demo version of BASCOM.  
  
Orders

The software and hardware is made by Eximia Projects.   
Your order will be shipped from the UK, directly from the manufacturer.  
You will receive a binary include file.   
You will also receive a free development board PCB. This board is used in production and does not has an ISP connector. But it has a tested processor and all other components. All you need is to connect 5V and a TV and it will show a demo.   
  
Support is included in the cost of the development package. You can be assured that this support will smooth your way to producing a product with a TV output - you will not be left to struggle on your own.  
Before purchasing the package you might want to E-mail to check if the TV software will be compatible with your planned product, for example if there are many interrupts running or a heavy CPU load.  
  
If you want to use a different Atmel AT Mega IC to the one the software is designed for (AT Mega 48 / 88 / 168 / 328) the first step to take is to contact Eximia Projects and let me know what your design requires. I can then let you know what extra steps you will need to take (if any) to get the TV software to work with any specific hardware. You can contact Graham Carnell at gmcarnell@gmail.com

A PCB you can buy from Agricom : 

http://agricom.gr/eshop/product_info.php?cPath=26_38&products_id=986&language=en 

How to use BASCOM with the TV software module

The TV display is very simple to use from a programming point of view.

As it runs entirely within the ATMega chip, it uses internal RAM to hold the display data. This means that all you have to do to write to the display is write bytes to the RAM which is allocated to the TV screen area.

To start with you need to include the following 7 lines of code in

your BASCOM program:

```vb
On Oc2a Tvinterrupt Nosave

Goto Main

```
!.org $100

```vb
$inc Tvinterrupt , Nosize , "tvinc.bin"

Return

```
Main:

$include "tv.inc.bas"

You don't need to worry about these statements, you can just cut & paste this into your program and it will work.

After including these lines of code you can make the TV display work simply by moving bytes to the screen area in the internal RAM.

The amount of RAM used by the display is very flexible. It can be any number of bytes up to the maximum possible which is 12 lines of around 56 bytes per line, maximum 672 bytes.

The minimum number of bytes which can be used is just one! This byte would be the "End of Screen" code which has to be the very last byte of any screen. In fact, if the interrupt is disabled, then no RAM is needed at all, and you will also have full CPU usage until you enable the interrupt again. To disable the TV software all you need to do is:

DISABLE OC2A

this will halt the TV code and allow all RAM to be used by your application, then

ENABLE OC2A

to start the TV code again. You will need to make sure the screen RAM area contains sensible display data before enabling the interrupts.

You can use all of the on-chip RAM to do calculations and for temporary storage, you only need to free enough RAM as you need for the screen while it is actually displaying.

More Info

<http://sites.google.com/site/bascomtvhelp/>

PDF with detailed information can be downloaded from [here](<http://www.mcselec.com/images/stories/shop/tvout/BascomTV.pdf>)

Bascom TV FAQs  
  
Q: How can I add TV output to my BASCOM application?  
  
A: If you are using an ATMega48/88/168/328 everything is already set up for you to use. If you want to use another ATMega IC, you need to refer to the technical information and make sure that the IC you are using has enough hardware resources (CPU speed, SPI port, RAM etc). You can't just add TV output to any AVR chip - ATTiny ICs are not supported as the TV code uses the hardware multiply instruction, and only ATMega ICs have enough RAM.  
  
Q: What about low power applications?  
  
A: Whilst TV output is enabled, power consumption will be around the maximum given in the data sheet for the IC at the speed and voltage used. TV output should be disabled when not needed, then the IC can benefit from all the low power and sleep modes available. This would be relevant to any device which is normally in low power mode, but can have a TV attached to display data only when required.  
  
Q: What about CPU intensive applications?  
  
A: As explained in the previous Q/A about low power, the TV output can be switched off (by disabling the relevant interrupt) so the full CPU power is available, however most applications can easily run in the spare time (approx 20%) of the CPU when running at 16 or 20 MHz.

Sample hardware:

![tvout_hw](tvout_hw.png)

![](embim3.png)

  


TECHNICAL INFORMATION  
  
IMPORTANT  
  
You do not have to read this information - BASCOM and the TV code will automatically set up the hardware as required. If you use the supplied PCB this ensures the TV output will work without any knowledge of the module.  
These technical details are for reference.  
  
The TV code has various fixed hardware requirements as follows.  
  
Clock:  
  
The clock MUST use an external crystal to produce a stable screen.  
Normally 20 MHz but 16 MHz can be used (20% less columns).  
  
SPI port:  
  
The SPI hardware is used by the TV code and cannot be used for other purposes while the TV code is running.  
  
RAM use:  
  
* Amount of RAM used can be very small - EndScreen code marks end of RAM used  
* Lines are variable length so only visible characters [excepting space] use RAM  
  
RAM Addresses:  
  
* The address of RAM used by the TV code is fixed at $100 (start of RAM in ATMega 48/88/168/328 ICs)  
* The first six bytes of RAM are used to store variables for the interrupt code  
* The first byte of RAM used for the screen area is at address $106  
  
Maximum RAM use:  
  
* For a full screen of 55 characters by 12 lines, RAM used = 660 bytes  
* In an ATMega48, used screen RAM will need to be kept below around 450 bytes for use with BASCOM  
  
GPIO register:  
  
In ATMega 48/88/168/328 ICs there is a "GPIO" register at $1E. Bit 0 of this is used by the code.  
The other 7 bits are unused and can be changed by the user software.  
  
Pixel data:  
  
* The pixel data used for the characters shown on screen starts at a fixed Flash ROM word address  
* All pixel data can be edited or replaced by the user to allow custom characters  
  
Timers:  
  
* Timer 2, an 8 bit timer, is reserved for use by this code  
* Timer 2 causes a 64µS interrupt and can be used for a system "tick"  
* Timers 0 and 1 are unused  
  
Reset and interrupt vectors:  
  
* The interrupt vectors for Timer 2 compare match A and B are both used  
* Timer/Counter2 Compare Match B vector points to the TV interrupt code  
  
Control characters:  
  
* End of line code = EndLineCode = $0D  
* End of screen code = EndScreenCode = $0C  
* Set colour to yellow chars on a red background = SetYellowCode = $10  
* Set colour to green chars on a black background = SetGreenCode = $11  
* Set colour to cyan chars on a blue background = SetBlueCode = $12  
* Set colour to white chars on a magenta background = SetWhiteCode = $16  
  
All of Port B is reserved:  
  
* PB0 Sync  
* PB1 Blue  
* PB2 Red  
* PB3 Green  
* PB4 & PB5 [2] allocated SPI pins  
* PB6 & PB7 [2] Used for XTAL  
  
No pins on Ports C or D are used  
  
Interrupt Code:  
  
* Triggered by Timer 2 interrupt  
* Runs every 64 uS  
* Consumes up to 80% of CPU time [worst case]  
  
Fuses:  
  
Only the low fuse needs to be changed:  
  
CKDIV8 must be high (unprogrammed) so clock will be at full freq  
  
1 CKDIV8 Divide clock by 8 (default 0 = programmed)  
1 CKOUT Clock output (default 1 = unprogrammed) i.e. clock output off  
1 SUT1 Select start-up time (default 1 = unprogrammed)  
1 SUT2 Select start-up time (default 0 = programmed)  
  


SUT1,2 = 11 selects Crystal Oscillator, slowly rising power (in case of PSU problems)  
  
0 CKSEL3 0  
1 CKSEL2 0  
1 CKSEL1 1  
1 CKSEL0 0  
  
0111 in CKSEL 3210 selects full swing oscillator, slowly rising power  
  
So lfuse = $F7

Example

```vb
' Serial input demo.  
' NOTES:  
' Uses an array of bytes for Screen RAM  
' Uses Tilde char "~" = $7E for new screen  
  
$crystal = 20000000  
$BAUD = 19200  
  
' Reserve screen variable area at start of RAM  
' Assembler interrupt code has two byte variables IN BETWEEN two word variables  
Dim ScreenAddr1 as word at $100  
Dim RAMVar1 as byte at $102  
Dim RAMVar2 as byte at $103  
Dim ScreenAddr2 as word at $104  
  
' Reserve Screen RAM - can reserve as much or as little as required  
Dim ScreenRAM(600) as byte at $106  
Dim Addr As Word  
Dim CharIn as Byte  
  
```
Const NewScreen = $7E  
  
```vb
'Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0  
'Config is not needed unless settings differ from default  
  
On Oc2a Tvinterrupt Nosave  
Goto Main  
```
!.org $100  
```vb
$inc Tvinterrupt , Nosize , "tvinc.bin"  
Return  
  
  
```
Main:  
```vb
' Set up clock division - only need to do this if DIV8 fuse not set, as default fuse setting is div. by 8  
Config Clockdiv = 1  
' CLKPR=$80  
' CLKPR=0  
' Setup timer 2  
```
TCCR2B=$02  
OCR2A=158  
OCR2B=160  
TIMSK2=&b00000110  
' Now set up sleep mode [SMCR = Sleep Mode Control Register] - must be enabled or TV code cannot work accurately  
SMCR=1  
' Set PORTB to all outputs for video signal  
DDRB=$FF  
' Enable & config SPI  
SPCR=$54  
SPSR=1  
' Init RAM variables for interrupt code  
RAMVar1=0  
RAMVar2=0  
ScreenAddr1=$106  
ScreenAddr2=$106  
  
```vb
ENABLE OC2A  
' ENABLE OC2B  
ENABLE INTERRUPTS  
' Now continue with user code  
  
  
  
  
```
Addr=1 ' Set Addr to address of first screen location  
  
Do  
CharIn=INKEY()  
If CharIn>0 then  
ScreenRAM(Addr)=CharIn  
Incr Addr  
ScreenRAM(Addr)=13 ' Make sure there is always an end of screen character  
```vb
End If  
If CharIn=NewScreen then  
```
Addr=1  
ScreenRAM(Addr)=13  
```vb
End If  
If Addr>599 then Addr=599 ' Make sure cannot write past end of screen Ram  
Loop  
  
' Decimal {012} = $0C = END OF LINE MARKER  
' Decimal {013} = $0D = END OF SCREEN MARKER  
  
' Decimal {017} = $11 = Green on black  
' Decimal {019} = $13 = Cyan on blue  
' Decimal {020} = $14 = Yellow on red  
' Decimal {022} = $16 = White on magenta  
  
End  
  


```

---

## TYPE

Action

Defines a memory container using normal data types.

Syntax

TYPE SomeName

mem1 As DataType

memn As DataType

END TYPE

Remarks

Type describes a container of data types. It does not use any memory. Memory allocation is done using DIM. 

You start a new Type by using the TYPE statement. It must be followed by the type name.

On new lines you enter the member names followed by their data type. This is just like the DIM statement except that you only provide the data type.

You can also use an earlier defined data type. 

It is also possible to create an array by specifying an index. This index is one dimensional.

You end the definition on a new line using END TYPE.

Some examples : 

Type Rectest  
Naam As String * 9 '0-9, 10 bytes  
B As Byte '1 byte  
C As Integer '2 bytes  
End Type 'total size 13  
  
Type Mem  
Ar(16) As Byte '16 bytes  
X As Rectest '13 bytes  
End Type '29 total size  
  
Type Trec3  
J As Byte ' 1 byte  
End Type 'total 1 byte  
  
Type Trec2  
N As Integer '2 bytes  
W As Word '2 bytes  
R As Trec3 '1 bytes  
End Type 'total 5 bytes  
  
Type Trec1  
B As Byte '1 byte  
Q(10) As Byte '10 bytes  
Z(5) As Trec2 '5x2=25 bytes  
End Type 'total 36 bytes  
  
Type Tstr  
Naam As String * 16 '17 bytes  
B As Byte '1 bytes  
I As Integer '2 bytes  
W As Word '2 bytes  
Dw As Dword '4 bytes  
L As Long '4 bytes  
S As Single '4 bytes  
D As Double '8 bytes  
Ar(5) As String * 12 '5x13=65  
```vb
End Type 'total 107 bytes  
  
Dim Myrec(5) As Trec1 'using DIM you refer to the type name  
Dim Rec1 , Rec2 As Rectest  
Dim Recar(4) As Mem  
Dim Srec As Tstr  


  
```
When you refer to a typed variable you either use the name to refer to the whole record or when you want to access a member, you use a DOT followed by the member name.  
When a type contains nested types you use multiple DOTs and member names till you reach the desired member.  
The same BASCOM rules apply for typed variables as normal variables.  


There are some limitations since the type was not part of the compiler when designed.

Some of the limitations might be changed in the future.  
\- variable types can be only used in RAM and XRAM. It will not work on ERAM  
\- you can not perform bit operation on a type member : rec.b.1 = 1 will not work  
\- boolean/bit types can not be used as members.  
\- just like arrays, types are global and are passed by reference only  


INDIRECT Types

Besides the normal types there is also the indirect type. It works exact the same but when you DIM the variable that uses the type you use an additional specifier named INDIRECT

```vb
Dim Somerec As Trec1 Indirect

While a normal variable that uses a type uses memory determined at compilation the Indirect variable type has an internal address which need to be set by the user.

```
An example :

Dim Idrec As Tstr Indirect 'claims no memory

Const Cx = Sizeof(idrec) 'determine the size of the variable

Dim Al(cx) As Byte 'create an array in memory with the size of the type

Idrec_adr = Varptr(al(1)) 'set the address to the memory of al array

The address is the name of the variable with a suffix of _adr

So what is this good for you wonder?

When the memory would be dynamically allocated and released by a memory manager there would be no fixed memory address. So this variant is intended to be used with a memory manager.

A free memory manager exists. See the help description of Options, Compiler, Output, Extended Constants for more details.

See also

[DIM](dim.md) , [SIZEOF](sizeof.md)

Example

```vb
'--------------------------------------------------------------------------------  
'name :  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose :  
'micro : avr64da64  
'suited for demo : no  
'commercial addon needed : yes  
'--------------------------------------------------------------------------------  
  
$regfile = "AVRX64da64.dat"  
$crystal = 24000000  
$hwstack = 40  
$swstack = 40  
$framesize = 64  
'The AVRX series have more oscillator options  
Config Osc = Enabled , Frequency = 24mhz  
'Config Base = 0  
'set the system clock and prescaler  
Config Sysclock = Int_osc , Prescale = 1  
  
'set up the COM por/USART  
Config Com1 = 115200 , Mode = Asynchroneous , Parity = None , Databits = 8 , Stopbits = 1 , Tx_rx_xc_xd_pin = Alt1_pa4_pa5_pa6_pa7  
  
'a TYPE Defines a data type containing one or more elements  
'each element is defined just as you do with DIM  
'a TYPE does not occupy any space, it defines how much space is used when it is DIMensioned  
'below are some examples of types.  
  
  
```
Type Rectest  
Naam As String * 9 '0-9, 10 bytes  
B As Byte '1 byte  
C As Integer '2 bytes  
End Type 'total size 13  
  
Type Mem  
Ar(16) As Byte '16 bytes  
X As Rectest '13 bytes  
End Type '29 total size  
  
Type Trec3  
J As Byte ' 1 byte  
End Type 'total 1 byte  
  
Type Trec2  
N As Integer '2 bytes  
W As Word '2 bytes  
R As Trec3 '1 bytes  
End Type 'total 5 bytes  
  
Type Trec1  
B As Byte '1 byte  
Q(10) As Byte '10 bytes  
Z(5) As Trec2 '5x2=25 bytes  
End Type 'total 36 bytes  
  
Type Tstr  
Naam As String * 16 '17 bytes  
B As Byte '1 bytes  
I As Integer '2 bytes  
W As Word '2 bytes  
Dw As Dword '4 bytes  
L As Long '4 bytes  
S As Single '4 bytes  
D As Double '8 bytes  
Ar(5) As String * 12 '5x1365  
```vb
End Type '107 bytes  
  
'declare som subs for testing  
Declare Sub Sbt(rec As Rectest)  
Declare Sub Sbtest(byval B1 As Byte , B2 As Byte , Rec As Rectest)  
  
'dim some vars for test  
Dim Ss As String * 10  
Dim Ar(2) As Byte  
Dim B As Byte  
Dim Myrec(5) As Trec1 'using DIM you refer to the type name  
Dim Bdum As Byte , Idx As Byte , Qdx As Byte , Zdx As Byte  
Dim B1 As Byte  
Dim Rec1 , Rec2 As Rectest  
Dim Recar(4) As Mem  
Dim B2 As Byte  
Dim Srec As Tstr  
  
'when you refer to a typed variable you either use the name to refer to the whole record  
'or when you want to access a member, you use a DOT followed by the member name  
'when a type contains nested types you use multiple DOTs and membernames till you reach the member of interest.  
'The same BASCOM rules apply for typed variables as normal variables.  
  
'There are some limitations. Some of them might be changed in the near future  
'- variable types can be only used in RAM and XRAM. It will not work on ERAM  
'- you can not do bit operation in a type member : rec.b.1 = 1 will not work  
'- boolean/bit types can not be used as members.  
'- types are global and are passed by reference only  
  
```
B = 2 'assign a normal byte  
  
Rec1.b = 2 'assign to the byte member  
  
Srec.naam = "abc" 'assign a string  
Srec.ar(1) = "one" 'ar is an index so it must be addressed as index  
Srec.ar(b) = "two"  
Srec.b = B 'byte  
Srec.i = -1234 'integer  
Srec.w = 50000 'word  
Srec.dw = 12345678 'double word  
Srec.s = 12.34 'single  
Srec.d = 500.1234 'double  
Bdum = 1 'some other byte  
Swap Srec.ar(1) , Srec.ar(b) 'swap to record members  
  
```vb
Print Srec.naam 'print content of member  
Print Srec.b 'print byte value  
  
```
Sbt Rec1 'call a subroutine  
Sbtest Srec.b , Srec.b , Rec1 'call another sub  
  
Rec1.naam = "abc" 'assign string member  
Myrec(3).z(2).w = &HEEBB 'nested records assignment  
Myrec(3).z(b).w = Myrec(3).z(2).w + 100 'math operation on a record  
  
Myrec(1).z(2).r.j = 1  
Myrec(2).z(b).r.j = B  
Myrec(bdum).z(2).r.j = 3  
Myrec(bdum).z(2).r.j = Myrec(2).z(2).r.j  
Myrec(1) = Myrec(2) 'copy entire record  
Myrec(bdum) = Myrec(2)  
```vb
Print Myrec(4).z(2).r.j  
  
For Idx = 1 To 5  
```
Myrec(idx).b = Idx  
For Qdx = 1 To 10  
Myrec(idx).q(qdx) = Qdx  
```vb
Next  
Next  
  
```
Rec1 = Rec2 'copy whole record  
  
```vb
End  
  
'when you create a sub/function that pass a typed variable you need to define the type name  
Sub Sbtest(byval B1 As Byte , B2 As Byte , Rec As Rectest)  
```
B1 = B1 + 1 'we add one which does not matter since we pass a local copy  
Print B1 'print the value  
B2 = B2 + 1 'this is passed by reference , add 1  
Print B2 'print it, the calling value is changed as well  
Rec.b = &HB 'print the record member value  
Rec.c = &HC  
```vb
End Sub  
  
'another simple test  
Sub Sbt(rec As Rectest)  
```
Rec.b = &HB  
Rec.c = &HC  
End Sub

---

## UCASE

Action

Converts a string in to all upper case characters.

Syntax

Target = UCASE(source)

Remarks

Target | The string that is assigned with the upper case string of string target.  
---|---  
Source | The source string.  
  
UCASE supports [$BIGSTRINGS](bigstrings.md)

See also

[LCASE](lcase.md)

ASM

The following ASM routines are called from MCS.LIB : _UCASE

X must point to the target string, Z must point to the source string.

The generated ASM code : (can be different depending on the micro used )

;##### Z = Ucase(s)

Ldi R30,$60

Ldi R31,$00 ; load constant in register

Ldi R26,$6D

Rcall _Ucase

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim S As String * 12 , Z As String * 12

```
S = "Hello World"

Z = Lcase(s)

Print Z

Z = Ucase(s)

```vb
Print Z

End

```

---

## Updates

The update process is simple if you follow all steps. 

•| Go to the main MCS website at <https://www.mcselec.com>  
---|---  
  
•| In the left pane under 'Main Menu' you will find a link named 'Registration/Updates'  
---|---  
  
•| Optional you can enter the address yourself : [https://register.mcselec.com](<http://register.mcselec.com>)  
---|---  
  
![mcsweb](mcsweb.png)

  
Notice that the website uses two different accounts : one for the forum/shop and one for the registration/updates. You will see the following screen:

![prod_reg](prod_reg.png)

•| When you don't have an account yet, Click the link and select ['Create new account'](<http://register.mcselec.com/register.php>)  
---|---  
  
![new_account](new_account.png)

You need to provide a username, password, email and full name. Company name is optional. 

When you filled in the information, click 'Submit Registration'.

•| After you click submit, you can get various error messages. For example that a username already exists. Press the Back-button in your browser, and correct the problem, then try again  
---|---  
  
•| If the registration is successful you will get a message that the registration succeeded.  
---|---  
  
•| Watch your mail : you will receive an email with a confirmation link. You need to click this link in order to finalize your account  
---|---  
  
•| Now you can login. You will see the following or similar screen :  
  
---|---  
  
![mcsloginok](mcsloginok.png)

•| You need to chose 'Product registration'.   
---|---  
  
•| The following screen will be shown:  
---|---  
  
![prod_regok](prod_regok.png)

•| Select a product from the list.   
---|---  
  
•| Enter the serial number  
---|---  
  
![notice](notice.jpg)It is important that you enter a valid serial number. Do not try to enter serial numbers from cracked versions. When you enter invalid serial numbers, you will loose support and the ability to update. We will also ban your IP number from our web. The valid serial number is shown in the Help, About box. 

![about_serial](about_serial.png)

When the product is selected, the serial number is entered and you press 'Register product' you will see the following message :

![reg_ok](reg_ok.png)

•| This does mean that you registered successfully.  
---|---  
  
•| MCS Electronics will validate all registrations once in a while. When the product is validated you will receive an email. After you receive the email, you can login to the register again.  
---|---  
  
•| Note that you need to register within 2 years after purchase. Only the original buyer can register and is qualified to get updates and support.  
---|---  
  
•| Once registered you will see the following or similar screen :  
---|---  
  
![download_lic](download_lic.png)

At the top you can see which products are registered and which status they have.

When you want to do an update you need to do a FULL SETUP, you need to download the full version. LIC files for partial updates are no longer offered.

You do not need to uninstall a previous version. You can install an update into the same directory or a new directory. 

We recommend to install into a new folder. 

When you uninstall a previous version, it will remove the license file which is not part of the setup.exe

![notice](notice.jpg)So in the event that you do run uninstall first, make a backup of the license dll named bscavrL.DLL

For BASCOM, the ZIP file you download contains only one setup.exe. You need to run this executable. 

It is also important that you put the license DLL into the same directory as setup.exe

Setup will copy this file to the BASCOM application directory. You can also manual copy this file.

The license file is on CD-ROM, diskette, or the media (email) you received it on. It is only supplied once.

Without the file, BASCOM will not run. 

The file is named bscavrL.DLL for BASCOM-AVR

When you got the license by email, it was zipped and probably had a different extension. Consult the original installation instructions.

The file is only provided once, we can not, and do not provide it again.

Add-on products can contain multiple files like lib, bas, pdf, etc.

See [Installing BASCOM ](installation.md)on how to do a full install.

IMPORTANT

![notice](notice.jpg)As of version 2080, the Update Wiz is phased out. This means that you need to download and install the full setup.exe

The BASCOM-IDE has a new simplified update method. See also [Help, UPDATE](help_update.md)

---

## UpdateScreen

Action

Executes the Commands in the FIFO and Display the Graphics. 

Syntax

UpdateScreen

Remarks

UpdateScreen High level command which executes the following commands

[Display_E](display_e.md)

[CmdSwap](cmdswap.md)

[CmdDlStart](cmddlstart.md)

[WaitCmdFifoEmpty](waitcmdfifoempty.md)

Generally you insert this command towards the end of the loop or when you need to

update the LCD.

Example

```vb
' Pseudocode

Do

```
ClearScreen

BitmapLayout PALETTED, Ft_DispWidth , Ft_DispHeight

BitmapSize NEAREST, BORDER, BORDER, Ft_DispWidth, Ft_DispHeight

...

...

UpdateScreen

Loop

---

## UPDI Programmer

The MCS UPDI programmer is a serial based programmer.

You need to select 115200 BAUD and the COM port which is connected to the UPDI interface.

In version 2084 you can select up to 225000 baud. This is the maximum recommended baud from microchip with the default clock.

In version 2086 the maximum baud of 1600000 is supported. Notice that only DA/DB processors support this speed.

The UPDI interface is very simple : all you need is a TX, RX and a resistor.

Connect TX from the PC UART to a 4K7 resistor. The other side of the resistor is connected to the PC RX and to the UPDI pin of the processor.

We use DTR to switch the TX and RX from the PC to the processor. This allows to use the PC COM port to be used for serial communication and as a UPDI programmer.

Note : some modules will not give proper signals. A 1K resistor will bring better results.

![notice](notice.jpg)Please notice that you need a MAX232 or other level converter between the PC communication pins to create the proper voltage level! Like the circuit shown below.

The programmer works similar as the other supported programmers : you can program the FLASH, EEPROM and the fuse/lock bytes

In version 2083 you can also write the fuse bytes. 

![updi-programmer](updi-programmer.png)

When you change the values of a fuse the WRITE-FUSES button will be enabled. 

When you change the value of the LOCK fuse, the WRITE-LOCK bits button will be enabled.

When you change the value of the user fuses, the WRITE USER ROW button will be enabled.

When you write the fuses, the fuse values will be re-read (refreshed). And the same for the other fuses. 

See CONFIG FUSES for information on how to automatic program fuse bytes.

Programmer Options

The MCS UPDI programmer has a number of options:

![mcsupdioptions](mcsupdioptions.png)

Since this is a serial programmer you need to select the COM port. 

The BAUD also need to be selected.

115200 should always work

22500 also should work for all processors

The maximum speed for the XTINY platform is 900.000 (900 KB)

The maximum speed for the MEGAX platform is also 900 KB

The maximum speed for the AVRX (DA/DB) platform is 1.600.000 (1.6 MB)

The timeout can best be set to 50.

Then there is an option to control what the DTR and RTS pins should do.

You can chose :

\- NONE : DTR/RTS is not used

\- program/data : DTR/RTS is used to switch between programming and normal mode. This way you can use a MUX and use the same TX/RX pins of your serial port for programming and data

\- HV program : DTR/RTS is used to generate a pulse on the UPDI pin. You should include some circuit that inserts 12V using DTR line.

Since you have 2 pins you can chose DTR for switch between program/data and RTS for the 12V pulse.

![unlock](unlock.png)

The UPDI prgrammer also has a Chip Unlock option. When the chip is locked, you need this option to fully erase the chip.

A typical connection for the UPDI programmer :

![updi-prog-sch](updi-prog-sch.png)

A MAX232 level converter will convert the RS232 levels to 5V.

The TX from the PC/max232 is connected with a 4K7(or 1K) resistor to the UPDI pin.

The RX from the PC/max232 is connected directly to the UPDI pin.

you can also use an USB virtual com port chip such as the FT232 or CP2102.

Using a serial port just for programming is a bit of a waste. Often you also like to have serial communications.

So a more practical programmer will switch the TX/RX lines between the UPDI pin and the TX-RX USART pins of the processor.

![updi-prog-mux](updi-prog-mux.png)

Notice that the USB circuit shown is not complete, you should check it with the chip of your choice like FT232RL, CP2102, etc. The main purpose of the USB part is to show the TX/RX and DTR pins.

The TX pin and RX pins are connected to a 4053 switch. This is an analog switch. The DTR line selects the XYZ-0 or XYZ-1 side of the switch. 

The UPDI pin is also connected to a MUX switch. This simple circuit now switches between the UPDI mode and the TX and RX pins of the processor.

The BASCOM-UPDI programmer will automatically switch the DTR line.

Some processors have a dedicated UPDI pin. Other processors share this pin with a normal IO pin.

The RESET pin can also be dedicated or shared. When shared you must program the RESET function since this is not enabled by default.

A virtual USB COM port is used most likely since a DB-9 serial connector is not found on most modern PC/laptop.

FT232/CP2102

We have tested using the CP2102 but FT232 should also work. As user EDC found out the FT232 requires some driver changes.  
\- Buffers need to be changed from 4096 to 64

\- Latency need to be set from 16 to 2

For more information : [mcs forum](<https://www.mcselec.com/index2.php?option=com_forum&Itemid=59&page=viewtopic&p=82271#82271>)

User Feedback about USB chips

MCP2221A:

1.1 Bascom AVR does not work with the chipset MCP2221A.... no matter of every change in the circuit or in the UART-settings.

UMFT230XB-01:

Works but very slow

See also the info from EDC listed above.

CP2102 (MCS chip of choice)

\- works perfect!

FT232RL

It works but it programs slow.

See also EDC settings.

CH340G

works perfect & fast

Comment from other user:

CH340 doesn't work.

FT232 works perfectly. 

This is of course contradicting. Could be the driver, other settings? 

MCS UPDI programmer is considered a nice free alternative to program the processor. 

For better results you best get the Microchip SNAP programmer. 

See Also

[Using a BOOTLOADER](using_a_bootloader.md) , MCS SNAP Programmer

---

## UPPERLINE

Action

Reset LCD cursor to the upper line.

Syntax

UPPERLINE

Remarks

Optional you can also use the LOCATE statement.

See also

[LOWERLINE](lowerline.md) , [THIRDLINE](thirdline.md) , [FOURTHLINE](fourthline.md) , [LCD](lcd_2.md), [CLS](cls.md) , [LOCATE](locate.md)

Example

Dim A As Byte

A = 255

Cls

Lcd A

Thirdline

Lcd A

Upperline

End

---

## USBprog Programmer / AVR ISP mkII

The USBprog programmer is a neat small USB programmer which is fully compatible with the AVR ISP mkII programmer.

When you select this programmer, you will get the same interface as for the [STK500 native](stk500_programmer.md) programmer.

F4 will launch the programmer. For more details read the help section for the STK500 programmer.

When programming XMEGA chips the interface for the fuse bits will be different. See [STK600](stk600.md) programmer for a description.

The default clock is 125 KHz. This because most/all chips ship with a clock frequency of 1 MHz. And since the clock frequency maximum is a quarter of the oscillator frequency, the default is 125 KHz, low enough to be able to program all chips. Once your chip runs at say 8 MHz, you can select 2 MHz as the maximum.

You must have the [LIBSUSB](libusb.md) drivers installed on your PC. Without it, it will not work.

Options

In the Configuration options you can adjust the clock speed and the timeout of the USB.

When you are using USB 1.1 and a lot of devices that generate a lot of USB traffic, you might need to increase the default timeout of 100 (msec). 

XMEGA

When used in PDI mode, take care about the following for some of the processors:

JTAG is activated by default which preventing from using the PDI because both interfaced share the same pins. In this case :

1 - Disable the JTAG before using the PDI. > You need a JTAG programmer

2 - Use a 47Kohm resistor to Pull down the clock pin to ground which allow you to have both JTAG and PDI working simultaneously.

---

## Using a BOOTLOADER

With booting we mean starting up like when you power a PC, after a reset.

When you reset the processor your user code will be executed.

A boot loader is a small program which task it is to re-program the processor. That is : in our case. A boot loader could do security checks or have other functions but when we say boot loader it always refer to some code that will reprogram the processor.

A boot loader typically runs just after a reset. But it could be initiated on any possible way. The recommended way is to use the statement : RESET MICRO.

A normal AVR and Xmega have a fuse that can be set to select the reset vector. It can point to address 0 which is the normal start address. Or it can point to an address at the end of flash memory.

When the fuse points to the boot vector, a jump is executed to this memory. And the boot code that is located at this memory is executed. Typically it will receive data and will flash/reprogram the memory from address 0 and up.

After that, the code at address 0 is executed and the normal user code runs. 

The $LOADER directive is used to place the program code at the boot address at the end of memory. The exact address depends on other fuse settings and the processor used.

The normal user code always end up in location 0 and up.

The new Xtiny/MegaX and AVRX processors work different. A reset will always execute address 0. But when you want to program a boot loader, you use a Boot fuse to tell how big the boot loader is. A value of 1 will reserve a size of 512 bytes. A value of 2 will reserve 1024 bytes, etc. So you are flexible in selecting the size of the boot loader.

After the boot block your normal code starts. But now you see the difference : the normal user code runs at a higher address. So we must tell the compiler that all code must be relocated.

We use the $ROMSTART directive for that. 

A boot loader does not have a $ROMSTART directive. 

```vb
While the boot fuse uses blocks of 512 bytes, the flash page size can be different. Do not confuse this. AVRX processors typically have flash page size of 512 bytes. 

For the AVRX series we include here a sample boot loader. 

'----------------------------------------------------------------  
' (c) 1995-2025, MCS  
' Bootloader-AVRX.bas  
'----------------------------------------------------------------  
' This sample demonstrates how you can write your own bootloader  
' in BASCOM BASIC for the AVR DB/DA series  
' The AVRX has a different memory lay out and a different NVM controller  
' Normal AVR starts with normal application code and the boot code is placed at the end of memory.  
' AVRX starts with BOOT memory. So we always start in BOOT mode.  
' With the BOOTEND fuse we can set the size of the BOOT area.  
' Different processors have different page sizes. For DA/DB series the pages size is 512 bytes  
' A value of 1 will give a size of 512 bytes, a value of 2 gives 1024 bytes, etc.  
' In this example we use less than 1536 bytes so we set the fuse to 3.  
' Notice that the fuse page size can differ from the flash page size ! In this case the sizes are equal.  
  
' After the optional boot space there is the APPLICATION CODE  
' And after the APPLICATION CODE there is the APPLICATION DATA  
' When you dont want a boot loader you set the bootend fuse to 0 which is the default.  
' your app will use the boot and application code  
' When you want a boot loader, you determine the size of the boot loader and then  
' set the fuse to the proper size  
' With the MCS boot loader, the code simply checks if the #123 data is received.  
' If so, it starts the loading. If not it continues.  
' It is similar to the normal AVR boot loading. The normal AVR boot starts after the normal space.  
' # There is one important difference. With normal AVR all the code start at &H0000.  
' For the loader we then use the $LOADER directive to place the code at the proper address  
' For XTINY/AVRX the boot loader starts at &H0000 thus is considered a normal application without specific switches  
' Your normal code must now be located AFTER the bootloader. This means you need to instruct the compiler to place the code  
' at a different address. We use $ROMSTART for this purpose.  
' Remember that AVR has word address. Which means that each address uses 2 bytes of memory.  
'  
'-----------------------------------------------------------------  
  
$regfile ="AVRX128da28.dat"  
$crystal = 24000000  
$hwstack = 40  
$swstack = 40  
$framesize = 40  
  
'declare subs and functions  
Declare Sub Erasepage()  
Declare Sub Protected_write_spm(byreg R16 As Byte)  
  
'The AVRX series have more oscillator options  
Config Osc = Enabled , Frequency = 24mhz  
'set the system clock and prescaler  
Config Sysclock = Int_osc , Prescale = 1  
'define the baud rate and port/usart  
Config Com1 = 115200 , Mode = Asynchroneous , Parity = None , Databits = 8 , Stopbits = 1  
  
```
Const Pagesize_bts = 512 ' page size in bytes is 512 bytes  
Const Fword = Pagesize_bts / 2 ' page size in words is 256  
Const Numpages = 256 ' number of page is 256  
Const Key_ctrla_spm = &H9D ' ccp key write protect for SPM NVM_CTRLA  
Const Key_ctrlb_io = &HD8 ' ccp key write protect for IO NVM_CTRLB  
' NVM Commands  
Const Nocmd = 0 'no command  
Const Noop = 1 'no operation  
Const Flwr = 2 'flash write enable  
Const Flper = 8 'flash erase enable  
  
'flash constants  
Const Maxwordbit = 8  
Const Maxword =(2 ^ Maxwordbit) * 2 '512  
Const Maxwordshift = Maxwordbit + 1 '9  
  
```vb
'It is VERY IMPORTANT that the baud rate match the one of the boot loader  
'do not try to use buffered com since we do not use interrupts  
'you could however use interrupts but it occupies more space  
  
'Possible return codes of the PC bootloader.exe  
' -6005 Cancel requested  
' -6006 Fatal time out  
' -6007 Unrecoverable event during protocol  
' -6008 Too many errors during protocol  
' -6009 Block sequence error in Xmodem  
' -6016 Session aborted  
  
'since this is a boot loader we do not want a vector table  
'we reduce the vector table to 0  
$reduceivr  
  
'Dim the used variables  
Dim Z As Dword ' this is the Z pointer word  
Dim Vl As Byte , Vh As Byte ' these bytes are used for the data values  
Dim Wrd As Word , Page As Word ' these vars contain the page and word address  
  
Dim Bstatus As Byte , Bretries As Byte , Bblock As Byte , Bblocklocal As Byte  
Dim Bcsum1 As Byte , Bcsum2 As Byte , Buf(128) As Byte , Csum As Byte  
Dim J As Byte , Wptr As Word  
  
  
'We start with receiving a file. The PC must send this binary file  
  
'some constants used in serial com  
```
Const Cnak = &H15  
Const Cack = &H06  
  
```vb
$timeout = 400000 ' we use a timeout  
'When you get LOADER errors during the upload, increase the timeout value  
'for example at 16 Mhz, use 200000  
  
```
Bretries = 5 ' we try 5 times  
Do  
Bstatus = Waitkey() ' wait for the loader to send a byte  
```vb
Print Chr(bstatus); ' echo back  
  
If Bstatus = 123 Then ' did we received value 123 ?  
Goto Loader ' jump into boot loader  
End If  
```
Decr Bretries  
```vb
Loop Until Bretries = 0  
  
'if we arrive here, there was not boot character received. we simply continue  
Goto Application_start_noload ' goto the normal code  
  
  
'this is the loader routine. It is a Xmodem-checksum reception routine  
```
Loader:  
Do  
Bstatus = Waitkey() ' flush the data  
```vb
Loop Until Bstatus = 0  
  
'just like the normal AVR loader we need to erase a page first  
'but since we write beyond the loader we need to set the page to the proper value which is essential the same as the FUSE BOOT SIZE value !  
```
page=3 'remember each page uses 512 bytes, this code is less than 1536 so the normal app start on page 3  
Erasepage 'erase it  
  
Bretries = 10 ' number of retries  
Do  
Bblocklocal = 1  
Csum = 0 ' checksum is 0 when we start  
```vb
Print Chr(cnak); ' first time send a nack  
Do  
  
```
Bstatus = Waitkey() ' wait for status byte  
  
```vb
Select Case Bstatus  
Case 1: ' start of heading, PC is ready to send  
```
Csum = 1 ' checksum is 1  
Bblock = Waitkey() : Csum = Csum + Bblock ' get block  
Bcsum1 = Waitkey() : Csum = Csum + Bcsum1 ' get checksum first byte  
For J = 1 To 128 ' get 128 bytes  
Buf(j) = Waitkey() : Csum = Csum + Buf(j)  
Next  
Bcsum2 = Waitkey() ' get second checksum byte  
```vb
If Bblocklocal = Bblock Then ' are the blocks the same?  
If Bcsum2 = Csum Then ' is the checksum the same?  
Gosub Writepage ' yes go write the page  
Print Chr(cack); ' acknowledge  
```
Incr Bblocklocal ' increase local block count  
```vb
Else ' no match so send nak  
Print Chr(cnak);  
End If  
Else  
Print Chr(cnak); ' blocks do not match  
End If  
Case 4: ' end of transmission , file is transmitted  
' Waitms 100 ' OPTIONAL REMARK THIS IF THE DTR SIGNAL ARRIVES TO EARLY  
Print Chr(cack); ' send ack and ready  
Waitms 20  
Goto Application_start ' start new program  
Case &H18: ' PC aborts transmission  
Goto Application_start ' ready  
Case 123 : Exit Do ' was probably still in the buffer  
Case Else  
Exit Do ' no valid data  
End Select  
Loop  
If Bretries > 0 Then ' attempte left?  
Waitms 1000  
```
Decr Bretries ' decrease attempts  
```vb
Else  
Exit Do ' reset chip  
End If  
Loop  
  
```
Application_start:  
Protected_write_SPM nocmd ' clear current command  
Cpu_ccp = key_CTRLB_io  
Rstctrl_swrr = 1 ' perform a soft reset  
  
'no code between the label above and below !  
  
Application_start_noload:  
r23=&B111 ' set value  
Cpu_ccp = key_CTRLB_io ' configuration change protect  
Nvmctrl_ctrlb = R23 ' enable boot section read protect, appdatawrite protect, appcode protect  
```vb
'the addres to go to is a word address, since our loader is less than 1536 bytes, this is 600 in hex and divided by 2 for words gives 300  
Goto &H300 ' normal app code  
  
'this sub routine will write the pages  
```
Writepage:  
For J = 1 To 128 step 2 ' get 128 bytes  
Z = Page ' make equal to page  
Shift Z , Left , Maxwordshift ' shift to proper place  
Z = Z + Wrd ' add word  
r0= Buf(j) ' r0:r1 point to the DATA for SPM  
R1 = Buf(j + 1)  
! lds r30,{Z} ; Z points to address  
! lds r31,{Z+1}  
  

#if _romsize > 65536  
! lds r24,{Z+2}  
! sts rampz,r24 ' we need to set rampz also for 128KB chips  

#endif  
!spm ; this actual executes the instruction  
wrd=wrd+2 ' we write word data so increase by 2  
```vb
Next  
  
if wrd=maxword then ' page is full  
```
wrd=0 ' reset word counter for next page  
page=page+1 ' increase page  
Erasepage ' erase so we can write  
```vb
end if  
return  
  
'erase a page based on PAGE value  
'RAMPZ ZH ZL (bit0 for low high byte selection)  
' 7 bits for word address : 128 word address  
' 1 bit from ZH -> 256 word address  
' leves 7 bit for PAGE address  
'zzzz,pppppppw,wwwwwwwx  
Sub Erasepage()  
```
Z = Page ' make equal to page  
Shift Z , Left , Maxwordshift ' shift to proper place  
  
bitwait NVMCTRL_STATUS.0,reset ' make sure flash is not busy  
Protected_write_SPM nocmd ' clear current command  
Protected_write_SPM flper ' erase page enable  
'dummy write needed, how dum  
  
! lds r30,{Z}  
! lds r31,{Z+1}  

#if _romsize > 65536  
! lds r24,{Z+2}  
! sts rampz,r24 ' we need to set rampz also for 128KB chips  

#endif  
! clr r0 ; data must be 0 for the dummy write  
! clr r1  
  
!spm ; execute dummy write  
  
bitwait NVMCTRL_STATUS.0,reset ' make sure flash is not busy  
Protected_write_SPM nocmd ' clear current command  
Protected_write_SPM flwr ' enable write to flash  
```vb
end sub  
  
sub Protected_write_SPM(byreg r16 as byte)  
```
CPU_CCP= key_CTRLA_spm 'change protect key  
NVMCTRL_CTRLA=r16 'write to SPM register  
```vb
end sub  
  
'this loader takes less than 1536 bytes so the BOOT FUSE is set to 3.  
'do NOT FORGET that your normal app must use $ROMSTART=&H300 in that case : halve of the bytes size of the loader  
  
'one other thing : the reset pin works in UPDI mode by default. so your chip will not reset when you do not change the fuse  
'but there are other ways of reset such as soft reset, bod and wd.

```
You compile the code and from the report you can find that the code size is 1214 bytes. Because the boot fuse block is 512, it means the value must be : 1214/512=2.31 We round up so end with 3.

We now run the MCS UPDI programmer and select the fuses TAB

![bootloader_fuses](bootloader_fuses.png)

The boot section size must be set to 3 as shown above.

You can also use the WRITE CONFIG button to write a CONFIG FUSE line in your code.

Just make sure the editor is set to a new line. in this case we end up with :

Config Fuses = Off , Lock = Off , Fuse0 = &H00 , FUSE1 = &H20 , FUSE2 = &HF0 , FUSE5 = &HDA , FUSE6 = &HF8 , FUSE7 = &H00 , FUSE8 = &H03 , UROW0 = &H00 , UROW31 = &H31

All user row values with a non default value are included too. 

When you compile with CONFIG FUSES=OFF, nothing will happen. Only when you change the FUSES=OFF to FUSES=ON, the fuses will be programmed when you auto program the chip.

And when you change LOCK=OFF to LOCK=ON, the processor will be locked too. The lock will make sure the data can not be read any longer. only the UNLOCK chip option from the programmer can unlock the chip. An operation that will also erase the chip. So typically writing LOCK bytes is something you do when all is tested.

Once we have programmed our boot loader and set the boot fuse to the correct size, we can use the MCS Boot loader to load new code.

Do not forget to chose the MCS Boot loader.

The only thing you need to remember : include the $ROMSTART=&H300 line in your NORMAL code. 

Most examples you find do not have this directive. 

Instead of the MCS Bootloader you can also make a boot loader that use Blue Tooth, Wifi, or an SD card. 

The mechanism is always : at boot check some condition, when met, perform the update.

The actual boot loader will remain in the processor. 

When you have suitable hardware like an external EEPROM with the size of the FLASH memory, you could update the firmware in your normal code. The boot code then would copy from EEPROM when required.

A boot loader could use decryption so your firmware can not be easily disassembled.

---

## USING RS485

RS485

RS485 is used for serial communication and well suited for transmission over large distances.

Similar to RS232 we need a level shifter.

![rs485-example](rs485-example.png)The sample above uses a MEGA161 or MEGA162 which has 2 UARTS. This way you can have both a RS232 and RS485 interface.

The RS232 is used for debugging.

In order to test you need 2 or more similar circuits. One circuit would be the master.

The other(s) would be a slave.

The same hardware is used to test the MODBUS protocol. The bus need to be terminated at both ends with a resistor. 100 ohm is a typical used value.

The GND of both circuits may not be connected ! Only connect point A and B from both circuits. For industrial usage it is best to use an optical isolated level shifter.

Simple MASTER sample

```vb
$regfile = "m162def.dat" ' specify the used micro

$crystal = 8000000

$baud = 19200 ' use baud rate

$hwstack = 42 ' default use 32 for the hardware stack

$swstack = 40 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

$lib "modbus.lbx"

Config Print1 = Portb.1 , Mode = Set ' use portb.1 for the direction

```
Rs485dir Alias Portb.1

Config Rs485dir = Output

Rs485dir = 0 ' go to receive mode

Portc.0 = 1 ' a switch is connected to pinc.0 so activate pull up resistor

```vb
' TX RX

' COM0 PD.1 PD.0 monitor

' COM1 PB.3 PB.2 rs485

' PB.1 data direction rs485

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Config Com2 = 9600 , Synchrone = 0 , Parity = Even , Stopbits = 1 , Databits = 8 , Clockpol = 0 ' MUST MATCH THE SLAVE

'use OPEN/CLOSE for using the second UART

```
Open "COM2:" For Binary As #1

```vb
'dimension some variables

Dim B As Byte

Dim W As Word

Dim L As Long

```
W = &H4567 ' set some values

L = &H12345678

```vb
Print "RS-485 MODBUS master"

Do

If Pinc.0 = 0 Then ' test button

Waitms 500 ' delay since we want to send just 1 frame

Print "send request to slave/server" ' to debug terminal

' Print #1 , Makemodbus(2 , 3 , 8 , 2); 'slave 2, function 3, start address 8, 2 bytes

' Print #1 , Makemodbus(2 , 6 , 8 , W); 'slave 2, function 6, address 8 , value of w

Print #1 , Makemodbus(b , 16 , 8 , L); 'send a long

End If

If Ischarwaiting(#1) <> 0 Then 'did we got something back?

```
B = Waitkey(#1) ' yes so get it

```vb
Print Hex(b) ; ","; ' print it

End If

Loop

```
A slave would simply listen to data, and once enough data received, send it back.

---

## Using the 1 WIRE protocol

The 1-wire protocol was invented by Dallas Semiconductors and needs only 1 wire for two-way communication. You also need power and ground of course.

This topic is written by GÃ¶te Haluza. He tested the new 1-wire search routines and is building a weather station.

Dallas Semiconductor (DS) 1-wire. This is a brief description of DS 1-wire bus when used in combination with BASCOM. For more detailed explanations about the 1-wire bus, please go to http://www.maxim-ic.com. Using BASCOM makes the world a lot easier. This paper will approach the subject from a "BASCOM-user-point-of-view".

1-wire-net is a serial communication protocol, used by DS devices. The bus could be implemented in two basic ways :

With 2 wires, then DQ and ground is used on the device. Power is supplied on the DQ line, which is +5V, and used to charge a capacitor in the DS device. This power is used by the device for its internal needs during communication, which makes DQ go low for short periods of time. This bus is called the 1-wire bus.

With 3 wires, when +5V is supplied to the VDD line of the device, and DQ + ground as above. This bus is called the 2-wire bus.

So, the ground line is "not counted" by DS. But hereafter we use DS naming conventions.

How it works. (1-wire)

The normal state of the bus is DQ=high. Through DQ the device gets its power, and performs the tasks it is designed for.

When the host (your micro controller (uC)) wants something to happen with the 1-wire bus, it issues a reset-command. That is a very simple electric function that happens then; the DQ goes active low for a time (480uS on original DS 1-wire bus). This put the DS-devices in reset mode; then (they) send a presence pulse, and then (they) listen to the host.

The presence pulse is simply an active low, this time issued by the device(s).

Now, the host cannot know what is on the bus, it is only aware of that at least 1 DS device is attached on the bus.

All communication on the 1-wire bus is initialized by the host, and issued by time-slots of active-low on a normally high line (DQ), issued by the device, which is sending at the moment. The devices(s) internal capacitor supplies its power needs during the low-time.

How do you work with 1-wire-bus

Thereafter, you can read a device, and write to it. If you know you only have 1 sensor attached, or if you want to address all sensors, you can start with a "Skip Rom" - command. This means; take no notice about the IDs of the sensors - skip that part of the communication.

When you made a 1-wire-reset, all devices of the bus are listening. If you chose to address only one of them, the rest of them will not listen again before you have made a new 1-wire-reset on the bus.

I do not describe BASCOM commands in this text - they are pretty much self-explanatory. But the uC has to write the commands to the bus - and thereafter read the answer. What you have to write as a command depends on devices you are using - and what you want to do with it. Every DS chip has a data sheet, which you can find at http://www.dalsemi.com/datasheets/pdfindex.html. There you can find out all about the actual devices command structure.

There are some things to have in mind when deciding which of the bus-types to use.

The commands, from BASCOM, are the same in both cases. So this is not a problem.

The +5V power-supply on the VDD when using a 2-wire bus has to be from a separate power supply, according to DS. But it still works with taking the power from the same source as for the processor, directly on the stabilizing transistor. I have not got it to work taking power directly from the processor pin.

Some devices consume some more power during special operations. The DS1820 consumes a lot of power during the operation "Convert Temperature". Because the sensors knows how they are powered (it is also possible to get this information from the devices) some operations, as "Convert T" takes different amount of time for the sensor to execute. The command "Convert T" as example, takes ~200mS on 2-wire, but ~700mS on 1-wire. This has to be considered during programming.

And that power also has to be supplied somehow.

```vb
If you use 2-wire, you don't have to read further in this part. You can do simultaneously "Convert T" on all the devices you attach on the bus. And save time. This command is the most power-consuming command, possible to execute on several devices, I am aware of.

If you use 1-wire, there are things to think about. It is about not consuming more power than you feed. And how to feed power? That depends on the devices (their consumption) and what you are doing with them (their consumption in a specific operation).

```
Short, not-so-accurate description of power needs, not reflecting on cable lengths.

Only the processor pin as power supplier, will work < 5 sensors. (AVR, 1-wire-functions use an internal pull-up. 8051 not yet tested). Don't even think of simultaneous commands on multiple sensors.

With +5V through a 4K7 resistor, to the DQ-line, 70 sensors are tested. But, take care, cause issuing "Convert T" simultaneously, would cause that to give false readings. About ~15 sensors is the maximum amount of usable devices, which simultaneously performs some action. This approach DS refers to as "pull-up resistor".

With this in mind, a bus with up to 70 devices has been successfully powered this way.

The resistor mentioned, 4K7, could be of smaller value. DS says minimum 1K5, I have tested down to 500 ohm - below that the bus is not usable any more. (AVR). Lowering the resistor feeds more power - and makes the bus more noise resistant. But, the resistor minimum value is naturally also depending on the uC-pin electric capabilities. Stay at 4K7 - which is standard recommendation.

DS recommends yet another approach, called "strong pull-up" which (short) works via a MOS-FET transistor, feeding the DQ lines with enough power, still on 1-wire, during power-consuming tasks. This is not tested, but should naturally work. Because this functionality is really a limited one; BASCOM has no special support for that. But anyway, we tell you about it, just in case you wonder. Strong pull-up has to use one uC pin extra - to drive the MOS-FET.

Cable lengths (this section is only for some limitation understanding)

```vb
For short runs up to 30 meters, cable selection for use on the 1-Wire bus is less critical. Even flat modular phone cable works with limited numbers of 1-Wire devices. However, the longer the 1-Wire bus, the more pronounced cable effects become, and therefore greater importance is placed on cable selection.

For longer distances, DS recommends twisted-pair-cable (CAT5).

```
DS standard examples show 100 meters cable lengths, so they say, that's no problem. They also show examples with 300m cabling, and I think I have seen something with 600-meter bus (but I cant find it again).

Noise and CRC

The longer cable and the noisier environment, the more false readings will be made. The devices are equipped with a CRC-generator - the LSByte of the sending is always a checksum. Look in program examples to learn how to re-calculate this checksum in your uC. AND, if you notice that there are false readings - do something about your cables. (Shield, lower resistor)

Transfer speed

On the original 1-wire bus, DS says the transfer speed is about 14Kbits /second. And, if that was not enough, some devices has an overdrive option. That multiplies the speed by 10. This is issued by making the communication-time-slots smaller (from 60 uS to 6uS ) which naturally will make the devices more sensitive, and CRC-error will probably occur more often. But, if that is not an issue, ~140Kbit is a reachable speed to the devices. So, whatever you thought before, it is FAST.

The BASCOM scanning of the bus is finds about 50 devices / second , and reading a specific sensors value to a uC should be about 13 devices / second.

Topology

Of the 1w-net - that is an issue we will not cover so much. Star-net, bus-net? It seems like you can mix that. It is a bus-net, but not so sensitive about that.

The benefit of the 1-wire bus

Each device is individual - and you can communicate with it over the media of 2 wires. Still, you can address one individual device, if you like. Get its value. There are 64 ^ 2 unique identifications-numbers.

Naturally, if lot of cables are unwanted, this is a big benefit. And you only occupy 1 processor pin.

DS supplies with different types of devices, which all are made for interfacing an uC - directly. No extra hardware. There are sensors, so you can get knowledge about the real world, and there are also potentiometers and relays, so you can do something about it. On the very same bus.

And the Ibutton approach from DS (ever heard of it?) is based on 1wire technology. Maybe something to pick up.

BASCOM let you use an uC with 1wire-devices so easy, that (since now) that also has to count as a benefit - maybe one of the largest. ;-)

The disadvantages of the 1-wire bus

So far as I know, DS is the only manufacturer of sensors for the bus. Some people think their devices are expensive. And, until now, it was really difficult to communicate with the devices. Particularly when using the benefit of several devices on one bus. Still some people say that the 1w-bus is slow - but I don't think so.

GÃ¶te Haluza

System engineer

---

## Using the UART

UART

A Universal Asynchronous Receiver and Transmitter (UART) can be used to send and receive data between two devices. More specific these devices can be PC-to-PC, PC-to-micro controller and micro controller-to-micro controller. The UART communicates using TTL voltages +5V and 0V or LVTTL depending on your micro controllers VCC voltage.

If you wish to connect to a PC you need to use RS232 protocol specifications. This means that the hardware communication is done with specific voltage levels. (+15V and -15V) This can be achieved by using a MAX232 level shifter.

The hardware is explained in this schematic:

![UART](uart.png)

The DB-9 connector has 9 pins but you only need to use 3 of them. Notice that the drawing above shows the FRONT VIEW thus remember that you are soldering on the other side. On most connectors the pin outs can also be found on the connector itself.

If your controller has no UART you can use a software UART see below. If your controller has one UART you connect controller pins TxD and RxD to TxD and RxD in the schematic above. If your controller has more than one UART you connect controller pins TxD0 and RxD0 to TxD and RxD in the schematic above.

You now need to initialize the program in your micro controller, open a new .bas file and add the following code in the beginning of your program.

```vb
$regfile = "your micro here def.dat"

$crystal = 8000000

$baud = 19200

```
Make sure to define your micro controller after $regfile for example if you use the ATMega32

$regfile = "m32def.dat"

Some new chips can use an internal oscillator, also some chips are configured to use the internal oscillator by default. Using an internal oscillator means you do not need an external crystal.

Perform this step only if you have an internal oscillator.

Open the BASCOM-AVR programmer like this:

![UART_PG](uart_pg.png)

•| Select the âLock and Fuse Bitsâ tab and maximize the programmer window.  
---|---  
  
•| Check if you see the following in the âFusebitâ section:  
---|---  
  
"1:Divide Clock by 8 Disabled"

and

"Int. RC Osc. 8 MHz; Start-up time: X CK + X ms; [CKSEL=XXXX SUT=XX]"

![UART_fusebits](uart_fusebits.png)

These options are not available for all AVRâs, if you donât have the option do not change any fuse bits.

If these options are available, but in a wrong setting. Change the setting in the drop down box and click another Fuse section. Finally click the "Program FS" button. Click "Refresh" to see the actual setting.

Now connect a straight cable between the DB-9 connector, micro controller side and the PC side.

Program a test program into your micro controller, it should look like this:

```vb
$regfile = "m32def.dat" 'Define your own

$crystal = 8000000 

$baud = 19200 

Do

Print "Hello World"

Waitms 25

Loop

End

```
Now open the BASCOM-AVR Terminal and set your connection settings by clicking âTerminalâ -> âSettingsâ Select your computers COM port and select baud 19200, Parity none, Data bits 8, Stop bits 1, Handshake none, emulation none.

![UART_terminal](uart_terminal.png) ![UART_TerminalShow](uart_terminalshow.png)

If you see the Hello World displayed in the BASCOM-AVR Terminal emulator window, your configuration is OK. Congratulations.

Example

You can also try this example with the BASCOM Terminal emulator, it shows you how to send and receive with various commands.

```vb
$regfile = "m88def.dat"

$crystal = 8000000

$baud = 19200

Dim Akey As Byte 'Here we declare a byte variable

Print

Print "Hello, hit any alphanumerical key..."

```
Akey = Waitkey() 'Waitkey waits untill a char is received from the UART

```vb
Print Akey

Wait 1

Print

Print "Thanks!, as you could see the controller prints a number"

Print "but not the key you pressed."

Wait 1

Print

Print "Now try the enter key..."

```
Akey = Waitkey()

Akey = Waitkey()

```vb
Print Akey

Print

Print "The number you see is the ASCII value of the key you pressed."

Print "We need to convert the number back to the key..."

Print 'Notice what this line does

Print "Please try an alphanumerical key again..."

```
Akey = Waitkey()

```vb
Print Chr(akey) 'Notice what this does

Print "That's fine!"

Wait 1

Print

Print "For a lot of functions, just one key is not enough..."

Print "Now type your name and hit enter to confirm"

Dim Inputstring As String * 12 'Declare a string variable here

Do

```
Akey = Waitkey()

If Akey = 13 Then Goto Thanks 'On enter key goto thanks

Inputstring = Inputstring + Chr(akey) 'Assign the string

Loop

Thanks:

```vb
Print "Thank you " ; Inputstring ; " !" 'Notice what ; does

Wait 1

Print

Print "Take a look at the program code and try to understand"

Print "how this program works. Also press F1 at the statements"

Print

Print "If you understand everything continue to the next experiment"

End

```
ASCII

As you could have seen in the previous example we use the PRINT statement to send something to the UART. Actually we do not send just text. We send ASCII characters. ASCII means American Standard Code for Information Interchange. Basically ASCII is a list of 127 characters.

ASCII Table (Incomplete)

Decimal Hex Binary Value

\------- --- ------ -----

000 000 00000000 NUL (Null char.)

008 008 00001000 BS (Backspace)

009 009 00001001 HT (Horizontal Tab)

010 00A 00001010 LF (Line Feed)

012 00C 00001100 FF (Form Feed)

013 00D 00001101 CR (Carriage Return)

048 030 00110000 0

049 031 00110001 1

052 034 00110100 4

065 041 01000001 A

066 042 01000010 B

067 043 01000011 C

You can find a complete ASCII table [here](asciichart.md)

CARRIAGE RETURN (CR) AND LINE FEED (LF)

In the previous example you can also see that a second print statement always prints the printed text to the following line. This is caused by the fact that the print statement always adds the CR and LF characters.

Basically if we state:

Print âABCâ

We send 65 66 67 13 10 to the UART. (In binary format)

The carriage return character (13) returns the cursor back to column position 0 of the current line. The line feed (10) moves the cursor to the next line.

Print âABCâ ;

When we type a semicolon ( ; ) at the end of the line...

Bascom does not send a carriage return/line feed, so you can print another text after the ABC on the same line.

Print âABCâ ; Chr(13) ;

This would send only ABC CR. The next print would overwrite the ABC.

OVERVIEW

Here are some other commands that you can use for UART communications:

Waitkey()

Waitkey will until a character is received in the serial buffer.

Ischarwaiting()

Returns 1 when a character is waiting in the hardware UART buffer.

Inkey()

Inkey returns the ASCII value of the first character in the serial input buffer.

Print

Sends a variable or non-variable string to the UART

ANOTHER EXAMPLE

This example shows how to use Ischarwaiting to test if there is a key pressed. And if there is, read to a variable.

```vb
'Print "Press B key to start"

Dim Serialcharwaiting As Byte, Serialchar As Byte

```
Serialcharwaiting = Ischarwaiting() 'Check if B or b pressed then goto

If Serialcharwaiting = 1 Then

Serialchar = Inkey()

```vb
If Serialchar = 66 Or Serialchar = 98 Then

Goto MyRoutine

End If

End If

Goto Main

```
Myroutine:

'Statements

Main:

```vb
'Statements

End

```
BUFFERING SERIAL DATA

If you wish to send and receive data at high speed, you need to use serial input and serial output buffers. This buffering is implemented in BASCOM-AVR and can only be used for hardware UARTâs.

To configure a UART to use buffers, you need to use the Config statement.

Config Serialout = Buffered , Size = 20

and/or

Config Serialin = Buffered , Size = 20

More information can be found in BASCOM-Help. Search topic = "[config serialin"](config_serialin.md). There is also a sample program âRS232BUFFER.BASâ in the samples folder if you wish a demonstration of the buffering.

SOFTWARE UART

The previous examples used the hardware UART. That means the compiler uses the internal UART registers and internal hardware (RxD(0) and TxD(0)) of the AVR. If you donât have a hardware UART you can also use a software UART.

The Bascom compiler makes it easy to âcreateâ additional UARTâs. Bascom creates software UARTâs on virtually every port pin. 

Remember that a software UART is not as robust as a hardware UART, thus you can get timing problems if you have lots of interrupts in your program.

For this example we use micro controller pins portc.1 and portc.2.

Connect portc.1 to TxD and portc.2 to RxD see the schematic above.

Change the $regfile and program this example:

```vb
$regfile = "m88def.dat"

$crystal = 8000000

$baud = 19200

Dim B As Byte

Waitms 100

'Open a TRANSMIT channel for output

```
Open "comc.1:19200,8,n,1" For Output As #1

```vb
Print #1 , "serial output"

'Now open a RECEIVE channel for input

```
Open "comc.2:19200,8,n,1" For Input As #2

```vb
'Since there is no relation between the input and output pin

'there is NO ECHO while keys are typed

Print #1 , "Press any alpha numerical key"

'With INKEY() we can check if there is data available

'To use it with the software UART you must provide the channel

Do

'Store in byte

```
B = Inkey(#2)

```vb
'When the value > 0 we got something

If B > 0 Then

Print #1 , Chr(b) 'Print the character

End If

Loop

```
Close #2 'Close the channels

Close #1

End

After you have programmed the controller and you connected the serial cable, open the terminal emulator by clicking on ![terminal-icon](terminal-icon.png) in Bascom.

You should see the program asking for an alphanumerical input, and it should print the input back to the terminal.

---

## Using USI (Universal Serial Interface)

The Universal Serial Interface (USI) is a multi purpose hardware resource which provide the basics hardware for various serial communications and is faster and reliable then implementing it in software.

You mainly find the USI on ATTINY devices but also for example on ATMEGA169.

USI Features:

•| Two-wire Synchronous Data Transfer  
---|---  
  
â¢ Three-wire Synchronous Data Transfer 

â¢ Data Received Interrupt 

â¢ Wakeup from Idle Mode 

The USI can be used in Two wire mode and in three wire mode:

•| 2 wire mode --> I2C/TWI  
---|---  
  
•| 3 wire mode --> SPI  
---|---  
  
The USI handle only the low level communication. High level communication for example for 2 wire mode (I2C) like address setting, message interpreting or preparing of data needs to be handled by software in the main loop.

There are Application Notes from Atmel available: 

[AVR312: Using the USI module as a I2C slave](<http://www.atmel.com/Images/doc2560.pdf>)

[AVR310: Using the USI module as a I2C master](<http://www.atmel.com/Images/doc2561.pdf>)

The 3 wire mode (SPI) is easier to implement and therefore shown here as an example.

The Slave Select (SS) needs to be implemented in software if needed.

The USI Pin names are: DI, DO and USCK.

[AVR319: Using the USI module for SPI communication](<http://www.atmel.com/Images/doc2582.pdf>)

See also:

[Using the SPI protocol](using_the_spi_protocol.md), [SPISLAVE](spislave.md), [Using I2C Protocol](using_the_i2c_protocol.md), [confiig TWISLAVE](config_twislave.md), [I2C TWI Slave](i2ctwislave.md) , [USI as TWI Slave](config_usi.md)

Following an example how to use an ATTINY as an SPI Master and another example show an SPI Slave over USI.

Example (SPI Master with USI):

1\. Configure the port pin's:

```vb
'---------Using ATTINY as SPI MASTER over USI-----------------------------------  
Config Portb.2 = Output 'USCK ----> SCK (Slave)  
Config Portb.1 = Output 'DO ----> SDI (Slave)  
Config Portb.0 = Input 'DI ----> SDO (Slave)  
Set Portb.0  
```
Sdo Alias Pinb.0 'Pullup

2\. Configure the Slave Select

```vb
Config Portb.3 = Output 'Slave Select (SS) ----> SEL (Slave)  
Set Portb.3  
```
Sel Alias Portb.3

3\. Configure the 3 wire mode

```vb
Set Usicr.usiwm0 'Three-wire mode. Uses DO, DI, and USCK pins.  
  
'The Data Output (DO) pin overrides the corresponding bit in the PORTA  
'register. However, the corresponding DDRA bit still controls the data direction.  
'When the port pin is set as input the pin pull-up is controlled by the PORTA bit.  
'The Data Input (DI) and Serial Clock (USCK) pins do not affect the normal port  
'operation. When operating as master, clock pulses are software generated by  
'toggling the PORTA register, while the data direction is set to output. The  
'USITC bit in the USICR Register can be used for this purpose.

```
4\. Function for send or receive a byte over USI (SPI Master mode)

Const Usi_clk_low = &B0001_0001  
Const Usi_clk_high = &B0001_0011  
  
```vb
'Wirte or read a byte over USI in SPI Master Mode  
Function Usi_byte(usi_out As Byte) As Byte  
```
Local I As Byte  
Usidr = Usi_out 'Byte to write over USI  
For I = 1 To 8  
Usicr = Usi_clk_low 'Toggle the USI Clock to send or receive the single bits over USI (8 Bit)  
Usicr = Usi_clk_high  
Next  
Usi_byte = Usidr 'Byte received over USI  
End Function

5\. call the function to send/receive a byte

Reset Sel  
Usi_return = Usi_byte(my_byte)  
Set Sel

Example (SPI Slave with USI):

The following example show how to use an USI of ATTINY85 as SPI SLAVE.

(you will also find the SPI Master for this USI of ATTINY85 as SPI SLAVE example)

ATXMEGA (SPI Master) <\-----SPI------> (SPI Slave over USI) ATTIN85

1\. First we configure the USI in Three-wire Mode

2\. Setup the USI Overflow Interrupt

3\. And wait until the USI Oveflow Interrupt is fired

4\. Then we read the USI Data-Register and clear the USI Interrupt flag

  
```vb
' Using USI as an SPI slave with Attiny85  
' The ATTINY85 work with 3.3 V so we can direct connect it to an ATXMEGA  
' Following you find also a SPI configuration with an XMEGA as SPI Master which I have tested with this SPI Slave  
  
'(  
Config Spid = Hard , Master = Yes , Mode = 0 , Clockdiv = Clk128 , Data_order = Msb , Ss = Auto  
'SS = Auto set the Slave Select (SS) automatically before a print #X or input #X command (including initialization of the pin)  
'Master SPI clock = 32MHz/Clk128 = 250KHz  
```
Open "SPID" For Binary As #12  
```vb
')  
  
$regfile = "ATtiny85.DAT"   
$crystal = 8000000 'internal crystal  
$hwstack = 32   
$swstack = 10   
$framesize = 30  
  
Dim B As Byte  
Dim Usi_data_ready As Bit  
  
Config Portb.1 = Output 'DO ---> MISO of ATXMEGA (PD6)  
  
Config Portb.2 = Output 'USCK ---> SCK of ATXMEGA (PD7)  
Set Portb.2 'enable Pullup  
  
Config Portb.0 = Input 'DI ---> MOSI of ATXMEGA (PD5)  
Set Portb.0 'enable Pullup  
  
'We do not use Slave Select in this example but this would be the configuration  
Config Portb.4 = Input 'Slave Select  
Set Portb.4 ' enable Pullup  
```
Ss Alias Pinb.4  
  
  
Config Portb.3 = Output 'Serial Debug output  
Open "comb.3:9600,8,n,1" For Output As #1  
```vb
Print #1 , "serial output"  
  
'Init USI as SPI Slave in USICR = USI Control Register  
Set Usicr.usiwm0 'Three-wire mode. Uses DO, DI, and USCK pins.  
Set Usicr.usics1 'Clock Source: External, positive edge ; External, both edges  
Set Usicr.usioie 'USI Counter Overflow Interrupt Enable  
  
  
On Usi_ovf Usi_overflow_int  
Enable Usi_ovf  
Enable Interrupts  
  
  
Do  
If Usi_data_ready = 1 Then  
Reset Usi_data_ready  
Print #1 , B 'print the received byte over debug output  
End If  
Loop  
  
End 'end program  
  
  
' After eight clock pulses (i.e., 16 clock edges) the 4-Bit USI counter will generate an overflow interrupt  
' A USI Overflow Int can also wakeup the Attiny from Idle mode if needed  
```
Usi_overflow_int:  
Set Usi_data_ready  
B = Usidr  
Usisr = &B01_000000 'Reset Overflow Flag and reset 4-Bit USI counter  
Return

SPI Master for the ATTIN85 as SPI Slave over USI:

  
  
```vb
'This is the SPI MASTER for the ATTINY85 with USI in SPI Slave Mode  
  
$regfile = "xm256a3bdef.dat"  
$crystal = 32000000 '32MHz  
$hwstack = 64  
$swstack = 40  
$framesize = 80  
  
  
Config Osc = Disabled , 32mhzosc = Enabled  
Config Sysclock = 32mhz '--> 32MHz  
  
'configure the priority  
Config Priority = Static , Vector = Application , Lo = Enabled , Med = Enabled  
Enable Interrupts  
  
Config Com7 = 57600 , Mode = Asynchroneous , Parity = None , Stopbits = 1 , Databits = 8  
Waitms 2  
```
Open "COM7:" For Binary As #1  
```vb
Print #1 ,  
Print #1 , "------------SPI MASTER-Slave Test----------------"  
  
  
'We use Port D for SPI  
Config Pind.7 = Output  
Config Pind.6 = Input  
Config Pind.5 = Output  
Config Pind.4 = Output  
'Bit7 = SCK = Output ------> USCK (ATTINY85) (PinB.2)  
'Bit6 = MISO = Input ------> DO (ATTINY85) (PinB.1)  
'Bit5 = MOSI = Output ------> DI (ATTINY85) (PinB.0)  
'Bit4 = SS = Output ------> SS (ATTINY85) (PinB.4)  
```
Slave_select Alias Portd.4  
Set Slave_select  
  
Portd_pin4ctrl = Bits(3 , 4) ' Enalbe Pullup  
  
  
```vb
Dim Bspivar As Byte  
Dim Spi_send_byte As Byte  
Dim Spi_receive_byte As Byte  
Dim Spi_master_want_send As Byte  
  
  
'SPI, Master|Slave , MODE, clock division  
Config Spid = Hard , Master = Yes , Mode = 0 , Clockdiv = Clk128 , Data_order = Msb , Ss = Auto  
'SS = Auto set the Slave Select (SS) automatically before a print #X or input #X command (including initialization of the pin)  
'Master SPI clock = 32MHz/Clk128 = 250KHz  
```
Open "SPID" For Binary As #12  
  
Main:  
  
```vb
Do  
Wait 3 'Every 3 seconds  
  
```
Incr Spi_send_byte  
```vb
Print #1 , "Spi_send_byte = " ; Spi_send_byte  
'SEND TO SLAVE  
Print #12 , Spi_send_byte 'SEND one BYTE TO SLAVE  
  
Waitms 10  
  
Input #12 , Spi_receive_byte  
Print #1 , Spi_receive_byte  
Loop  
  
  
  
End 'end program  
  
'there is NO CLOSE for SPI  
  
  
  
'

```

---

## VAL

Action

Converts a string representation of a number into a number.

Syntax

var = VAL( s)

Remarks

Var | A numeric variable that is assigned with the value of s.  
---|---  
S | Variable of the string type.  
  
It depends on the variable type which conversion routine will be used. Single and Double conversion will take more code space.

When you use INPUT, internal the compiler also uses the VAL routines.

In order to safe code space, there are different conversion routines. For example BINVAL and HEXVAL are separate routines.

While they could be added to the compiler, it would mean a certain overhead as they might never be needed.

With strings as input or the INPUT statement, the string is dynamic and so all conversion routines would be needed.

The VAL() conversion routine does not check for illegal characters. If you use them you get a wrong result or 0.

If you want to check for illegal characters you can add a constant named _VALCHECK to your code with a value of 1.

This will include some code that will set the internal ERR variable to 0 or 1. If illegal characters are found, ERR will return 1.

Since VAL is used for the INPUT statement too, this will also work for the INPUT statement.

See also

[STR](str.md) , [HEXVAL](hexval.md) , [HEX](hex.md) , [BIN](bin.md) , [BINVAL](binval.md) , [STR2DIGITS](str2digits.md)

Example

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

Dim A As Byte , S As String * 10

```
S = "123"

A = Val(s) 'convert string

Print A ' 123

S = "12345678"

Dim L As Long

L = Val(s)

```vb
Print L

End

```
Example2

```vb
$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Config Com1 = Dummy , Synchrone = 0 , Parity = None , Stopbits = 1 , Databits = 8 , Clockpol = 0

```
Const _VALCHECK=1 ' TEST VAL()

Dim A As Byte , S As String * 10

S = "123"

A = Val(s) 'convert string

Print A ; " ERR:" ; Err ' 123

S = "1234a5678"

Dim L As Long

L = Val(s)

```vb
Print L ; " ERR:" ; Err

End

```

---

## VARPTR

Action

Retrieves the memory-address of a variable.

Syntax

var = VARPTR( var2 )

var = VARPTR( "var3" )

Remarks

Var | The variable that receives the address of var2.  
---|---  
Var2 | A variable to retrieve the address from.  
var3 | A constant  
  
Sometimes you need to know the address of a variable, for example when you like to peek at it's memory content.

The VARPTR() function assigns this address.

You can also get the address of a register using VARPTR.

The address of registers are constants you can find in the DAT file.

See also

[LOADADR](loadadr.md) , [SIZEOF](sizeof.md) , [CONFIG VARPTRMODE](config_varptrmode.md)

Example

```vb
Dim W As Byte

Print Hex(varptr(w)) ' 0060 depends on processor

```

---

## VER

Action

Returns the AVR-DOS version

Syntax

result = VER()

Remarks

Result | A numeric variable that is assigned with the AVR-DOS version. The version number is a byte and the first release is version 1.  
---|---  
  
When you have a problem, MCS can ask you for the AVR-DOS version number. The VER() function can be used to return the version number then.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [WRITE](write.md) , [INPUT](input.md)

![notice](notice.jpg)The [VERSION](version.md)() function is something different. It is intended to include compile time info into the program.

ASM

Calls | _AVRDOSVer  
---|---  
|   
Input | -  
Output | R16 loaded with value  
  
Example

Print Ver()

---

## VERSION

Action

Returns a string with the date and time of compilation.

Syntax

Var = VERSION(frm)

Remarks

Var is a string variable that is assigned with a constant. This version constant is set at compilation time to MM-DD-YY hh:nn:ss Where MM is the month, DD the day of the month, YY the year. hh is the hour is 24-hour format, nn the minutes, and ss the seconds.  
---  
When frm is set to 1, the format date will be shown in European DD-MM-YY hh:nn:ss format.  
When frm is set to 2, the version info from $VERSION will be used.  
When frm is set to 3, the filename will be used.  
When frm is set to 4, the version info from $VERSION will be used without the separating dots. So 1.2.3 will become 123.  
When frm is a string constant, the string constant will be used.  
  
While it is simple to store the version of your program in the source code, it is harder to determine which version was used for a programmed chip.

The Version() function can print this information to the serial port, or to an LCD display.

See Also

[VER](ver.md) , [$VERSION](_version.md)

Example

Print Version()

---

## Vertex2f

Action

Start the operation of graphics primitives at the specified screen coordinate, in 1/16th pixel precision.

Syntax

Vertex2f x, y

Remarks

x | x-coordinate in 1/16 pixel precision (Integer)  
---|---  
y | y-coordinate in 1/16 pixel precision (Integer)  
  
The range of coordinates can be from -16384 to +16383 in terms of 1/16 th pixel units. 

The Vertex2F command allows negative coordinates. It also allows fractional coordinates, because it specifies screen (x,y) in 

units of 1/16 of a pixel.

Please note the negative x coordinate value means the coordinate in the left virtual screen from (0, 0), while the negative y coordinate value means the coordinate in the upper virtual screen from (0, 0). If drawing on the negative coordinate position, the drawing operation will not be visible

See also

[BEGIN_G](begin_g.md) , [END_G](end_g.md) , [VERTEX2II](vertex2ii.md)

Example

ClearColorRGB 5, 45, 10

ColorRGB 255, 168, 64

Clear_B 1 ,1 ,1

Begin_G EDGE_STRIP_R

Vertex2F 16 * 16, 16 * 16

Vertex2F (FT_DispWidth * 2 / 3) * 16, (FT_DispHeight * 2 / 3) * 16

Vertex2F (FT_DispWidth - 80) * 16, (FT_DispHeight - 20) * 16

UpdateScreen

---

## Vertex2ii

Action

Start the operation of graphics primitive at the specified coordinates in pixel precision. 

Syntax

Vertex2ii x, y, handle, cell

Remarks

x | x-coordinate in pixels, from 0 to 511  
---|---  
y | y-coordinate in pixels, from 0 to 511  
handle | Bitmap handle. The valid range is from 0 to 31. From 16 to 31, the bitmap handle is dedicated to the FT800 built-in font.  
cell | Cell number. Cell number is the index of bitmap with same bitmap layout and format. For example, for handle 31, the cell 65 means the character "A" in the largest built in font.  
  
The Vertex2II command only allows positive screen coordinates.

If the bitmap is partially off screen, for example during a screen scroll, then it is necessary to 

specify negative screen coordinates (with Vertex2F).

The handle and cell parameters will be ignored unless the graphics primitive is specified as bitmap by command [Begin_G](begin_g.md), prior to this command.

See Also

[BEGIN_G](begin_g.md) , [END_G](end_g.md) , [VERTEX2F](vertex2f.md)

Example

Clear_B 1, 1, 1 ' Clear Screen

BitmapSource RAM_G

BitmapLayout BARGRAPH, 256, 1

BitmapSize NEAREST, Border, Border, 256, 256

Begin_G BITMAPS

ColorRGB 255, 0, 0

' Display bargraph At hoffset, voffset location

Vertex2II 0, 0, 0, 0

Vertex2II 256, 0, 0, 1

ColorRGB 0, 0, 0

Vertex2II 0, 4, 0, 0

Vertex2II 256, 4, 0, 1

UpdateScreen

---

## WAIT

Action

Suspends program execution for a given time.

Syntax

WAIT seconds

Remarks

seconds | The number of seconds to wait.  
---|---  
  
No accurate timing is possible with this command.

When you use interrupts, the delay may be extended.

See also

[DELAY](delay.md) , [WAITMS](waitms.md)

Example

```vb
WAIT 3 ' wait for three seconds

Print "*"

```

---

## WaitCmdFifoEmpty

Action

Executes Commands in the FIFO buffer.

Syntax

WaitCmdFifoEmpty

Remarks

WaitCmdFifoEmpty polls a loop checking the state of the Reg_Cmd_Read and Reg_Cmd_Write registers

to see whether the FT800 has executed the commands in the FIFO buffer.

If the your code is long you have to be careful it's not more than 4K otherwise you can get

overflows/corruption.

Inserting WaitCmdFifoEmpty in area of your code allows you to execute parts of your code

instantly, but be aware it won't display any Graphics and don't use it for Graphics Display

(use [UpdateScreen)](updatescreen.md)

---

## WAITKEY

Action

Wait until a character is received.

Syntax

var = WAITKEY()

var = WAITKEY(#channel)

Remarks

var | Variable that receives the ASCII value of the serial buffer. Can be a numeric variable or a string variable.  
---|---  

```vb
#channel | The channel used for the software UART.  
  
While Inkey() returns a character from the serial buffer too, INKEY() continues when there is no character. Waitkey() waits until there is a character received. This blocks your program.

```
See also

[INKEY](inkey.md) , [ISCHARWAITING](ischarwaiting.md) , [$TIMEOUT](_timeout.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : inkey.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: INKEY , WAITKEY

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte , S As String * 2

Do

```
A = Inkey() 'get ascii value from serial port

```vb
's = Inkey()

If A > 0 Then 'we got something

Print "ASCII code " ; A ; " from serial"

End If

Loop Until A = 27 'until ESC is pressed

```
A = Waitkey() 'wait for a key

```vb
's = waitkey()

Print Chr(a)

'wait until ESC is pressed

Do

Loop Until Inkey() = 27

'When you need to receive binary data and the bibary value 0 ,

'you can use the IScharwaiting() function.

'This will return 1 when there is a char waiting and 0 if there is no char waiting.

'You can get the char with inkey or waitkey then.

End

```

---

## WAITMS

Action

Suspends program execution for a given time in mS.

Syntax

WAITMS mS

Remarks

Ms | The number of milliseconds to wait. (1-65535)  
---|---  
  
No accurate timing is possible with this command.

In addition, the use of interrupts can slow this routine.

See also

[DELAY](delay.md) , [WAIT](wait.md) , [WAITUS](waitus.md)

ASM

WaitMS will call the routine _WAITMS. R24 and R25 are loaded with the number of milliseconds to wait.

Uses and saves R30 and R31.

Depending on the used XTAL the asm code can look like :

_WaitMS:

_WaitMS1F:

Push R30 ; save Z

Push R31

_WaitMS_1:

Ldi R30,$E8 ; delay for 1 mS

Ldi R31,$03

_WaitMS_2:

Sbiw R30,1 ; -1

Brne _WaitMS_2 ; until 1 mS is ticked away

Sbiw R24,1

Brne _WaitMS_1 ; for number of mS

Pop R31

Pop R30

Ret

Example

```vb
WAITMS 10 ' wait for 10 mS

Print "*"

```

---

## WAITUS

Action

Suspends program execution for a given time in uS.

Syntax

WAITUS uS

Remarks

US | The number of microseconds to wait. (1-65535) This must be a constant. Not a variable! In version 1.12.x.x and higher you can use a variable as well.  
---|---  
  
No accurate timing is possible with this command. For accurate timing you can best use a timer.

In addition, the use of interrupts can slow down this routine.

The minimum delay possible is determined by the used frequency.

The number of cycles that are needed to set and save registers is 17.

When the loop is set to 1, the minimum delay is 21 uS. In this case you can better use a NOP that generates 1 clock cycle delay.

At 4 MHz the minimum delay is 5 uS. So a waitus 3 will also generate 5 uS delay.

Above these values the delay will become accurate.

In version 2.0.7.6 the compiler will create different code depending on the $CRYSTAL value and the specified delay.

When you use a constant, the timing is reasonable accurate. When using a variable, the timing accuracy depends on the oscillator speed.

As a general rule : the higher the clock speed, the better the result. 

When you really need an accurate delay you should use a timer.

Set the timer to a value and poll until the overflow flag is set. The disadvantage is that you can not use the timer for other tasks during this hardware delay.

The philosophy behind BASCOM is that it should not use hardware resources unless there is no other way to accomplish a task.

See also

[DELAY](delay.md) , [WAIT](wait.md) , [WAITMS](waitms.md)

Example

WAITUS 10 ' wait for 10 uS

Print "*"

---

## What is new in 2078-2079

Beta version 2079

\- Support for WS2812 RGB led : [CONFIG RAINBOW](config_rainbow.md). This is the rainbow lib from Galahat, see : <http://bascom-forum.de/mediawiki/index.php/Rainbow_Lib>

\- [SETATTR](setattr.md) and [CLEARATTR](clearattr.md) added to AVR-DOS, by Josef.

\- shift & rotate left/right did not work for xmega port registers

\- IDE : improved speed for showing deadcode/unused variables

\- IDE : stacktrace speed up. big projects made the stacktrace slow.

\- included FT801 support. See [CONFIG FT800](config_ft800.md). Notice that the INC files have been renamed into FT80x

\- fixed attiny261,461 and 861 interrupt entries. this chip has only 1 pcint.

\- added check when [$loadersize](loadersize.md) and [$boot](_boot.md) are combined.

\- [Dim](dim.md) supports a list ; dim a,b,c,d as byte. It also supports identifiers like %,#,& and !

\- Font Editor plugin is replaced by integrated Font Editor: [Tools, Font Editor](tools_font_editor.md)

\- Sample added for [USI Slave lib](i2c_usi_slave.md)

\- fonts contributed by Adam Siwek included. You can find them in the Samples\LCDgraph\Fonts folder.

\- [report](program_show_result.md) can be opened in IDE as text file.

\- [mySmartUSB light](mysmartusb_light.md) programmer support added.

\- support added for [W5500](config_tcpip.md) tcp/ip chip

\- W5500 [socketconnect](socketconnect.md) has a 4-th parameter : nowait. When you make it 1, there is no wait for connection.

\- [$ROMSTART](_romstart.md) added : $romstart = &H8000 , will let the code start at &H8000. Default is 0.

\- jtag ice mkII programmer new firmware 7.26 from AVR studio resulted in signoff problem. Workaround implemented.

\- editor can show unused code in conditional compilation. [Edit, Show Excluded Code](edit_show_excluded_code.md) menu option.

\- usbasp programmer updated. chosen clock frequency will work.

\- makemodbus() did not support locals/passed parameters properly.

\- [crc16](crc16.md) can now directly read a range from eeprom memory to calculate a checksum for you. To enable it, just add const CRC16_EEPROM=1 to the beginning of your code.

\- simulator fix for xmega low IO registers. registers were simulated with a 32 byte offset as in plain AVR.

\- [config lcd ](config_lcd.md)has 2 new options : BEFORE and AFTER. with a parameter value of 1 a sub will be called _lcdBefore and _lcdAfter

just before the LCD is used. This allows for example to turn off interrupts when executing LCD code.

Only text LCD is supported.

\- [getadc](getadc.md)() when used on normal AVR with offset parameter, and both parameters numeric will give an error when MUX5 bit must be set.

Use getadc() with just the channel parameter.

\- multi dim arrays, added ERAM byte support, and used registers are saved now.

\- saving programming buffer as HEX file created wrong HEX files which would not load in AVR Studio. This would occur for chips with multiple segments like xmega128 

\- Full [Kamprog](kamprog_for_avr.md) support added.

\- multi dim arrays had no check on invalid index value (non dimmed)

\- using a constant float without leading 0 resulted in an error message : var= var + .12344

\- INPUT did not support DWORD. 

\- added user definable command buttons to [terminal emulator](tools_terminal_emulator.md).

\- using {} in constants was not working as expected : Const Cmd_suffix_ver1 = Asc( "{013}") was not interpreted as 13 but 123 (the { sign)

\- changed [PDF download](tools_pdf_update.md) from HTTP to FTP. This is quicker and better for the load of the server. PORT 211 is used for FTP. So you need to have port 211 open on your firewall. 

\- atxmega128c3 added. 

\- [FT800](ft800.md), vertex2ii , the X is clipped. Change call in sub vertex2II into Cmd32 _vertex2ii(___wtmpb , R18 , R17 , R16)

\- support for [EADOGXL240-7 I2C](glcdeadogmxl240_7_i2c.md) added, see eadogxl240-7.bas. This is a customer sponsored lib.

\- added support for [SSD1306 I2C](glcddssd1306_i2c.md) OLED, see SSD1306-I2C.BAS. 

\- i2c multi bus lib did not clear ERR bit correctly. 

\- when a multi dim array is only used within sub/functions and submode=new is used, an error was raised since the index table was not written at that stage. 

\- multi dim arrays can only be used to read/assign variables. Using them in functions and statements will not work. 

\- [str](str.md)() can have an optional parameter to specify the amount of digits. This works for double, but now also for singles. 

\- [MOD](mod.md) for singles changed in fp_trig.lib so it uses the same algorithm as excel/VBA.

\- FOR..NEXT with WORD data type and STEP with values other than 1 failed : for w=1 to 10 step 2 

\- when opening a single file in non-project mode, the code explorer does not get updated until you set the cursor on the code.

This also resulted in not updating the pinout viewer. 

\- R0-R31 internal variables are now exposed as byte variables. This is simpler than using getreg/setreg. 

\- added option to skip eeprom cell test. This allows to write all FF to the EEPROM whithout erasing the chip. 

\- terminal emulator font color could not be selected from the font dialog. 

\- various programmers : added chip name to info panel when chip does not match. no match will result in a red font, a match will show in green. 

\- added an error message when $hwstack,$swstack and $framesize are missing from the source. Also put back compatibility to 2077 when these directives are not specified. 

\- hovering the indention line will show the begin of the structure in the tool tip (just try it).

\- [Terminal emulator](tools_terminal_emulator.md) has 8 user definable buttons

\- [SEROUT](serout.md) defaults to CONST SEROUT_EXTPULL=1 to be in Hi-Z mode. In this mode a pull up resistor is required. To use PORT output mode, set the constant to 0 : CONST SEROUT_EXTPULL=0

2.0.7.8.001 public release

\- changing a bit on a passed array inside a sub/function gave a bit index error. 

\- while moving all single FP code to fp_trig.lib, some double (but WRONG) functions were moved to the top. It causes various problems.

\- clear buffer did not reset the RST pin in case CTS/RTS was used. 

\- val()/asc2float contained a bug for converting big values not fitting into the mantissa. The exponent was not increased. 

\- [asc](asc.md)() can have an additional index parameter : byte=Asc(string|string constant[,index]). Use this instead of asc(mid( 

\- user functions/subs can have a custom color 

\- added support for i2c lcd display RX1602A5. Use : config lcd = 16x2 , chipset = st7032. See sample LCD-RX1602A5.bas

\- using overlay pointing to a string array resulted in a wrong overlay address. 

\- additional XTEA2.LIB added. This lib complies with the original standard. 

\- Tab order can be changed with drag and drop. 

\- USI master TWI mode added. 

\- when config submode=new was used, the syntax check could give false errors. 

\- mkII programmer would give a warning about chip mismatch when atmel chip ID was the same. 

\- pulsein.lib was missing from distribution. 

\- documented beta switches [$NOTYPECHECK](notypecheck.md), [$TYPECHECK](typecheck.md) and [$REDUCEIVR](reduceivr.md)

\- when using a serial boot loader compiled with an older version, and when calling it from code (not after a reset) you need to reset the u2x flag in ucsrxA.

Or you can compile both the bootloader and main code with the new version. When you want the old behaviour, you can remark the u2x constant in the dat file. 

\- FLIP programmer will not erase EEPROM anymore. 

\- use ALT key to select blocks of text in the editor. 

\- hint window location fixed for multi monitors systems. 

\- [rgb8to16](rgb8to16.md)() function added to convert RGB8 to RGB16. 

\- xmega, config OSC : when using external osc, the oscillator ready test was not working properly. enable the internal osc as a workaround in 2077. fixed in this release.

\- arduino leonardo can be programmed with myAVR MK2/AVR910. You need to give a manual reset before pressing F4. 

\- attiny87 dat file contained an error : INTADR = 1 ; it was 2 but must be 1 

\- xmega spi length parameter supported globals only. now it supports locals and parameters as well. 

\- syntax check gave errors when config submode=new was used in some cases. 

\- 1wirecount returned with ERR set, even when sensors were found. 

\- [simulator](program_simulate.md) has trace log option to dump all executed lines to a file. 

\- error list content can be copied to clipboard with right mouse popup menu 

\- xmega uarts 5-8 serial buffered output enable the wrong uart. 

\- indention line colors can be customized. 

\- [proper indent ](edit_proper_indent.md)will not indent comment 

\- [getkbd](getkbd.md)() required change for xmega. (xmega does not use port register for pull up) 

\- added dword support to lookup() 

\- [config rnd](config_rnd.md)=16|32 added to support bigger random numbers. 

\- attiny441 stk500 settings changed. attiny441 and attiny841 verified with real chips. some mods made to the dat files. 

\- increased internal constant string storage length to 1024. for cases like : s="some very long constant". previously the max size was 256. 

\- xmegaE5 timers 4/5 support added. 

\- xmegaE timer4/5 OVF bit need a manual reset, writing a 1 to intflags register. it is not cleared automatically. 

\- xm128a1U dat file added 

\- code folding added to editor. Press F11 to fold a sub/function 

\- all project files can be placed in an [archive](file_zip.md) (zip) file. 

\- AVR-DOS, GET and PUT support [$bigstrings](bigstrings.md)

\- [$boot](_boot.md) extended to support >64KB processors. $boot can be used together with $inc to include a boot loader in your code. 

\- FM25C256 example with BMA.bas sample added which demons xmega ramtron lib with shared bus. 

\- baudX=value added for Xmega. This will change the baud rate on an xmega at run time. 

\- special multi bus i2c added for normal AVR processors. See [config i2cbus](config_i2cbus.md). 

\- muli dimensional array support added like : dim ar(10,50,3,5,2). 

\- long/dword data types added to SORT statement. 

\- report extended with bit position in memory and length of dimensioned strings 

\- [Lookup](lookup.md) supports a numeric variable too for the label : novar = LOOKUP( value, label|address). 

\- soft spi supports DATA ORDER LSB and MSB 

\- [str](str.md)() second optional parameter added to help. It specifies number of digits after the DP. Only for doubles. 

\- m324/m164/m644/m1280 config timer0, disconnect option fixed. 

\- settings xml file can be passed as parameter to allow different settings files and versions. 

\- added option to show invisible characters. 

\- added support for DWORD to [SWAP](swap.md)

\- added insertionsort.bas sample 

\- m64C1 and M32C1 dat files added. 

\- History Backup option added : it will create a unique copy of the source file each time you save a file. 

\- code explorer can show INC files under their own branch ([options, environment, IDE](options_environment.md))

\- [Qsin](qsin.md) and [Qcos](qcos.md) integer trig added.

---

## What is new in 2080

\- [tiny461](attiny461.md) and [tiny861](attiny861.md) only did set pcie0 when you enable the PCINT because there is just one interrupt in the chip. In 2080, both PCIE0 and PCIE1 are enabled/disabled.

\- added m48PB, m88PB, 168PB and m328PB dat files.

\- new Rainbow functions : [RB_Color](rb_color.md) and [RB_Copy](rb_copy.md) added by Galahat

\- simulator did not show maximum values of DWORD correct.

\- [RB_GETCOLOR](rb_getcolor.md) and [RB_LOOKUPCOLOR](rb_lookupcolor.md) functions did return false result when index was a variable.

\- some font problems solved.

\- simulator could crash for xmega processors.

\- when using non-mono font like Arial, text selection does not work properly. Use a font like CONSOLAS.

\- Added option 'Use Monofont' for backwards compatibility

\- Some new atmel PDF files could not be loaded with the PDF viewer. Viewer is rewritten and requires a new DLL named BASPDF.DLL

\- [getadc](getadc.md)() on m640.m1280/m2560 or any other processor with 6 mux bits did not set mux5 bit for getadc(32) and higher.

\- generic byte [compare](compare.md)() function added, based on code and idea from MWS. (Magic White Smoke)

\- varexist() did not support ALIAS. 

\- XMega64A1-SRAM 4-Port-Sample.bas sample added for setup EBI 4 port on XMega. See also [Adding XRAM to XMEGA using EBI](adding_sram_4_port_non_multipl.md)

\- when bascom-avr.xml options file exists in the bascom application folder, that option file will be used.

\- [format](format.md) is extended to use a variable for the mask.

\- [config xpin](config_xpin.md) did not support alias for the pin.

\- [bufspace](bufspace.md)() did not support UART 5-8

\- [INSERTCHAR](insertchar.md) and [DELCHAR](delchar.md) use Z pointer which must be cleared for XMEGA. fixed in mcs.lib

\- programmer did not fetch correct chip from editor when code was not saved. this would give a chip mismatch.

\- assigning a negative value to a dword did not throw an error.

\- [code explorer](view_code_explorer.md) can show estimated stack usage. 

\- higher standard baud rates added to terminal emulator

\- added support for EDMA in xmega8/16/32 E5. See [config EDMA](config_edma.md)

\- [version](version.md)() function did not append to string but would overwrite existing string data. 

\- [right](right.md)() adds an additional null byte when a numeric constant is used for the number of characters to copy.

\- new [dim](dim.md) option to specify multiple items : dim a,b,c,d as byte failed when using multiple indexed items.

\- all dat files updated with CONFIG information.

\- printing values from multi index variables failed : print index(index1,index2)

\- m1284pdef.dat updated with missing TIFR3 register.

\- more fonts in various sizes from Adam Siwek.

\- [power()](power.md) function for doubles did not work correct when assigned to a function

\- some new atmel PDF files can not be loaded with the PDF viewer. Viewer is rewritten.

\- SSD1306 i2c oled driver updated for Xmega.

\- m649A and m649P dat files added.

\- [LCDFONT](lcdfont.md) prm, added. prm selects the font table (0-3) of a text LCD.

\- [CONFIG POWER_REDUCTION](config_power_reduction.md) set register to 0 in some conditions. Also added LCD and other new Xmega power reduction options.

\- CONFIG OSC extended with calibration register settings and DFLL.

\- val() for doubles has a bug for XMega >64KB chips

\- added [flip](flip2.md)(byte) function to mirror bits in a byte

\- xmega128B3 dat file added

\- [readsig](readsig.md) also works for normal AVR processors.

\- inputbin and printbin load 1 element too many with arrays using base 0.

\- [config inputbin](config_inputbin.md) added to allow reading packets of up to 64 KB

\- added support for LCD text OLED RS0010 lcd4_anypin_oled_RS0010.lib 

\- [FT81x](ft800.md) support added

\- [M324PB](atmega324pb.md) dat file added.

\- [I2CINIT](i2cinit.md) enhanced for multiple TWI

\- [I2C_TWI-MULTI.lib](i2c_twi_multi.md) added to support multiple TWI busses.

\- second SPI on m328PB added : [INIT1SPI](spi1init_spi1in_spi1out_spi1mo.md), SPI1OUT, SPI1MOVE, SPI1IN

\- user donated library [I2C DOGS104](lcd_dogs104a_i2c.md) driver, SSD1803A included.

\- [URL2IP](url2ip.md)(url) function added to W5100 to do DNS lookup using google DNS server

\- when defining a const [Updateeprom](writeeeprom.md) , the eeprom will be updated. which means that the value will only be written when it differs

\- [BASE64ENC](base64enc.md) and [BASE64DEC](base64dec.md) can work on byte arrays too.

2017, 2080 release

\- [SGN](settcpregs.md) extended to byte, integer, word, dword and long

\- [LOADLABEL](loadlabel.md) assigns a 24 bit address when used with a DWORD

\- CTRL+SPACE for code help.

---

## What is new in 2081

\- [CONTINUE](continue.md) statement added

\- [REDO](redo.md) statement added

\- [NOP](nop.md) is now also a BASCOM BASIC statement

\- The editor supports jump to implementation : hold CTRL key and hover the mouse over an identifier. When it becomes underlined and blue you can click it with the left mouse key.

Use CTRL+BACKSPACE to jump back

\- when defining a constant named [Updateeprom](dim.md) , the eeprom will be updated. which means that the value will only be written when it differs. The value of the constant does not matter.

\- config timer1 for tiny 25/45/85 set the wrong register bits.

\- the watchdog is disabled as part of the init procedure. it is now disabled BEFORE the optional call to [init_micro](_initmicro.md) and not after as in 2079.

\- passing string constants with embedded {034} resulted in an extra (unwanted) space.

\- accessing passed string array in sub without length info, but with constant index failed.

\- [crcmb](crcmb.md) funtion added to help. (checksum for modbus)

\- for xmega [i2cstop](i2start_i2cstop__i2crbyte__i2cwbyte.md) you can define a constant named _TWI_STOP_1 or _TWI_STOP_2 to change the behavior.

\- [makemodbus](makemodbus.md)() function 1, 2 and 4 added to modbus.lib

\- support for xmega added to [getrc](getrc.md)

\- PDF download now also checks/download the BASCOM-AVR manual

\- PRINTBIN did not accept a constant for the optional channel : printbin #someconst. Fixed. 

\- [update](help_update.md) from within the application simplified. see help.

\- printbin raised error while printing multiple variables

\- simulator did not show proper hex value for single variables.

\- fusing which uses ftoa uses a table which could be loaded on a page boundary. this could lead to rampz problems. fixed.

\- [crc8UNI](crc8uni.md) added for normal crc8 CCITT

\- [config clock ](config_clock.md)additional option : highESR=1 to enable high ESR mode in xmega with 32 bit RTC

\- [FM24C64_256](fm24c64_256_xmega.md)-XMEGA.lib added for xmega. read the lib notes.

\- tcpip-w5500.lbx has been updated to support usage from boot space. See [$loader](loader.md)

\- stk500 board. osc can be set from menu

\- using [spimove](spimove.md)() inside a sub with a parameter for the count, would load the wrong data.

\- [i2cwbyte](i2start_i2cstop__i2crbyte__i2cwbyte.md) would raise an error if a multi dim array was used.

\- get/put/seek in AVR-DOS used in combination with $bigstrings would fail for numeric data

\- xmega [i2cstop](i2start_i2cstop__i2crbyte__i2cwbyte.md) has two new optional mode. See help.

\- [CONFIG SPI](config_spi.md) has a new option : EXTENDED=1 to have extended data size reading/writing.

\- support for [rgbW](config_rainbow.md) leds added (ws2812 with extra white led)

\- [CONFIG USI](config_usi.md) has a new option to support optional pins.

---

## What is new in 2082

\- rearranging memory order for usb support caused a bug in config clock : the date time bytes are not mapped after each other. Fixed.

\- START/STOP statements worked on the wrong register for the TINY1634

\- i2c_twi_multi lib had a problem in the readbyte function.

\- [SPIMOVE](spimove.md) added for Xmega

\- split screen did not allow copy & paste

\- USI slave support added for tiny1634

\- All DAT files are now stored in a sub folder named DAT. This means you need to copy your DAT file to this folder if you made custom DAT files.

\- some registers of tcc1 were missing in xmega D3 series

\- read only files could not be opened anymore. fixed.

\- On win10 you could get a HID error message. 

\- w5500 tcp lbx : removed RST status bit check since the bit never becomes 0 and hangs the code

\- [url2ip](url2ip.md) bug fix. one byte of the IP address could get trashed

\- url2ip added to w5500

\- new samples for w5500 wiznet chip

\- accessing a zero based array inside a sub coulld result in an index error.

\- simulator did not support writing to xmega portx_CLR _SET and TGL registers

\- using search in files function could result in 'out of bound' error.

\- [manchesterEnc](manchesterenc.md) and [manchesterDec](manchesterdec.md) functions added for manchester coding/decoding

\- assigning a byte with a string constant with spaces, resulted in 0, not 32. 

\- [VARPTR](varptr.md)() function returned &H1000 too much for Xmega ERAM data type.

\- using getadc() with 2 numeric parameters or constants like : getadc(4,&H20) would not set the right bits.

\- i2csend and i2creceive updated for xmega. after the start/slave address, the status is now checked and does not send data in case of a bus problem. this to prevent a hangup in the twi logic.

\- printing supports selection of text and page range now. you need to use print preview for this.

\- OUT instruction did not clear RAMPZ for Xmega with ROM > 64KB and normal SRAM.

\- [PS2MOUSEXY](ps2mousexy.md) accepts an additional optional parameter for mouse wheel support. Notice that you MUST download an update of the ps2 lib add on

\- config spi on non xmega did not support the extended mode for HW SPI

\- [config tcpip](config_tcpip.md) now supports SPI1 for the SPI bus

\- windows 10 DEP and ASLR support added. 

\- printbin: when using automatic rs485 and printing a long/dword constant on a chip with extended port register, R23 was trashed. Example : printbin &HABCDEF00

\- FLIP() function resulted in an error about $REGS

\- terminal emulator component is replaced in order to support windows DEP/ASLR. This means that some features from the terminal emulator have changed.

\- [printbin](printbin.md) can print a variable amount of bytes now. while ; is used to separate multiple variables, the comma can be used to specify the amount of bytes

like : printbin ar(1) , numbytes ; othervar 

this makes the syntax compatible with the old syntax. We recommend to use the new syntax

\- terminal emulator custom messages extended to 16

\- [UPDI programmer](updi_programmer.md) added for new AVR processors with UPDI interface. 

\- A table is added to [$LOADER](loader.md) with the size of maxwordbit. This constant depends on the number of flash pages.

FILE LOCATION

With DOS things were simple : all files could go in a folder and sub folder. To make a backup all you had to do was using XCOPY.

With Windows things are not so simple : files are located all over the PC. Some folders are write protected and to make a backup is not so simple.

A lot of customers are looking for the SAMPLE files. These are put in the documents folder and can be accessed using the File, Open Sample option. 

In 2082 the preferred folder for installation is C:\MCS\BASCAVR2082

But of course you are free to install in any other folder of your choice.

The samples are installed in a sub folder of the application folder too.

In the Environment Options of the IDE you can specify which folder you want to use for the sample files. 

About UPDI

The new UPDI processors have a total different architecture compared to normal AVR. In fact the differences are similar to XMEGA. For this reason we refer to these processors as XTINY since they are tiny Xmega processors.

Because of the work and support for XMEGA fresh in mind, the actual UPDI compiler/DAT support will be available very soon in a next update as an add on. 

The TINY816/817 will be the first processor to be supported.

---

## What is new in 2083

For the Xtiny the following changes were made to 2083.008:

\- xtiny 8 pin chips set the wrong tx pin for config com. as a work around, you can define a portb alias that points to portA

\- printing a constant using the str() function : print str(number_constant) would include a leading space for positive numbers. Variables do not have 

this (VB behavior).

\- xtiny config xpin was missing the INVERTIO option in the DAT files.

\- passing a big string for which the size could not be determined, would not release space which would result in a quick crash. 

to determine the size of passed strings, you best declare with the size indicator like : someString as String * cSize

\- config spi0 for xtiny 202,402,212,412(8 pins) did not set the SS pin in the proper state. 

\- config vref was not described in the help

\- adc.bas sample added for xtiny

\- xtiny dat files updated for config adc and signature row offset adjusted. 

\- xtiny adc1 can also be configured now

\- xtiny renamed ACI to AC : config ac0. Also added ac1 and ac2

\- xtiny config dac1 and dac2 added.

\- xtiny config port_mux added.

\- xtiny SPI sample added

\- showing report in project mode inside the editor as a TAB did not set focus to the report.

\- xtiny dac.bas sample added

\- xtiny portmux.bas sample added

\- optional custom defined menu shortcuts added. See help : Options Environment

\- RESET MICRO added which will soft reset the micro. for xtiny/xmega a hardware soft reset is performed. For normal AVR a jump to the start address is 

performed. 

\- getadc can also read and process the internal temp sensor when you define a const named _adc_kelvin. The value is unimportant. see adc.bas example

\- multiple asm .def with different register but same name will give an error now since .defs are global. 

\- num2str for xtiny/xmega offset added to avoid str() causing problems when passed to a function

Public release

\- new option SAFE for variables. [Dim](dim.md) b as bit SAFE , see help.

\- added BOOTONLY option to [$LOADER](loader.md) directive. $loader bootaddress[,BOOTONLY] this will write just the boot loader code to the BIN file. The HEX remains as is.

\- you can select the [Options_Select_Settings_File](options_select_settings_file.md) now. This setting is stored in the registry.

\- project files are stored with absolute files names inside the prj file. An absolute file name is relative to the location. 

\- simulator bug fixed where SI file simulation data was not processed properly.

\- [MemFill](memfill.md) added. 

\- using instr() with {xxx} for the search string does not work : pos=instr(someAString,"{065}")

\- using compare_a/compare_b=clear for timer0 resulted in SET instead of CLEAR. 

\- bascomp command line utility updated to support new file structure

\- multiple instances bug fixed.

\- mcs.lbx was not in sync with mcs.lib (it was not compiled when a last minute change was made)

\- when using channel specifier without # you will get an error

\- stk500v2 based programmers like mkII and stk500v2 could give a program error when your code contains empty blocks And the processor has multiple 64KB segments. applies to normal mega only. 

\- [crc8](crc8.md) overloaded version added for big strings.

\- 2082 broke the default printing function

\- added DES asm instruction.

\- added [DesEncrypt](desencrypt.md) and [DesDecrypt](desdecrypt.md) which are also supported by the simulator

\- [inputbin](inputbin.md) accepts an optional variable for the number of bytes to receive. delimited by a ;

\- [simulator](program_simulate.md) update.

\- simulator double click cycles, will reset cycles

\- simulator allows to load a custom serial data file from file

\- [Xtiny](xtiny.md) support, requires a commercial add on

\- CTS/RTS bug fixed : only part of the buffer was used

\- added PA version of dat files M88PAdef,M644PAdef,M48PAdef,M168PA. These are almost the same as the P versions. They are binary compatible and have the same ID

\- searching in files would not search in the specified folder when the folder name contained a space. Instead the root folder was used.

\- $programmer option did not support conditional compilation. It was global. Now supports #IF/#ENDIF. but only when 'Use new method' is used in environment IDE options.

\- CLEAR serialinx buffer did not clear the RTS pin when cts/rts was used for xmega uarts 4-7. 

\- xmega high baud calculation > 2MB and higher did not support double rate flag resulting in a wrong baud rate

\- for next using a step for bytes could fail when the byte boundary was crossed.

\- xmega num2str code rewritten and xmega routine rewritten that used _XmegaFix_Rol_R1014 and _XMEGAFIX_CLEAR. These routines are not used anymore!

\- using a string function with select case, could result in improper branching, depending on the user function. 

select case mid(someString,start,len) for example. 

\- bascom-AVR and the SETUP are now code signed.

\- CONFIG XPIN for the E-series : slewrate will be set the whole port, not for an individual pin

\- [crc16uni](crc16uni.md) can handle 65535 bytes

\- low/high can be used as a procedure too for BASCOM-8051 compatibility.

\- UPDI programmer can write fuses

Please notice that this version has significant changes in order to support the Xtiny platform.

While everything was extensively tested, it is still possible you encounter a bug.

When you encounter a problem you did not had with 2082 you best contact support.

---

## What is new in 2084

version 2084.001  
  
\- mega4809 added to xtiny platform. See also [MEGAX](megax.md)

\- xtiny support added to i2cslave add on. 

\- [LCD I2C](lcd_i2c_pcf8574.md) driver from O-Family included that supports up to 8 LCD.

\- xtiny alias portx,ddrx and pinx have been changed from the port_out to the virtual address. this also required the following :

\- 1wire,i2c,getrc,pulsein,pulseout,serout,serin,i2cbus and rainbow changed for new port mapping

\- [config COM](configcomx.md) for xtiny has a new option to chose the alternative pin. TXPIN=option

\- xtiny TCB0: CCMP_OTP renamed into CCMP_OUTPUT. Also reversed enable/disable. And ASYNC enabled/disabled were reversed too.

\- xmega dat files corrected for DACA/DACB. 

\- xmega config eeprom=quick|mapped did not simulate properly

\- xtiny config port_mux did not set the proper register value for TCAx and TCBx

\- portmux support complete rewritten. data is stored in the dat files. see also [config_portmux](config_port_mux.md) for important information.

most choices list the pin number name now.

\- [sizeof](sizeof.md)() function added. it returns the size of a variable in memory. 

\- xtiny config sysclock prescaler value 6 was missing.

\- simulator fix for xtiny (register offset). Also register name length extended to 32 characters

\- htrc110.LBX added * for used equ so they can be adjusted by the user

\- DTR option for terminal emulator. you can set the DTR pin level for the terminal emulator just like you can for the RTS pin.

\- mysmartusb light programmer problem with EEPROM programming solved

\- const [_TEXTLCDKIND](config_lcd.md) added which contains the text LCD kind like : 162 for 16x2

\- the tool tip info (SHIFT key) shows the length of a string constant when moving over a string constant.

\- xtiny support added for AVR-DOS

\- serin/serout implemented for xmega and xtiny

\- [SWAP](swap.md) can swap a long/dword too

\- glcdST7565R.lib adjusted for RAMPX boundary in showpic

\- xtiny enable/disable set wrong bits for the timers

\- xtiny start/stop switch the enable bit for timers

\- datetime.lib modified for xtiny

\- split() did not raise an error when using non-strings. The result array must be a string array.

\- syntax check/compile did reset the stk200 programmer reset pin

\- xtiny tcb1 added which was missing.

\- UPDI programmer speed increased. baud is selectable. 225000 is the maximum for the default updi clock.

\- IDE did not compile for the right processor when multiple $regfile directives were used with #IF#ENDIF.

\- Font size increased in IDE. Default is now SEGUI 12. When you use a different language in options, this might not be visible. 

Also changed IDE so that high resolution monitor should show better font when bigger fonts are chosen. The icons/images still need to be changed to vector drawn images so they can scale better. 

\- more xtiny samples

\- IDE can [update](updates.md) a number of add ons

---

## What is new in 2085

version 2085.003(beta 3)

\- getadc() checks data type for xmega/xtiny. data type should be integer/word

\- $SIM -> _SIM was not properly colored when using 'show excluded code' option

\- simulator gave overflow error when kept running for a long time. 

\- simulator dual port registers support added. this means that using virtual ports will update correctly the normal registers

\- [join](join.md)() function added as counter part of [Split](split.md)() function

\- [lookdown](lookdown.md)() support added for dword/long

version 2085.002(beta2)

\- movw code replaced by mov when the processor does not have the movw instruction. only applies to old processors

\- xtiny platform config SPIx has an additional option SPIPIN to specify which port pins must be used for the SPI bus

\- since some xtiny(megaX,AVRX) have multiple SPI, config SPI1 is added to configure the second SPI bus. This works for SPI1IN, SPI1OUT, SPI1MOVE.

\- mid function and mid statement rewritten. the start position is not simply added but checked so it can not be placed beyond the end of the string

use the byte variant to terminate the string like : mid(somestring,index)=0.

\- Both [MID](mid.md) statement and function support $bigstrings

\- instr() function updated to be more safe. since you can specify an offset, this offset is checked so it will not read beyond the string.

\- [space](space.md)() and [string](string.md)() functions moved to mcs.lib and also added support for $bigstrings

\- [delchar](delchar.md)/[insertchar](insertchar.md) support [$bigstrings](bigstrings.md)

\- [bascomp](bascomp.md) utility updated

version 2085.001 (beta1)

This is an updated to support the DB series.

\- make sure to read about PRESERVE and OVERWRITE in the [CONFIG](config.md) options.

\- lcd_i2c_PCF8574.LIB updated version included. 

\- mega16M1,32M1 and 64M1 corrected for LIN/USART

\- rainbow libs rolled back. the automatic platform code had the disadvantage of requiring a call instead of rcall

\- font editor fixed. The width of the font was not properly saved when it wasn't a multiple of 8.

\- various fonts changed in IDE. There is also a new option to override the windows system settings. 

\- m48pb dat file modified. DDRE entry was invalid

\- a number of icons are changed. Also new bigger icons included which can be selected in the options. This is intended for high resolution DPI. The icons are still in the ICO format however which mean that they do not scale perfect as SVG would do. This is in the works as well.

\- DB/[AVRX](avrx.md) support. The xtiny add on is required. You need to update the add on lib.

---

## What is new in 2086

\- config sections are also grouped for code collapse

\- toggle code improved for word,int,long. Also bug fixed when toggle as used on a port with constant like porta.pd3

\- spi1move and spimove for xtiny using manual SS setting would set DDR instead of PORT register

\- SW UART Inkey, Input, Waitkey revised for $timeout. $timeout maximum value is &HFF_FF_FF. Input will end when one of the incoming characters times out. 

\- attiny861 , START TIMER did actual stop the timer since the wrong value was written. 

\- buffered serial port changed. since a global variable is used for the buffer count, the interrupts are disabled and reenabled during updating this variable. but users that use the BYTEMATCH option in combination with serial input code

like input, inputbin, etc. autmatic enable the interrupts since reading disable/enables global interrupts. this can lead to problems. it is not good practice to read data from the interrupt but since many users seems to use this

we changed the CLI/SEI so that the I-flag is restored and thus global ints are not enabled by reading inside the ISR. 

\- using rnd() with config rnd=32 on a word/integer result in an internal variable error

### CODE BREAKING CHANGE ###

\- [config comx](configcomx.md) TXPIN becomes TX_RX_XC_XD_PIN. This better reflects that all pins belonging to the USART will have an alternative pin value

This only breaks old code when the TXPIN option was used. 

#########################

\- config comx for xtiny platform has a new option : TX=DISABLED|ENABLED and RX=ENABLED|DISABLED by default both TX and RX are enabled. but you can disable the Transmitter or Receiver

\- M324PBdef.dat updated to support second TWI channel. See also the M324PB sample.

\- included fonts for graphical LCD are now word aligned. this in case the user uses multiple END statements.

\- drivers(libs) updated that were unsafe when using port pins on an extended address. 

\- I2C_TWI-MULTI.lib : i2cstop missed setup call to _i2c_chan_setup when CONST _TWI_STOP_TIMEOUT was not defined resulting in a hang up

\- AVR-DOS updated for xtiny and added sample files : FlashCard-demo-XTINY.bas , Config_MMCSD_HC_XTINY.inc , CONFIG_AVR-DOS.inc. See also the AVR-DOS topic description for a sample.

\- bootloader added for megax : BootLoader-MegaX.bas the file m4808-tca0-BOOT.bas can be used to load the demo which uses [$romstart](_romstart.md). See also [Using a BOOTLOADER](using_a_bootloader.md)

\- dim SAFE changed see help

\- val() to a double for a string with leading + would result in NAN.

\- decr/incr did not protect variables dimmed with SAFE 

\- editor multi search highlight and multi selection highlight added. See [Options Environment](options_environment.md)

\- com5 and com5 buffered output for xtiny bug fixed where there was a double label used.

\- RTF export now capitalizes IO registers, just as they appear on screen.

\- simulator now uses a separate register space. old AVR, xmega and xtiny have different memory maps. while older AVR can reach the registers by a pointer, the xmega and xtiny can not do so.

while desgning the simulator there was one memory area. but it turned out that some instructions writing to registers, actually wrote to lower IO space. So this has been rewritten.

This means that a lot of the simulation code has been changed. Please report any simulation bug to support.

\- config dmxslave support added for xtiny platform

\- xtiny buffered serial input for com5 and com6 gave a duplicate label error

\- some programmers like stk200,stk300, kamprog had no icon any longer in the toolbar. and the chosen size was not working either.

\- clearing history in search box did not work properly(right mouse button)

\- config tcpip for w5500 supports xtiny

\- CLS in $ASM block mistaken as BASIC CLS

\- shiftout number_of_bits would not accept a local/param

\- buffered serial output com5 for xmega caused an error

\- [dcf77](configdcf77.md) xtiny support added for timer TCA0

\- user EDC had a great idea about notification of usb-serial ports. you are notified with an alert window when a CDC is added or removed

\- $programmer extended with constants for programmers and additional COM parameter. prog.inc contains the constants for the programmers

\- [writedac](writedac.md) statement added for xtiny platform

\- simulator usart emulation added for xtiny platform

\- baud statement implemented for Xtiny

\- [getrc5](getrc5.md) xtiny support, also background mode added for TCBx. check config-rc5 in the help and the avrx128da28-RC5-Background-send-receive.bas example

\- [rc5send](rc5send.md) xtiny support, check config rc5send

\- config tca0 splitmode fixed. see also the example. this also requires an update of all DAT files.

\- $romstart number of bugs in simulator fixed (elpm, lpm)

\- Baud statement improved. it did not support channels for a HW UART. it will also raise an error when you try to use non existing channels.

\- [FM24C64_256-XMEGA](fm24c64_256_xmega.md).lib support for strings added.

\- UPDI addon support for more processors : mega808,1608 and 3208. also added 64DB32,128DB32,128DA48,128DA32,32DA48,64DA64,128DA28

\- [updi programmer](updi_programmer.md) enhanced, it works up to 1.6 Mbaud now. not all processors support this. See help. Also added unlock chip function.

also added lockbit table to DA/DB series. these platforms use a 4 byte ID to lock.

updi can use DTR/RTS for switching data and/or a 12V pulse. 12V pulse is used to access UPDI when the updi/reset are shared and the pin is programmed for reset function. 

\- tcpip w5500 corrected a bug for xmega with > 64KB processors. mixing tcpwrite and tcpwritestr could result in sram accessing a wrong page.

\- some checks added for string assignment/passing byval. when constants are used that are too big you get an error. you also get an error when you claim more temp memory than specified with $framesize. 

see also the help for error 406. The option need to be turned on using CONFIG STRCHECK=ON

\- string to double conversion with string in scientific notation conversion bug fixed when there was a leading minus. also added support for the bigger xtinies.

\- some scaling problems fixed. 

\- DB/DA series use a different method for the UPDI fuse/eeprom/signature writing. This is corrected.

\- xtiny with 128 SRAM did not simulate correct. Also the MSB of pointers were not set since normal AVR do not need this for 128 SRAM chips. 

since xtiny has a different memory model this lead to memory bugs

\- optimization did not recognize flag registers. code like : portf_flags = portf_flags would not be executed. 

\- kamprog icons were not visible due to a change in icons

\- writing a constant to an eeprom string on a normal AVR would fail

\- closing bascom with programmer window open produced an access error

\- lib manager can add a routine from the clipboard

\- int_trig.lib 64K boundary bug fixed (qsin/qcos)

\- xtiny/megaX dat files had ADC value exchanged for 8bit/10bit resolution selection

\- mcusr register was not properly cleared at start up for old AVR processors. only the WD flag was reset, notice you should not write a 0, since some AVR have other unrelated bit flags in the MCUSR register!

processors like that will have an additional mask in the dat file : WD=MCUCSR.WDRF,$E0

\- assigning a hex number to a double did not work for all numbers

\- waitkey() for the software uart did not support timeout.

\- [View Show Alert Window](viewalertwindow.md)

---

## What is new in 2087

Modifications in 2087

\- options, programmer shows an image (when available) of the selected programmer

\- config [varptrMode](config_varptrmode.md) added to change behavior of Varptr()

\- [TYPE](type.md) support added.

\- xtiny low IO registers would not paint red/blue in the simulator.

\- print fusing() with a single array would fail because of a bug that trashed a register.

\- new [$USER](user.md) directive added for creating .usr files for the Xtiny platform. This is a user signature data. Using $USER and DATA you can create the .usr file

\- config TCDx changed so CTRLA is written last and the the status.0 bit is checked. without this the timer would not initialize properly

\- readsig() for xtiny uses a named constant since the address might be different for other xtiny platforms.

\- [$PROGRAMMER](programmer.md) supports serial number for MCS EDBG programmer

\- [1wread](1wread.md)(bts , PinE , 3) failed when bts was a variable.

\- [Config printX](configprint.md) has an additional parameter : DELAY=time. This is an optional parameter that can be used to delay for the specified time before the data direction pin is switched 

\- Options, Environment, IDE, new parser has an updated description.

\- When using new parser and wrong syntax for $regfile, the setting from the config file was used. Now you will get an error so it is clear you use the wrong DAT file.

\- When storing project .prj file in a folder other than the source, source code errors reported by the compiler were not jumped to when double clicked in the Error window.

\- Alert window position is saved.

\- STOP WATCHDOG bug fixed for Xtiny platform.

\- Simulator IO grid improved for speed. Other grids in simulator are improved as well since they use the same improved code.

\- Simulator SRAM grid improved for speed and displaying options. See help.

\- I2CINIT bug fixed for xtiny 8 pin devices which have a different port for I2C

\- When updating from an old version and keeping settings files, the options, Compiler , LCD could have a value of nothing(not selected). This could cause the compilation to end without creating bin/hex files.

\- Alternative rename added using References, right click menu : [RENAME](view_code_explorer.md). This will rename the selected item in the whole project, including the files on disk that are not loaded.

\- [Microchip CMIS-DAP programmers](mcs_snap_programmer.md) support added. The programmer is named MCS EDBG programmer.

\- [Config DMXSLAVE](config_dmxslave.md) bug fixed for COM4. Also COM5 and COM6 added.

\- [Search and Replace](edit_replace.md) in files added. this is similar to Search and Find in Files but you can replace text.

\- Find, search and replace button added to clear the history. this replaces the right click menu. 

\- [readSig](readsig.md)() support for Xtiny platform added.

\- [MCS UPDI programmer](updi_programmer.md) info added for USB virtual COM drivers/chips. 

\- [_XTINY](xtiny.md) constant in the DAT files set to 4 for the EA series since they differ significantly.

\- Xtiny EEPROM writing updated and modified since all series handle this different in the NVM.

_EPROM_PAGESIZE is now an internal constant since it is used in the xtiny.lib. This does also fix a potential EEPROM write problem for some UPDI processors. This constant is auto generated by the compiler.

\- Pulseout did not work on normal AVR extended ports. An extended port has a memory address > &H60

\- Using INPUT on XMEGA with a software UART would result in stack loss caused by code intended for the HW UART.

\- Using .\ for include files could load the file twice in the IDE when clicking the Error window and the code explorer. While this is fixed now, to include files that reside in the same folder as the main application, do not prefix the file.

\- [$programmer](programmer.md) additional COMPORT option did not work for MCS Bootloader. Also notice that New Parser must be selected in Options, Environment, IDE for this option.

\- GETRC fix for xmega and Xtiny. While XMega would work with passing DDR register, the Xtiny passed the wrong register. Now all platforms can pass PINx register.

\- CONFIG XPIN accepts both OUTPULL and PULLUP as a parameter to activate pullup. While normal AVR only supports pullup for input mode and the Xtiny till today also support pullup for input mode only, the Xmega supports various  
modes in output mode as well. Since XMEGA was the first chip with pullup and atmel named it outpull we used this term too. But as it will be confusing for Xtiny/normal AVR, PULLUP is added.

\- MCS UPDI programmer supports P3 protocol too as found in the EA series.

\- Simulation of xmega eeprom did not work. 

\- READ statement did not support multi dim arrays. The optional number of bytes parameter was not described in the help.

\- Room for labels and other data increased in order to fix error 337.

\- MCS UPDI programmer write counter added. It keeps track how many times a processor is programmed based on its serial number.

\- SAFE option for DIM had a bug for one usage case. Also optimized the code for multiple safe access.

\- The simulator memory handling had a bug for LD reg,X so depending on used platform this could result in wrong simulation.

\- HW register color could not be changed anymore. 

\- Bigbuffers added for COM1/USART0. It uses bigbuf.lib which need to be included using $LIB. Set this option using CONFIG COM1 BIGSIZE instead of SIZE.

\- Config-kbd extended in DAT file with possible options

\- [CANSEND](cansend.md) statement added. this statement does not wait/blocks the code. see help.

\- Watchdog documentation improved for xtiny. also added example watchdog-avrx128da28.bas

\- Splash window adjusted to show new xtiny processors

\- Some DAT files had the wrong flash_size value which results in programming problems

\- Find window lost right click copy,past,cut options when 'clear history' was added. 

\- Config comx new options RX and TX enabled/disabled were reversed. (tx would disable rx and vice versa)

---

## WHILE-WEND

Action

Executes a series of statements in a loop, as long as a given condition is true.

Syntax

WHILE condition

statements

WEND

Remarks

If the condition is true then any intervening statements are executed until the WEND statement is encountered.

BASCOM then returns to the WHILE statement and checks the condition.

```vb
If it is still true, the process is repeated.

If it is not true, execution resumes with the statement following the WEND statement.

```
So in contrast with the DO-LOOP structure, a WHILE-WEND condition is tested first so that if the condition fails, the statements in the WHILE-WEND structure are never executed.

See also

[DO-LOOP](do_loop.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : while_w.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : demo: WHILE, WEND

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

Dim A As Byte

```
A = 1 'assign var

```vb
While A < 10 'test expression

Print A 'print var

```
Incr A 'increase by one

```vb
Wend 'continue loop

End

```

---

## Windows Maximize All

Maximize all open editor windows.

---

## WR16

Action

This statement will write an address and a word parameter to the FT800.

Syntax

WR16 address , prm

Remarks

The address need to be an address in the FT800 address range. See FT800 manual for more info.

The parameter (prm) is a word numeric value. It depends on the address which parameter value you may send.

When you want to write to the FIFO buffer you can best use CMD16.

See also

[CMD8](cmd8.md) , [CMD16](cmd16.md), [CMD32](cmd32.md) , [WR8](wr8.md), [WR32](wr32.md)

Example

Wr8 Reg_GPIO_Dir , &H83  
Wr8 Reg_GPIO , &H83  
  
Wr16 Reg_Touch_rzThresh , 1200

  
Wr32 Ram_DL + 0, &H02FFFFFF

---

## WR32

Action

This statement will write an address and a dword parameter to the FT800.

Syntax

WR32 address , prm

Remarks

The address need to be an address in the FT800 address range. See FT800 manual for more info.

The parameter (prm) is a dword numeric value. It depends on the address which parameter value you may send.

When you want to write to the FIFO buffer you can best use CMD32.

See also

[CMD8](cmd8.md) , [CMD16](cmd16.md), [CMD32](cmd32.md) , [WR8](wr8.md), [WR16](wr16.md)

Example

Wr8 Reg_GPIO_Dir , &H83  
Wr8 Reg_GPIO , &H83  
  
Wr16 Reg_Touch_rzThresh , 1200

  
Wr32 Ram_DL + 0, &H02FFFFFF

---

## WR8

Action

This statement will write an address and a byte parameter to the FT800.

Syntax

WR8 address , prm

Remarks

The address need to be an address in the FT800 address range. See FT800 manual for more info.

The parameter (prm) is a word numeric value. It depends on the address which parameter value you may send.

When you want to write to the FIFO buffer you can best use CMD8.

See also

[CMD8](cmd8.md) , [CMD16](cmd16.md), [CMD32](cmd32.md) , [WR16](wr16.md), [WR32](wr32.md)

Example

Wr8 Reg_GPIO_Dir , &H83  
Wr8 Reg_GPIO , &H83  
  
Wr16 Reg_Touch_rzThresh , 1200

  
Wr32 Ram_DL + 0, &H02FFFFFF

---

## WRITE

Action

Writes data to a sequential file

Syntax

WRITE #ch , data [,data1]

Remarks

Ch | A channel number, which identifies an opened file. This can be a hard coded constant or a variable.  
---|---  
Data , data1 | A variable whoâs content are written to the file.  
  
When you write a variables value, you do not write the binary representation but the ASCII representation. When you look in a file it contains readable text.

When you use PUT, to write binary info, the files are not readable or contain unreadable characters.

Strings written are surrounded by string delimiters "". Multiple variables written are separated by a comma. Consider this example :

Dim S as String * 10 , W as Word

S="hello" : W = 100

OPEN "test.txt" For OUTPUT as #1

WRITE #1, S , W

CLOSE #1

The file content will look like this : "hello",100

Use INPUT to read the values from value.

See also

[INITFILESYSTEM](initfilesystem.md) , [OPEN](open.md) , [CLOSE](close.md), [FLUSH](flush.md) , [PRINT](print.md), [LINE INPUT](line_input.md), [LOC](loc.md), [LOF](lof.md) , [EOF](eof.md) , [FREEFILE](freefile.md) , [FILEATTR](fileattr.md) , [SEEK](seek.md) , [BSAVE](bsave.md) , [BLOAD](bload.md) , [KILL](kill.md) , [DISKFREE](diskfree.md) , [GET](get.md) , [PUT](put.md) , [FILEDATE](filedate.md) , [FILETIME](filetime.md) , [FILEDATETIME](filedatetime.md) , [DIR](dir.md) , [WRITE](write.md) , [INPUT](input.md)

ASM

Calls | _FileWriteQuotationMark | _FileWriteDecInt  
---|---|---  
| _FileWriteDecByte | _FileWriteDecWord  
| _FileWriteDecLong | _FileWriteDecSingle  
Input | Z points to variable |   
Output |  |   
  
Partial Example

Dim S As String * 10 , W As Word , L As Long

S = "write"

Open "write.dmo"for Output As #2

Write #2 , S , W , L ' write is also supported

Close #2

Open "write.dmo"for Input As #2

Input #2 , S , W , L ' write is also supported

Close #2

Print S ; " " ; W ; " " ; L

---

## WRITEDAC

Action

Sets or resets a single pixel.

Syntax

PSET X , Y, value

Remarks

X | The X location of the pixel. In range from 0-239.  
---|---  
Y | The Y location of the pixel. In range from 0-63.  
value | The value for the pixel. 0 will clear the pixel. 1 Will set the pixel.  
  
The PSET is handy to create a simple data logger or oscilloscope.

See also

[SHOWPIC](showpic.md) , [CONFIG GRAPHLCD](config_graphlcd.md) , [LINE](line.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : t6963_240_128.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : T6963C graphic display support demo 240 * 128

'micro : Mega8535

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m8535.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'-----------------------------------------------------------------

' (c) 1995-2025 MCS Electronics

' T6963C graphic display support demo 240 * 128

'-----------------------------------------------------------------

'The connections of the LCD used in this demo

'LCD pin connected to

'1 GND GND

'2 GND GND

'3 +5V +5V

'4 -9V -9V potmeter

'5 /WR PORTC.0

'6 /RD PORTC.1

'7 /CE PORTC.2

'8 C/D PORTC.3

'9 NC not conneted

'10 RESET PORTC.4

'11-18 D0-D7 PA

'19 FS PORTC.5

'20 NC not connected

'First we define that we use a graphic LCD

' Only 240*64 supported yet

Config Graphlcd = 240 * 128 , Dataport = Porta , Controlport = Portc , Ce = 2 , Cd = 3 , Wr = 0 , Rd = 1 , Reset = 4 , Fs = 5 , Mode = 8

'The dataport is the portname that is connected to the data lines of the LCD

'The controlport is the portname which pins are used to control the lcd

'CE, CD etc. are the pin number of the CONTROLPORT.

' For example CE =2 because it is connected to PORTC.2

'mode 8 gives 240 / 8 = 30 columns , mode=6 gives 240 / 6 = 40 columns

'Dim variables (y not used)

Dim X As Byte , Y As Byte

'Clear the screen will both clear text and graph display

```
Cls

```vb
'Other options are :

' CLS TEXT to clear only the text display

' CLS GRAPH to clear only the graphical part

```
Cursor Off

```vb
Wait 1

'locate works like the normal LCD locate statement

' LOCATE LINE,COLUMN LINE can be 1-8 and column 0-30

```
Locate 1 , 1Action

Sets or resets a single pixel.

Syntax

PSET X , Y, value

Remarks

X | The X location of the pixel. In range from 0-239.  
---|---  
Y | The Y location of the pixel. In range from 0-63.  
value | The value for the pixel. 0 will clear the pixel. 1 Will set the pixel.  
  
The PSET is handy to create a simple data logger or oscilloscope.

See also

[SHOWPIC](showpic.md) , [CONFIG GRAPHLCD](config_graphlcd.md) , [LINE](line.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : t6963_240_128.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : T6963C graphic display support demo 240 * 128

'micro : Mega8535

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m8535.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'-----------------------------------------------------------------

' (c) 1995-2025 MCS Electronics

' T6963C graphic display support demo 240 * 128

'-----------------------------------------------------------------

'The connections of the LCD used in this demo

'LCD pin connected to

'1 GND GND

'2 GND GND

'3 +5V +5V

'4 -9V -9V potmeter

'5 /WR PORTC.0

'6 /RD PORTC.1

'7 /CE PORTC.2

'8 C/D PORTC.3

'9 NC not conneted

'10 RESET PORTC.4

'11-18 D0-D7 PA

'19 FS PORTC.5

'20 NC not connected

'First we define that we use a graphic LCD

' Only 240*64 supported yet

Config Graphlcd = 240 * 128 , Dataport = Porta , Controlport = Portc , Ce = 2 , Cd = 3 , Wr = 0 , Rd = 1 , Reset = 4 , Fs = 5 , Mode = 8

'The dataport is the portname that is connected to the data lines of the LCD

'The controlport is the portname which pins are used to control the lcd

'CE, CD etc. are the pin number of the CONTROLPORT.

' For example CE =2 because it is connected to PORTC.2

'mode 8 gives 240 / 8 = 30 columns , mode=6 gives 240 / 6 = 40 columns

'Dim variables (y not used)

Dim X As Byte , Y As Byte

'Clear the screen will both clear text and graph display

```
Cls

```vb
'Other options are :

' CLS TEXT to clear only the text display

' CLS GRAPH to clear only the graphical part

```
Cursor Off

```vb
Wait 1

'locate works like the normal LCD locate statement

' LOCATE LINE,COLUMN LINE can be 1-8 and column 0-30

```
Locate 1 , 1

'Show some text

Lcd "MCS Electronics"

'And some othe text on line 2

Locate 2 , 1 : Lcd "T6963c support"

Locate 3 , 1 : Lcd "1234567890123456789012345678901234567890"

Locate 16 , 1 : Lcd "write this to the lower line"

Wait 2

Cls Text

```vb
'use the new LINE statement to create a box

'LINE(X0,Y0) - (X1,Y1), on/off

```
Line(0 , 0) -(239 , 127) , 255 ' diagonal line

Line(0 , 127) -(239 , 0) , 255 ' diagonal line

Line(0 , 0) -(240 , 0) , 255 ' horizontal upper line

Line(0 , 127) -(239 , 127) , 255 'horizontal lower line

Line(0 , 0) -(0 , 127) , 255 ' vertical left line

Line(239 , 0) -(239 , 127) , 255 ' vertical right line

```vb
Wait 2

' draw a line using PSET X,Y, ON/OFF

' PSET on.off param is 0 to clear a pixel and any other value to turn it on

For X = 0 To 140

```
Pset X , 20 , 255 ' set the pixel

```vb
Next

For X = 0 To 140

```
Pset X , 127 , 255 ' set the pixel

```vb
Next

Wait 2

'circle time

'circle(X,Y), radius, color

'X,y is the middle of the circle,color must be 255 to show a pixel and 0 to clear a pixel

For X = 1 To 10

```
Circle(20 , 20) , X , 255 ' show circle

Wait 1

Circle(20 , 20) , X , 0 'remove circle

```vb
Wait 1

Next

Wait 2

For X = 1 To 10

```
Circle(20 , 20) , X , 255 ' show circle

```vb
Waitms 200

Next

Wait 2

'Now it is time to show a picture

'SHOWPIC X,Y,label

'The label points to a label that holds the image data

```
Test:

Showpic 0 , 0 , Plaatje

Showpic 0 , 64 , Plaatje ' show 2 since we have a big display

Wait 2

Cls Text ' clear the text

```vb
End

'This label holds the mage data

```
Plaatje:

```vb
'$BGF will put the bitmap into the program at this location

$bgf "mcs.bgf"

'You could insert other picture data here

```
Action

This statement will set the DAC output value on the XTINY platform.

Syntax

WRITEDAC value

Remarks

A DAC is a digital to analog converter.

Value is a constant or numeric variable. Xtinies have an 8 bit DAC. DA/DB series have a 10 bit DAC. The 10 bit model need a specific alignment of the bits. That is the reason this statement exists since on Xtiny it will write to the DAC0_DATA register which is 1 byte.

On the AVR128DB28 the DAC0_DATA register is a word register. The two LS bits of the value are located in bit 6 and 7 of the LSB. This means that the value you write must be shifted 6 places to the left and that is what WRITEDAC will do for the platforms that use a 10 bit DAC.

In order to use the DAC you must use the CONFIG DACx statement that will enable the DAC and will set the output pin to output mode.

And you need to set the voltage reference for the DAC using [CONFIG VREF](config_vref.md).

See also

[CONFIG DACx](config_dacx2.md) , [CONFIG VREF](config_vref.md)

Example

See the CONFIG DACx example.

---

## WRITEEEPROM

Action

Write a variables content to the DATA EEPROM.

Syntax

WRITEEEPROM var , address

Remarks

var | The name of the variable that must be stored  
---|---  
address | The address in the EEPROM where the variable must be stored. A new option is that you can provide a label name for the address. See example 2.  
  
This statement is provided for compatibility with BASCOM-8051.

You can better use :

```vb
Dim V as Eram Byte 'store in EEPROM

Dim B As Byte 'normal variable

```
B = 10

V = B 'store variable in EEPROM which is the actual writeeeprom

When you use the assignment version, the data types must be the same!

According to a data sheet from ATMEL, the first location in the EEPROM with address 0, can be overwritten during a reset. It is advised not to use this location.

For security, register R23 is set to a magic value before the data is written to the EEPROM.

All interrupts are disabled while the EEPROM data is written. Interrupts are enabled automatic after the data is written.

It is advised to use the Brownout circuit that is available on most AVR processors. This will prevent that data is written to the EEPROM when the voltage drops under the specified level.

When data is written to the EEPROM, all interrupts are disabled, and after the EEPROM has been written, the interrupts are re-enabled.

In the XMEGA, you need to set the mode to mapped : [CONFIG EEPROM](config_eeprom.md) = MAPPED.

![notice](notice.jpg)When you define a constant named UPDATEEPROM the eprom cells will be only written when the value differs. Instead of just writing the value, the EPROM content is first read and compared to the new value. Only when the new value differs the new value is written to the EEPROM. A memory location can be written to 100.000 times at least. 

The constant UPDATEEPROM can have any value. There is only a check if this constant is defined. So even : CONST UPDATEEPROM=0 will use the special update code.

See also

[READEEPROM](readeeprom.md)

ASM

NONE

Example

```vb
'-----------------------------------------------------------------------------------------

'name : eeprom2.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : shows how to use labels with READEEPROM

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 4000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'first dimension a variable

Dim B As Byte

Dim Yes As String * 1

'Usage for readeeprom and writeeprom :

'readeeprom var, address

'A new option is to use a label for the address of the data

'Since this data is in an external file and not in the code the eeprom data

'should be specified first. This in contrast with the normal DATA lines which must

'be placed at the end of your program!!

'first tell the compiler that we are using EEPROM to store the DATA

$eeprom

'the generated EEP file is a binary file.

'Use $EEPROMHEX to create an Intel Hex file usable with AVR Studio.

'$eepromhex

'specify a label

```
Label1:

Data 1 , 2 , 3 , 4 , 5

Label2:

Data 10 , 20 , 30 , 40 , 50

```vb
'Switch back to normal data lines in case they are used

$data

'All the code above does not generate real object code

'It only creates a file with the EEP extension

'Use the new label option

```
Readeeprom B , Label1

```vb
Print B 'prints 1

'Succesive reads will read the next value

'But the first time the label must be specified so the start is known

```
Readeeprom B

Print B 'prints 2

Readeeprom B , Label2

Print B 'prints 10

Readeeprom B

```vb
Print B 'prints 20

'And it works for writing too :

'but since the programming can interfere we add a stop here

Input "Ready?" , Yes

```
B = 100

Writeeeprom B , Label1

B = 101

Writeeeprom B

'read it back

Readeeprom B , Label1

```vb
Print B 'prints 100

'Succesive reads will read the next value

'But the first time the label must be specified so the start is known

```
Readeeprom B

```vb
Print B 'prints 101

End

```

---

## X10DETECT

Action

Returns a byte that indicates if a X10 Power line interface is found.

Syntax

Result = X10DETECT( )

Remarks

Result | A variable that will be assigned with 0 if there is no Power Line Interface found. 1 will be returned if the interface is found, and the detected mains frequency is 50 Hz. 2 will be returned if the interface is found and the detected mains frequency is 60 Hz.  
---|---  
  
When no TW-523 or other suitable interface is found, the other X10 routines will not work.

See also

[CONFIG X10](config_x10.md) , [X10SEND](x10send.md)

Example

```vb
'-----------------------------------------------------------------------------------------

'name : x10.bas

'copyright : (c) 1995-2025, MCS Electronics

'purpose : example needs a TW-523 X10 interface

'micro : Mega48

'suited for demo : yes

'commercial addon needed : no

'-----------------------------------------------------------------------------------------

$regfile = "m48def.dat" ' specify the used micro

$crystal = 8000000 ' used crystal frequency

$baud = 19200 ' use baud rate

$hwstack = 32 ' default use 32 for the hardware stack

$swstack = 10 ' default use 10 for the SW stack

$framesize = 40 ' default use 40 for the frame space

'define the house code

```
Const House = "M" ' use code A-P

```vb
Waitms 500 ' optional delay not really needed

'dim the used variables

Dim X As Byte

'configure the zero cross pin and TX pin

Config X10 = Pind.4 , Tx = Portb.0

' ^--zero cross

' ^--- transmission pin

'detect the TW-523

```
X = X10detect()

```vb
Print X ' 0 means error, 1 means 50 Hz, 2 means 60 Hz

Do

Input "Send (1-32) " , X

'enter a key code from 1-31

'1-16 to address a unit

'17 all units off

'18 all lights on

'19 ON

'20 OFF

'21 DIM

'22 BRIGHT

'23 All lights off

'24 extended code

'25 hail request

'26 hail acknowledge

'27 preset dim

'28 preset dim

'29 extended data analog

'30 status on

'31 status off

'32 status request

```
X10send House , X ' send the code

```vb
Loop

Dim Ar(4) As Byte

```
X10send House , X , Ar(1) , 4 ' send 4 additional bytes

End

---

## X10SEND

Action

Sends a house and key code with the X10 protocol.

Syntax

X10SEND house , code

Remarks

House | The house code in the form of a letter A-P. You can use a constant, or you can use a variable  
---|---  
Code | The code or function to send. This is a number between 1-32.  
  
The X10SEND command needs a TW-523 interface.

Only ground, TX and Zero Cross, needs to be connected for transmission.

Use CONFIG X10 to specify the pins.

X10 is a popular protocol used to control equipment via the mains. A 110 KHz signal is added to the normal 50/60 Hz , 220/110 V power.

Notice that experimenting with 110V-240V can be very dangerous when you do not know exactly what you are doing !!!

In the US, X10 is very popular and wide spread. In Europe it is hard to get a TW-523 for 220/230/240 V.

I modified an 110V version so it worked for 220V. On the Internet you can find modification information. But as noticed before, MODIFY ONLY WHEN YOU UNDERSTAND WHAT YOU ARE DOING.

A bad modified device could result in a fire, and your insurance will most likely not pay. A modified device will not pass any CE, or other test.

When the TW-523 is connected to the mains and you use the X10SEND command, you will notice that the LED on the TW-523 will blink.

The following table lists all X10 codes.

Code value | Description  
---|---  
1-16 | Used to address a unit. X10 can use a maximum of 16 units per house code.  
17 | All units off  
18 | All lights on  
19 | ON  
20 | OFF  
21 | DIM  
22 | BRIGHT  
23 | All lights off  
24 | Extended ode  
25 | Hail request  
26 | Hail acknowledge  
27 | Preset dim  
28 | Preset dim  
29 | Extended data analog  
30 | Status on  
31 | Status off  
32 | Status request  
  
At www.x10.com you can find all X10 information. The intension of BASCOM is not to learn you everything about X10, but to show you how you can use it with BASCOM.

See also

[CONFIG X10](config_x10.md) , [X10DETECT](x10detect.md) , [X10SEND](x10send.md)

Example

See [X10DETECT](x10detect.md)

---

## XOR

Action

This logical operator returns the XOR of two numeric variables.

Syntax

target = source1 XOR source2

Remarks

The XOR operator works on two bits. It returns a '1' if both inputs are different. 

A | B | R  
---|---|---  
0 | 0 | 0  
0 | 1 | 1  
1 | 0 | 1  
1 | 1 | 0  
  
The truth table above shows all possible values. A and B represent the 2 inputs. R is the Return or output value. As you can see, you will get a '1' when both inputs differ.

While you can use XOR on bits, you can also perform the same operation on bytes, integers, etc. In such a case, all bits of the variables will be XOR-ed.

Example :

Dim A as Byte, B as Byte, R as byte

A=&B1100_0001

B=&B1001_0000

R=A XOR B

R=&B0101_0001

See also

[AND](and.md) , [OR](or.md), [NOT](not.md)

Example

```vb
'--------------------------------------------------------------------------------  
'name : boolean.bas  
'copyright : (c) 1995-2025, MCS Electronics  
'purpose : demo: AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
'suited for demo : yes  
'commercial add on needed : no  
'use in simulator : possible  
'--------------------------------------------------------------------------------  
'This very same program example can be used in the Help-files for  
' AND, OR, XOR, NOT, BIT, SET, RESET and MOD  
  
  
$baud = 19200  
$crystal = 8000000  
$regfile = "m88def.dat"  
  
$hwstack = 40  
$swstack = 20  
$framesize = 20  
  
Dim A As Byte , B1 As Byte , C As Byte  
Dim Aa As Bit , I As Integer  
  
```
A = 5 : B1 = 3 ' assign values  
C = A And B1 ' and a with b  
Print "A And B1 = " ; C ' print it: result = 1  
  
  
C = A Or B1  
Print "A Or B1 = " ; C ' print it: result = 7  
  
C = A Xor B1  
Print "A Xor B1 = " ; C ' print it: result = 6  
  
A = 1  
C = Not A  
Print "c = Not A " ; C ' print it: result = 254  
C = C Mod 10  
```vb
Print "C Mod 10 = " ; C ' print it: result = 4  
  
  
If Portb.1 = 1 Then 'test a bit from a PORT (which is not the same as testing the input state)  
Print "Bit set"  
Else  
Print "Bit not set"  
End If 'result = Bit not set  
  
Config Pinb.0 = Input : Portb.0 = 1 'configure as input pin  
Do  
Loop Until Pinb.0 = 0 ' repeat this loop until the logic level becomes 0  
  
```
Aa = 1 'use this or ..  
```vb
Set Aa 'use the set statement  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit set (aa=1)  
  
```
Aa = 0 'now try 0  
```vb
Reset Aa 'or use reset  
If Aa = 1 Then  
Print "Bit set (aa=1)"  
Else  
Print "Bit not set(aa=0)"  
End If 'result = Bit not set(aa=0)  
  
```
C = 8 'assign variable to &B0000_1000  
```vb
Set C 'use the set statement without specifying the bit  
Print C 'print it: result = 9 ; bit0 has been set  
  
```
B1 = 255 'assign variable  
```vb
Reset B1.0 'reset bit 0 of a byte variable  
Print B1 'print it: result = 254 = &B11111110  
  
```
B1 = 8 'assign variable to &B00001000  
```vb
Set B1.7 'set it  
Print B1 'print it: result = 9 = &B00001001  
End

```

---

## XRAM CF-Interface for simulation

The XRAM CF-Card interface is created for the purpose of testing the File System routines without hardware.

You can use an external RAM chip (XRAM) for the CF-interface but of course it is not practical in a real world application unless you backup the power with a battery.

For tests with the simulator it is ideal.

Just specify the Config_XRAMDrive.bas file and select a micro that can address external memory such as the M128. Then specify that the system is equipped with 64KB of external RAM.

You can now simulate the flashdisk.bas sample program !

In order to simulate Flashdisk.bas, set the constant XRAMDRIVE to 1. Then select 64KB of external RAM and compile.

---

## XTEADECODE

Action

Decrypts a variable or array using the XTEA protocol. This is a software implementation. 

Syntax

XTEADECODE Msg , Key , size

Remarks

Msg | The variable to decrypt. Decryption is performed in blocks of 8 bytes. This means that you need to specify an array that has a minimal size of 8 bytes. For example, 2 Longs will be 8 bytes in size. After the decryption is performed, Msg will contain the original unencrypted data.  
---|---  
Key | The 128 bit key which is used to decrypt the message data. You need to pass this as an array of 16 bytes.   
Size | The number of bytes to decrypt. This must be a multiple of 8.   
  
The XTEA encryption/decryption is described well at <http://en.wikipedia.org/wiki/XTEA>

The XTEA is an enhanced version of the TEA encryption protocol.

The XTEA encoding/decoding routines have a small footprint. You could use the XTEADECODE in a bootloader and encrypt your firmware.

When you use other tools to encode your data, you will find differences because of memory order. You can use the xtea2.lib for using the same memory order.

Include it in your code like : $LIB "xtea2.lib" 

See also

[$LOADER](loader.md) , [$AESKEY](_aeskey.md) , [AESENCRYPT](aesencrypt.md) , [AESDECRYPT](aesdecrypt.md) , [DESENCRYPT](desencrypt.md) , [DESDECRYPT](desdecrypt.md) , [$XTEAKEY](xteakey.md) , [XTEAENCODE](xteaencode.md)

Example

```vb
'----------------------------------------------------------  
' XTEA.BAS  
' This sample demonstrates the XTEA encryption/decryption  
' statements  
' (c) 1995-2025 MCS Electronics  
'----------------------------------------------------------  
$regfile = "m88def.dat"  
$hwstack = 40  
$swstack = 32  
  
  
'The XTEA encryption/decryption has a small footprint  
'XTEA processes data in blocks of 8 bytes. So the minimum length of the data is 8 bytes.  
'A 128 bit key is used to encrypt/decrypt the data. You need to supply this in an array of 8 bytes.  
  
'Using the encoding on a string can cause problems when the data contains a 0. This is the end of the string marker.  
  
Dim Key(16) As Byte ' 128 bit key  
Dim Msg(32) As Byte ' this need to be a multiple of 8  
  
Dim B As Byte ' counter byte  
  
For B = 1 To 16 ' create a simple key and also fill the data  
```
Key(b) = B  
Msg(b) = B  
Next  
  
  
Xteaencode Msg(1) , Key(1) , 32 ' encode the data  
  
```vb
For B = 1 To 16  
Print Hex(msg(b)) ; " , " ;  
Next  
Print  
  
  
```
Xteadecode Msg(1) , Key(1) , 32 ' decode the data  
  
```vb
For B = 1 To 16  
Print Hex(msg(b)) ; " , " ;

Next ' it should print 1-16 now  
Print  
  
End

```

---

## XTEAENCODE

Action

Encrypts a variable or array using the XTEA protocol.

Syntax

XTEAENCODE Msg , Key , size

Remarks

Msg | The variable to encrypt. Encryption is performed in blocks of 8 bytes. This means that you need to specify an array that has a minimal size of 8 bytes. For example, 2 Longs will be 8 bytes in size. After the encryption is performed, Msg will contain the encrypted data. The original data will be overwritten.  
---|---  
Key | The 128 bit key which is used to encrypt the message data. You need to pass this as an array of 16 bytes.   
Size | The number of bytes to encrypt. This must be a multiple of 8.   
  
The XTEA encryption/decryption is described well at <http://en.wikipedia.org/wiki/XTEA>

The XTEA is an enhanced version of the TEA encryption protocol.

The XTEA encoding/decoding routines have a small footprint. You could use the XTEADECODE in a bootloader and encrypt your firmware.

When you use other tools to encode your data, you will find differences because of memory order. You can use the xtea2.lib for using the same memory order.

Include it in your code like : $LIB "xtea2.lib" 

See also

[$LOADER](loader.md) , [$AESKEY](_aeskey.md) , [AESENCRYPT](aesencrypt.md) , [AESDECRYPT](aesdecrypt.md) , [DESENCRYPT](desencrypt.md) , [DESDECRYPT](desdecrypt.md) , [$XTEAKEY](xteakey.md) , [XTEADECODE](xteadecode.md)

Example

```vb
'----------------------------------------------------------  
' XTEA.BAS  
' This sample demonstrates the XTEA encryption/decryption  
' statements  
' (c) 1995-2025 MCS Electronics  
'----------------------------------------------------------  
$regfile = "m88def.dat"  
$hwstack = 40  
$swstack = 32  
  
  
'The XTEA encryption/decryption has a small footprint  
'XTEA processes data in blocks of 8 bytes. So the minimum length of the data is 8 bytes.  
'A 128 bit key is used to encrypt/decrypt the data. You need to supply this in an array of 8 bytes.  
  
'Using the encoding on a string can cause problems when the data contains a 0. This is the end of the string marker.  
  
Dim Key(16) As Byte ' 128 bit key  
Dim Msg(32) As Byte ' this need to be a multiple of 8  
  
Dim B As Byte ' counter byte  
  
For B = 1 To 16 ' create a simple key and also fill the data  
```
Key(b) = B  
Msg(b) = B  
Next  
  
  
Xteaencode Msg(1) , Key(1) , 32 ' encode the data  
  
```vb
For B = 1 To 16  
Print Hex(msg(b)) ; " , " ;  
Next  
Print  
  
  
```
Xteadecode Msg(1) , Key(1) , 32 ' decode the data  
  
```vb
For B = 1 To 16  
Print Hex(msg(b)) ; " , " ;

Next ' it should print 1-16 now  
Print  
  
End

```

---
